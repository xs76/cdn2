!function(e) {
    var t = {};
    function r(n) {
        if (t[n])
            return t[n].exports;
        var i = t[n] = {
            i: n,
            l: !1,
            exports: {}
        };
        return e[n].call(i.exports, i, i.exports, r),
        i.l = !0,
        i.exports
    }
    r.m = e,
    r.c = t,
    r.i = function(e) {
        return e
    }
    ,
    r.d = function(e, t, n) {
        r.o(e, t) || Object.defineProperty(e, t, {
            configurable: !1,
            enumerable: !0,
            get: n
        })
    }
    ,
    r.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return r.d(t, "a", t),
        t
    }
    ,
    r.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    r.p = "",
    r(r.s = 87)
}([function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    function i() {}
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }
    ),
    void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : e > 0 ? 1 : +e
    }
    ),
    "name"in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(e) {
        if (void 0 === e || null === e)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), r = 1; r < arguments.length; r++) {
            var n = arguments[r];
            if (void 0 !== n && null !== n)
                for (var i in n)
                    Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
        }
        return t
    }
    ),
    Object.assign(i.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var r = this._listeners;
            void 0 === r[e] && (r[e] = []),
            -1 === r[e].indexOf(t) && r[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners)
                return !1;
            var r = this._listeners;
            return void 0 !== r[e] && -1 !== r[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            if (void 0 !== this._listeners) {
                var r = this._listeners[e];
                if (void 0 !== r) {
                    var n = r.indexOf(t);
                    -1 !== n && r.splice(n, 1)
                }
            }
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var r = t.slice(0), n = 0, i = r.length; n < i; n++)
                        r[n].call(this, e)
                }
            }
        }
    });
    var o, a = "101", s = 0, c = 1, l = 2, u = 1, h = 2, p = 0, d = 1, f = 2, m = 0, v = 1, g = 2, y = 0, b = 1, x = 2, w = 3, _ = 4, M = 5, S = 100, E = 101, T = 102, A = 103, L = 104, P = 200, C = 201, R = 202, O = 203, I = 204, N = 205, D = 206, B = 207, z = 208, G = 209, U = 210, j = 0, F = 1, k = 2, H = 3, V = 4, W = 5, q = 6, X = 7, Y = 0, J = 1, Z = 2, K = 0, Q = 1, $ = 2, ee = 3, te = 4, re = 5, ne = 301, ie = 302, oe = 303, ae = 304, se = 305, ce = 306, le = 307, ue = 1e3, he = 1001, pe = 1002, de = 1003, fe = 1004, me = 1005, ve = 1006, ge = 1007, ye = 1008, be = 1009, xe = 1010, we = 1011, _e = 1012, Me = 1013, Se = 1014, Ee = 1015, Te = 1016, Ae = 1017, Le = 1018, Pe = 1019, Ce = 1020, Re = 1021, Oe = 1022, Ie = 1023, Ne = 1024, De = 1025, Be = Ie, ze = 1026, Ge = 1027, Ue = 1028, je = 33776, Fe = 33777, ke = 33778, He = 33779, Ve = 35840, We = 35841, qe = 35842, Xe = 35843, Ye = 36196, Je = 37808, Ze = 37809, Ke = 37810, Qe = 37811, $e = 37812, et = 37813, tt = 37814, rt = 37815, nt = 37816, it = 37817, ot = 37818, at = 37819, st = 37820, ct = 37821, lt = 2201, ut = 2400, ht = 0, pt = 1, dt = 2, ft = 3e3, mt = 3001, vt = 3007, gt = 3002, yt = 3004, bt = 3005, xt = 3006, wt = 3200, _t = 3201, Mt = 0, St = 1, Et = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var e = [], t = 0; t < 256; t++)
                e[t] = (t < 16 ? "0" : "") + t.toString(16);
            return function() {
                var t = 4294967295 * Math.random() | 0
                  , r = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0;
                return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & r] + e[r >> 8 & 255] + "-" + e[r >> 16 & 15 | 64] + e[r >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & i] + e[i >> 8 & 255] + e[i >> 16 & 255] + e[i >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(e, t, r) {
            return Math.max(t, Math.min(r, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, r, n, i) {
            return n + (e - t) * (i - n) / (r - t)
        },
        lerp: function(e, t, r) {
            return (1 - r) * e + r * t
        },
        smoothstep: function(e, t, r) {
            return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, r) {
            return e <= t ? 0 : e >= r ? 1 : (e = (e - t) / (r - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * Et.DEG2RAD
        },
        radToDeg: function(e) {
            return e * Et.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };
    function Tt(e, t) {
        this.x = e || 0,
        this.y = t || 0
    }
    function At() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    function Lt(e, t, r, n) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = r || 0,
        this._w = void 0 !== n ? n : 1
    }
    function Pt(e, t, r) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = r || 0
    }
    function Ct() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(Tt.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }),
    Object.assign(Tt.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e,
            this.y = t,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        },
        multiply: function(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x
              , r = this.y
              , n = e.elements;
            return this.x = n[0] * t + n[3] * r + n[6],
            this.y = n[1] * t + n[4] * r + n[7],
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        },
        clampScalar: function() {
            var e = new Tt
              , t = new Tt;
            return function(r, n) {
                return e.set(r, r),
                t.set(n, n),
                this.clamp(e, t)
            }
        }(),
        clampLength: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI),
            e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , r = this.y - e.y;
            return t * t + r * r
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        },
        lerpVectors: function(e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e
        },
        fromBufferAttribute: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this
        },
        rotateAround: function(e, t) {
            var r = Math.cos(t)
              , n = Math.sin(t)
              , i = this.x - e.x
              , o = this.y - e.y;
            return this.x = i * r - o * n + e.x,
            this.y = i * n + o * r + e.y,
            this
        }
    }),
    Object.assign(At.prototype, {
        isMatrix4: !0,
        set: function(e, t, r, n, i, o, a, s, c, l, u, h, p, d, f, m) {
            var v = this.elements;
            return v[0] = e,
            v[4] = t,
            v[8] = r,
            v[12] = n,
            v[1] = i,
            v[5] = o,
            v[9] = a,
            v[13] = s,
            v[2] = c,
            v[6] = l,
            v[10] = u,
            v[14] = h,
            v[3] = p,
            v[7] = d,
            v[11] = f,
            v[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new At).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[0] = r[0],
            t[1] = r[1],
            t[2] = r[2],
            t[3] = r[3],
            t[4] = r[4],
            t[5] = r[5],
            t[6] = r[6],
            t[7] = r[7],
            t[8] = r[8],
            t[9] = r[9],
            t[10] = r[10],
            t[11] = r[11],
            t[12] = r[12],
            t[13] = r[13],
            t[14] = r[14],
            t[15] = r[15],
            this
        },
        copyPosition: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[12] = r[12],
            t[13] = r[13],
            t[14] = r[14],
            this
        },
        extractBasis: function(e, t, r) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            r.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(e, t, r) {
            return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function() {
            var e = new Pt;
            return function(t) {
                var r = this.elements
                  , n = t.elements
                  , i = 1 / e.setFromMatrixColumn(t, 0).length()
                  , o = 1 / e.setFromMatrixColumn(t, 1).length()
                  , a = 1 / e.setFromMatrixColumn(t, 2).length();
                return r[0] = n[0] * i,
                r[1] = n[1] * i,
                r[2] = n[2] * i,
                r[3] = 0,
                r[4] = n[4] * o,
                r[5] = n[5] * o,
                r[6] = n[6] * o,
                r[7] = 0,
                r[8] = n[8] * a,
                r[9] = n[9] * a,
                r[10] = n[10] * a,
                r[11] = 0,
                r[12] = 0,
                r[13] = 0,
                r[14] = 0,
                r[15] = 1,
                this
            }
        }(),
        makeRotationFromEuler: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements
              , r = e.x
              , n = e.y
              , i = e.z
              , o = Math.cos(r)
              , a = Math.sin(r)
              , s = Math.cos(n)
              , c = Math.sin(n)
              , l = Math.cos(i)
              , u = Math.sin(i);
            if ("XYZ" === e.order) {
                var h = o * l
                  , p = o * u
                  , d = a * l
                  , f = a * u;
                t[0] = s * l,
                t[4] = -s * u,
                t[8] = c,
                t[1] = p + d * c,
                t[5] = h - f * c,
                t[9] = -a * s,
                t[2] = f - h * c,
                t[6] = d + p * c,
                t[10] = o * s
            } else if ("YXZ" === e.order) {
                var m = s * l
                  , v = s * u
                  , g = c * l
                  , y = c * u;
                t[0] = m + y * a,
                t[4] = g * a - v,
                t[8] = o * c,
                t[1] = o * u,
                t[5] = o * l,
                t[9] = -a,
                t[2] = v * a - g,
                t[6] = y + m * a,
                t[10] = o * s
            } else if ("ZXY" === e.order) {
                m = s * l,
                v = s * u,
                g = c * l,
                y = c * u;
                t[0] = m - y * a,
                t[4] = -o * u,
                t[8] = g + v * a,
                t[1] = v + g * a,
                t[5] = o * l,
                t[9] = y - m * a,
                t[2] = -o * c,
                t[6] = a,
                t[10] = o * s
            } else if ("ZYX" === e.order) {
                h = o * l,
                p = o * u,
                d = a * l,
                f = a * u;
                t[0] = s * l,
                t[4] = d * c - p,
                t[8] = h * c + f,
                t[1] = s * u,
                t[5] = f * c + h,
                t[9] = p * c - d,
                t[2] = -c,
                t[6] = a * s,
                t[10] = o * s
            } else if ("YZX" === e.order) {
                var b = o * s
                  , x = o * c
                  , w = a * s
                  , _ = a * c;
                t[0] = s * l,
                t[4] = _ - b * u,
                t[8] = w * u + x,
                t[1] = u,
                t[5] = o * l,
                t[9] = -a * l,
                t[2] = -c * l,
                t[6] = x * u + w,
                t[10] = b - _ * u
            } else if ("XZY" === e.order) {
                b = o * s,
                x = o * c,
                w = a * s,
                _ = a * c;
                t[0] = s * l,
                t[4] = -u,
                t[8] = c * l,
                t[1] = b * u + _,
                t[5] = o * l,
                t[9] = x * u - w,
                t[2] = w * u - x,
                t[6] = a * l,
                t[10] = _ * u + b
            }
            return t[3] = 0,
            t[7] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        },
        makeRotationFromQuaternion: function() {
            var e = new Pt(0,0,0)
              , t = new Pt(1,1,1);
            return function(r) {
                return this.compose(e, r, t)
            }
        }(),
        lookAt: function() {
            var e = new Pt
              , t = new Pt
              , r = new Pt;
            return function(n, i, o) {
                var a = this.elements;
                return r.subVectors(n, i),
                0 === r.lengthSq() && (r.z = 1),
                r.normalize(),
                e.crossVectors(o, r),
                0 === e.lengthSq() && (1 === Math.abs(o.z) ? r.x += 1e-4 : r.z += 1e-4,
                r.normalize(),
                e.crossVectors(o, r)),
                e.normalize(),
                t.crossVectors(r, e),
                a[0] = e.x,
                a[4] = t.x,
                a[8] = r.x,
                a[1] = e.y,
                a[5] = t.y,
                a[9] = r.y,
                a[2] = e.z,
                a[6] = t.z,
                a[10] = r.z,
                this
            }
        }(),
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var r = e.elements
              , n = t.elements
              , i = this.elements
              , o = r[0]
              , a = r[4]
              , s = r[8]
              , c = r[12]
              , l = r[1]
              , u = r[5]
              , h = r[9]
              , p = r[13]
              , d = r[2]
              , f = r[6]
              , m = r[10]
              , v = r[14]
              , g = r[3]
              , y = r[7]
              , b = r[11]
              , x = r[15]
              , w = n[0]
              , _ = n[4]
              , M = n[8]
              , S = n[12]
              , E = n[1]
              , T = n[5]
              , A = n[9]
              , L = n[13]
              , P = n[2]
              , C = n[6]
              , R = n[10]
              , O = n[14]
              , I = n[3]
              , N = n[7]
              , D = n[11]
              , B = n[15];
            return i[0] = o * w + a * E + s * P + c * I,
            i[4] = o * _ + a * T + s * C + c * N,
            i[8] = o * M + a * A + s * R + c * D,
            i[12] = o * S + a * L + s * O + c * B,
            i[1] = l * w + u * E + h * P + p * I,
            i[5] = l * _ + u * T + h * C + p * N,
            i[9] = l * M + u * A + h * R + p * D,
            i[13] = l * S + u * L + h * O + p * B,
            i[2] = d * w + f * E + m * P + v * I,
            i[6] = d * _ + f * T + m * C + v * N,
            i[10] = d * M + f * A + m * R + v * D,
            i[14] = d * S + f * L + m * O + v * B,
            i[3] = g * w + y * E + b * P + x * I,
            i[7] = g * _ + y * T + b * C + x * N,
            i[11] = g * M + y * A + b * R + x * D,
            i[15] = g * S + y * L + b * O + x * B,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        },
        applyToBufferAttribute: function() {
            var e = new Pt;
            return function(t) {
                for (var r = 0, n = t.count; r < n; r++)
                    e.x = t.getX(r),
                    e.y = t.getY(r),
                    e.z = t.getZ(r),
                    e.applyMatrix4(this),
                    t.setXYZ(r, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , r = e[4]
              , n = e[8]
              , i = e[12]
              , o = e[1]
              , a = e[5]
              , s = e[9]
              , c = e[13]
              , l = e[2]
              , u = e[6]
              , h = e[10]
              , p = e[14];
            return e[3] * (+i * s * u - n * c * u - i * a * h + r * c * h + n * a * p - r * s * p) + e[7] * (+t * s * p - t * c * h + i * o * h - n * o * p + n * c * l - i * s * l) + e[11] * (+t * c * u - t * a * p - i * o * u + r * o * p + i * a * l - r * c * l) + e[15] * (-n * a * l - t * s * u + t * a * h + n * o * u - r * o * h + r * s * l)
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        },
        setPosition: function(e) {
            var t = this.elements;
            return t[12] = e.x,
            t[13] = e.y,
            t[14] = e.z,
            this
        },
        getInverse: function(e, t) {
            var r = this.elements
              , n = e.elements
              , i = n[0]
              , o = n[1]
              , a = n[2]
              , s = n[3]
              , c = n[4]
              , l = n[5]
              , u = n[6]
              , h = n[7]
              , p = n[8]
              , d = n[9]
              , f = n[10]
              , m = n[11]
              , v = n[12]
              , g = n[13]
              , y = n[14]
              , b = n[15]
              , x = d * y * h - g * f * h + g * u * m - l * y * m - d * u * b + l * f * b
              , w = v * f * h - p * y * h - v * u * m + c * y * m + p * u * b - c * f * b
              , _ = p * g * h - v * d * h + v * l * m - c * g * m - p * l * b + c * d * b
              , M = v * d * u - p * g * u - v * l * f + c * g * f + p * l * y - c * d * y
              , S = i * x + o * w + a * _ + s * M;
            if (0 === S) {
                var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t)
                    throw new Error(E);
                return console.warn(E),
                this.identity()
            }
            var T = 1 / S;
            return r[0] = x * T,
            r[1] = (g * f * s - d * y * s - g * a * m + o * y * m + d * a * b - o * f * b) * T,
            r[2] = (l * y * s - g * u * s + g * a * h - o * y * h - l * a * b + o * u * b) * T,
            r[3] = (d * u * s - l * f * s - d * a * h + o * f * h + l * a * m - o * u * m) * T,
            r[4] = w * T,
            r[5] = (p * y * s - v * f * s + v * a * m - i * y * m - p * a * b + i * f * b) * T,
            r[6] = (v * u * s - c * y * s - v * a * h + i * y * h + c * a * b - i * u * b) * T,
            r[7] = (c * f * s - p * u * s + p * a * h - i * f * h - c * a * m + i * u * m) * T,
            r[8] = _ * T,
            r[9] = (v * d * s - p * g * s - v * o * m + i * g * m + p * o * b - i * d * b) * T,
            r[10] = (c * g * s - v * l * s + v * o * h - i * g * h - c * o * b + i * l * b) * T,
            r[11] = (p * l * s - c * d * s - p * o * h + i * d * h + c * o * m - i * l * m) * T,
            r[12] = M * T,
            r[13] = (p * g * a - v * d * a + v * o * f - i * g * f - p * o * y + i * d * y) * T,
            r[14] = (v * l * a - c * g * a - v * o * u + i * g * u + c * o * y - i * l * y) * T,
            r[15] = (c * d * a - p * l * a + p * o * u - i * d * u - c * o * f + i * l * f) * T,
            this
        },
        scale: function(e) {
            var t = this.elements
              , r = e.x
              , n = e.y
              , i = e.z;
            return t[0] *= r,
            t[4] *= n,
            t[8] *= i,
            t[1] *= r,
            t[5] *= n,
            t[9] *= i,
            t[2] *= r,
            t[6] *= n,
            t[10] *= i,
            t[3] *= r,
            t[7] *= n,
            t[11] *= i,
            this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, r, n))
        },
        makeTranslation: function(e, t, r) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e);
            return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(e, t) {
            var r = Math.cos(t)
              , n = Math.sin(t)
              , i = 1 - r
              , o = e.x
              , a = e.y
              , s = e.z
              , c = i * o
              , l = i * a;
            return this.set(c * o + r, c * a - n * s, c * s + n * a, 0, c * a + n * s, l * a + r, l * s - n * o, 0, c * s - n * a, l * s + n * o, i * s * s + r, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(e, t, r) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(e, t, r) {
            return this.set(1, t, r, 0, e, 1, r, 0, e, t, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(e, t, r) {
            var n = this.elements
              , i = t._x
              , o = t._y
              , a = t._z
              , s = t._w
              , c = i + i
              , l = o + o
              , u = a + a
              , h = i * c
              , p = i * l
              , d = i * u
              , f = o * l
              , m = o * u
              , v = a * u
              , g = s * c
              , y = s * l
              , b = s * u
              , x = r.x
              , w = r.y
              , _ = r.z;
            return n[0] = (1 - (f + v)) * x,
            n[1] = (p + b) * x,
            n[2] = (d - y) * x,
            n[3] = 0,
            n[4] = (p - b) * w,
            n[5] = (1 - (h + v)) * w,
            n[6] = (m + g) * w,
            n[7] = 0,
            n[8] = (d + y) * _,
            n[9] = (m - g) * _,
            n[10] = (1 - (h + f)) * _,
            n[11] = 0,
            n[12] = e.x,
            n[13] = e.y,
            n[14] = e.z,
            n[15] = 1,
            this
        },
        decompose: function() {
            var e = new Pt
              , t = new At;
            return function(r, n, i) {
                var o = this.elements
                  , a = e.set(o[0], o[1], o[2]).length()
                  , s = e.set(o[4], o[5], o[6]).length()
                  , c = e.set(o[8], o[9], o[10]).length();
                this.determinant() < 0 && (a = -a),
                r.x = o[12],
                r.y = o[13],
                r.z = o[14],
                t.copy(this);
                var l = 1 / a
                  , u = 1 / s
                  , h = 1 / c;
                return t.elements[0] *= l,
                t.elements[1] *= l,
                t.elements[2] *= l,
                t.elements[4] *= u,
                t.elements[5] *= u,
                t.elements[6] *= u,
                t.elements[8] *= h,
                t.elements[9] *= h,
                t.elements[10] *= h,
                n.setFromRotationMatrix(t),
                i.x = a,
                i.y = s,
                i.z = c,
                this
            }
        }(),
        makePerspective: function(e, t, r, n, i, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements
              , s = 2 * i / (t - e)
              , c = 2 * i / (r - n)
              , l = (t + e) / (t - e)
              , u = (r + n) / (r - n)
              , h = -(o + i) / (o - i)
              , p = -2 * o * i / (o - i);
            return a[0] = s,
            a[4] = 0,
            a[8] = l,
            a[12] = 0,
            a[1] = 0,
            a[5] = c,
            a[9] = u,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = h,
            a[14] = p,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        },
        makeOrthographic: function(e, t, r, n, i, o) {
            var a = this.elements
              , s = 1 / (t - e)
              , c = 1 / (r - n)
              , l = 1 / (o - i)
              , u = (t + e) * s
              , h = (r + n) * c
              , p = (o + i) * l;
            return a[0] = 2 * s,
            a[4] = 0,
            a[8] = 0,
            a[12] = -u,
            a[1] = 0,
            a[5] = 2 * c,
            a[9] = 0,
            a[13] = -h,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * l,
            a[14] = -p,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        },
        equals: function(e) {
            for (var t = this.elements, r = e.elements, n = 0; n < 16; n++)
                if (t[n] !== r[n])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var r = 0; r < 16; r++)
                this.elements[r] = e[r + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var r = this.elements;
            return e[t] = r[0],
            e[t + 1] = r[1],
            e[t + 2] = r[2],
            e[t + 3] = r[3],
            e[t + 4] = r[4],
            e[t + 5] = r[5],
            e[t + 6] = r[6],
            e[t + 7] = r[7],
            e[t + 8] = r[8],
            e[t + 9] = r[9],
            e[t + 10] = r[10],
            e[t + 11] = r[11],
            e[t + 12] = r[12],
            e[t + 13] = r[13],
            e[t + 14] = r[14],
            e[t + 15] = r[15],
            e
        }
    }),
    Object.assign(Lt, {
        slerp: function(e, t, r, n) {
            return r.copy(e).slerp(t, n)
        },
        slerpFlat: function(e, t, r, n, i, o, a) {
            var s = r[n + 0]
              , c = r[n + 1]
              , l = r[n + 2]
              , u = r[n + 3]
              , h = i[o + 0]
              , p = i[o + 1]
              , d = i[o + 2]
              , f = i[o + 3];
            if (u !== f || s !== h || c !== p || l !== d) {
                var m = 1 - a
                  , v = s * h + c * p + l * d + u * f
                  , g = v >= 0 ? 1 : -1
                  , y = 1 - v * v;
                if (y > Number.EPSILON) {
                    var b = Math.sqrt(y)
                      , x = Math.atan2(b, v * g);
                    m = Math.sin(m * x) / b,
                    a = Math.sin(a * x) / b
                }
                var w = a * g;
                if (s = s * m + h * w,
                c = c * m + p * w,
                l = l * m + d * w,
                u = u * m + f * w,
                m === 1 - a) {
                    var _ = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                    s *= _,
                    c *= _,
                    l *= _,
                    u *= _
                }
            }
            e[t] = s,
            e[t + 1] = c,
            e[t + 2] = l,
            e[t + 3] = u
        }
    }),
    Object.defineProperties(Lt.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(Lt.prototype, {
        isQuaternion: !0,
        set: function(e, t, r, n) {
            return this._x = e,
            this._y = t,
            this._z = r,
            this._w = n,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(e, t) {
            if (!e || !e.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var r = e._x
              , n = e._y
              , i = e._z
              , o = e.order
              , a = Math.cos
              , s = Math.sin
              , c = a(r / 2)
              , l = a(n / 2)
              , u = a(i / 2)
              , h = s(r / 2)
              , p = s(n / 2)
              , d = s(i / 2);
            return "XYZ" === o ? (this._x = h * l * u + c * p * d,
            this._y = c * p * u - h * l * d,
            this._z = c * l * d + h * p * u,
            this._w = c * l * u - h * p * d) : "YXZ" === o ? (this._x = h * l * u + c * p * d,
            this._y = c * p * u - h * l * d,
            this._z = c * l * d - h * p * u,
            this._w = c * l * u + h * p * d) : "ZXY" === o ? (this._x = h * l * u - c * p * d,
            this._y = c * p * u + h * l * d,
            this._z = c * l * d + h * p * u,
            this._w = c * l * u - h * p * d) : "ZYX" === o ? (this._x = h * l * u - c * p * d,
            this._y = c * p * u + h * l * d,
            this._z = c * l * d - h * p * u,
            this._w = c * l * u + h * p * d) : "YZX" === o ? (this._x = h * l * u + c * p * d,
            this._y = c * p * u + h * l * d,
            this._z = c * l * d - h * p * u,
            this._w = c * l * u - h * p * d) : "XZY" === o && (this._x = h * l * u - c * p * d,
            this._y = c * p * u - h * l * d,
            this._z = c * l * d + h * p * u,
            this._w = c * l * u + h * p * d),
            !1 !== t && this.onChangeCallback(),
            this
        },
        setFromAxisAngle: function(e, t) {
            var r = t / 2
              , n = Math.sin(r);
            return this._x = e.x * n,
            this._y = e.y * n,
            this._z = e.z * n,
            this._w = Math.cos(r),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e) {
            var t, r = e.elements, n = r[0], i = r[4], o = r[8], a = r[1], s = r[5], c = r[9], l = r[2], u = r[6], h = r[10], p = n + s + h;
            return p > 0 ? (t = .5 / Math.sqrt(p + 1),
            this._w = .25 / t,
            this._x = (u - c) * t,
            this._y = (o - l) * t,
            this._z = (a - i) * t) : n > s && n > h ? (t = 2 * Math.sqrt(1 + n - s - h),
            this._w = (u - c) / t,
            this._x = .25 * t,
            this._y = (i + a) / t,
            this._z = (o + l) / t) : s > h ? (t = 2 * Math.sqrt(1 + s - n - h),
            this._w = (o - l) / t,
            this._x = (i + a) / t,
            this._y = .25 * t,
            this._z = (c + u) / t) : (t = 2 * Math.sqrt(1 + h - n - s),
            this._w = (a - i) / t,
            this._x = (o + l) / t,
            this._y = (c + u) / t,
            this._z = .25 * t),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: function() {
            var e, t = new Pt;
            return function(r, n) {
                return void 0 === t && (t = new Pt),
                (e = r.dot(n) + 1) < 1e-6 ? (e = 0,
                Math.abs(r.x) > Math.abs(r.z) ? t.set(-r.y, r.x, 0) : t.set(0, -r.z, r.y)) : t.crossVectors(r, n),
                this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = e,
                this.normalize()
            }
        }(),
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(Et.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var r = this.angleTo(e);
            if (0 === r)
                return this;
            var n = Math.min(1, t / r);
            return this.slerp(e, n),
            this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (e = 1 / e,
            this._x = this._x * e,
            this._y = this._y * e,
            this._z = this._z * e,
            this._w = this._w * e),
            this.onChangeCallback(),
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var r = e._x
              , n = e._y
              , i = e._z
              , o = e._w
              , a = t._x
              , s = t._y
              , c = t._z
              , l = t._w;
            return this._x = r * l + o * a + n * c - i * s,
            this._y = n * l + o * s + i * a - r * c,
            this._z = i * l + o * c + r * s - n * a,
            this._w = o * l - r * a - n * s - i * c,
            this.onChangeCallback(),
            this
        },
        slerp: function(e, t) {
            if (0 === t)
                return this;
            if (1 === t)
                return this.copy(e);
            var r = this._x
              , n = this._y
              , i = this._z
              , o = this._w
              , a = o * e._w + r * e._x + n * e._y + i * e._z;
            if (a < 0 ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            a = -a) : this.copy(e),
            a >= 1)
                return this._w = o,
                this._x = r,
                this._y = n,
                this._z = i,
                this;
            var s = 1 - a * a;
            if (s <= Number.EPSILON) {
                var c = 1 - t;
                return this._w = c * o + t * this._w,
                this._x = c * r + t * this._x,
                this._y = c * n + t * this._y,
                this._z = c * i + t * this._z,
                this.normalize()
            }
            var l = Math.sqrt(s)
              , u = Math.atan2(l, a)
              , h = Math.sin((1 - t) * u) / l
              , p = Math.sin(t * u) / l;
            return this._w = o * h + this._w * p,
            this._x = r * h + this._x * p,
            this._y = n * h + this._y * p,
            this._z = i * h + this._z * p,
            this.onChangeCallback(),
            this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this._x = e[t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(Pt.prototype, {
        isVector3: !0,
        set: function(e, t, r) {
            return this.x = e,
            this.y = t,
            this.z = r,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(e, t)) : (this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this)
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        },
        applyEuler: function() {
            var e = new Lt;
            return function(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(e.setFromEuler(t))
            }
        }(),
        applyAxisAngle: function() {
            var e = new Lt;
            return function(t, r) {
                return this.applyQuaternion(e.setFromAxisAngle(t, r))
            }
        }(),
        applyMatrix3: function(e) {
            var t = this.x
              , r = this.y
              , n = this.z
              , i = e.elements;
            return this.x = i[0] * t + i[3] * r + i[6] * n,
            this.y = i[1] * t + i[4] * r + i[7] * n,
            this.z = i[2] * t + i[5] * r + i[8] * n,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , r = this.y
              , n = this.z
              , i = e.elements
              , o = 1 / (i[3] * t + i[7] * r + i[11] * n + i[15]);
            return this.x = (i[0] * t + i[4] * r + i[8] * n + i[12]) * o,
            this.y = (i[1] * t + i[5] * r + i[9] * n + i[13]) * o,
            this.z = (i[2] * t + i[6] * r + i[10] * n + i[14]) * o,
            this
        },
        applyQuaternion: function(e) {
            var t = this.x
              , r = this.y
              , n = this.z
              , i = e.x
              , o = e.y
              , a = e.z
              , s = e.w
              , c = s * t + o * n - a * r
              , l = s * r + a * t - i * n
              , u = s * n + i * r - o * t
              , h = -i * t - o * r - a * n;
            return this.x = c * s + h * -i + l * -a - u * -o,
            this.y = l * s + h * -o + u * -i - c * -a,
            this.z = u * s + h * -a + c * -o - l * -i,
            this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function() {
            var e = new At;
            return function(t) {
                return this.applyMatrix4(e.getInverse(t.projectionMatrix)).applyMatrix4(t.matrixWorld)
            }
        }(),
        transformDirection: function(e) {
            var t = this.x
              , r = this.y
              , n = this.z
              , i = e.elements;
            return this.x = i[0] * t + i[4] * r + i[8] * n,
            this.y = i[1] * t + i[5] * r + i[9] * n,
            this.z = i[2] * t + i[6] * r + i[10] * n,
            this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        },
        clampScalar: function() {
            var e = new Pt
              , t = new Pt;
            return function(r, n) {
                return e.set(r, r, r),
                t.set(n, n, n),
                this.clamp(e, t)
            }
        }(),
        clampLength: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        },
        lerpVectors: function(e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e)
        },
        cross: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var r = e.x
              , n = e.y
              , i = e.z
              , o = t.x
              , a = t.y
              , s = t.z;
            return this.x = n * s - i * a,
            this.y = i * o - r * s,
            this.z = r * a - n * o,
            this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: function() {
            var e = new Pt;
            return function(t) {
                return e.copy(this).projectOnVector(t),
                this.sub(e)
            }
        }(),
        reflect: function() {
            var e = new Pt;
            return function(t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function(e) {
            var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
            return Math.acos(Et.clamp(t, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , r = this.y - e.y
              , n = this.z - e.z;
            return t * t + r * r + n * n
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, r) {
            var n = Math.sin(t) * e;
            return this.x = n * Math.sin(r),
            this.y = Math.cos(t) * e,
            this.z = n * Math.cos(r),
            this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, r) {
            return this.x = e * Math.sin(t),
            this.y = r,
            this.z = e * Math.cos(t),
            this
        },
        setFromMatrixPosition: function(e) {
            var t = e.elements;
            return this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length()
              , r = this.setFromMatrixColumn(e, 1).length()
              , n = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
            this.y = r,
            this.z = n,
            this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        },
        fromBufferAttribute: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        }
    }),
    Object.assign(Ct.prototype, {
        isMatrix3: !0,
        set: function(e, t, r, n, i, o, a, s, c) {
            var l = this.elements;
            return l[0] = e,
            l[1] = n,
            l[2] = a,
            l[3] = t,
            l[4] = i,
            l[5] = s,
            l[6] = r,
            l[7] = o,
            l[8] = c,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , r = e.elements;
            return t[0] = r[0],
            t[1] = r[1],
            t[2] = r[2],
            t[3] = r[3],
            t[4] = r[4],
            t[5] = r[5],
            t[6] = r[6],
            t[7] = r[7],
            t[8] = r[8],
            this
        },
        setFromMatrix4: function(e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        },
        applyToBufferAttribute: function() {
            var e = new Pt;
            return function(t) {
                for (var r = 0, n = t.count; r < n; r++)
                    e.x = t.getX(r),
                    e.y = t.getY(r),
                    e.z = t.getZ(r),
                    e.applyMatrix3(this),
                    t.setXYZ(r, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var r = e.elements
              , n = t.elements
              , i = this.elements
              , o = r[0]
              , a = r[3]
              , s = r[6]
              , c = r[1]
              , l = r[4]
              , u = r[7]
              , h = r[2]
              , p = r[5]
              , d = r[8]
              , f = n[0]
              , m = n[3]
              , v = n[6]
              , g = n[1]
              , y = n[4]
              , b = n[7]
              , x = n[2]
              , w = n[5]
              , _ = n[8];
            return i[0] = o * f + a * g + s * x,
            i[3] = o * m + a * y + s * w,
            i[6] = o * v + a * b + s * _,
            i[1] = c * f + l * g + u * x,
            i[4] = c * m + l * y + u * w,
            i[7] = c * v + l * b + u * _,
            i[2] = h * f + p * g + d * x,
            i[5] = h * m + p * y + d * w,
            i[8] = h * v + p * b + d * _,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        },
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , r = e[1]
              , n = e[2]
              , i = e[3]
              , o = e[4]
              , a = e[5]
              , s = e[6]
              , c = e[7]
              , l = e[8];
            return t * o * l - t * a * c - r * i * l + r * a * s + n * i * c - n * o * s
        },
        getInverse: function(e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var r = e.elements
              , n = this.elements
              , i = r[0]
              , o = r[1]
              , a = r[2]
              , s = r[3]
              , c = r[4]
              , l = r[5]
              , u = r[6]
              , h = r[7]
              , p = r[8]
              , d = p * c - l * h
              , f = l * u - p * s
              , m = h * s - c * u
              , v = i * d + o * f + a * m;
            if (0 === v) {
                var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t)
                    throw new Error(g);
                return console.warn(g),
                this.identity()
            }
            var y = 1 / v;
            return n[0] = d * y,
            n[1] = (a * h - p * o) * y,
            n[2] = (l * o - a * c) * y,
            n[3] = f * y,
            n[4] = (p * i - a * u) * y,
            n[5] = (a * s - l * i) * y,
            n[6] = m * y,
            n[7] = (o * u - h * i) * y,
            n[8] = (c * i - o * s) * y,
            this
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        },
        setUvTransform: function(e, t, r, n, i, o, a) {
            var s = Math.cos(i)
              , c = Math.sin(i);
            this.set(r * s, r * c, -r * (s * o + c * a) + o + e, -n * c, n * s, -n * (-c * o + s * a) + a + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var r = this.elements;
            return r[0] *= e,
            r[3] *= e,
            r[6] *= e,
            r[1] *= t,
            r[4] *= t,
            r[7] *= t,
            this
        },
        rotate: function(e) {
            var t = Math.cos(e)
              , r = Math.sin(e)
              , n = this.elements
              , i = n[0]
              , o = n[3]
              , a = n[6]
              , s = n[1]
              , c = n[4]
              , l = n[7];
            return n[0] = t * i + r * s,
            n[3] = t * o + r * c,
            n[6] = t * a + r * l,
            n[1] = -r * i + t * s,
            n[4] = -r * o + t * c,
            n[7] = -r * a + t * l,
            this
        },
        translate: function(e, t) {
            var r = this.elements;
            return r[0] += e * r[2],
            r[3] += e * r[5],
            r[6] += e * r[8],
            r[1] += t * r[2],
            r[4] += t * r[5],
            r[7] += t * r[8],
            this
        },
        equals: function(e) {
            for (var t = this.elements, r = e.elements, n = 0; n < 9; n++)
                if (t[n] !== r[n])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var r = 0; r < 9; r++)
                this.elements[r] = e[r + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var r = this.elements;
            return e[t] = r[0],
            e[t + 1] = r[1],
            e[t + 2] = r[2],
            e[t + 3] = r[3],
            e[t + 4] = r[4],
            e[t + 5] = r[5],
            e[t + 6] = r[6],
            e[t + 7] = r[7],
            e[t + 8] = r[8],
            e
        }
    });
    var Rt = {
        getDataURL: function(e) {
            var t;
            if ("undefined" == typeof HTMLCanvasElement)
                return e.src;
            if (e instanceof HTMLCanvasElement)
                t = e;
            else {
                void 0 === o && (o = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                o.width = e.width,
                o.height = e.height;
                var r = o.getContext("2d");
                e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
                t = o
            }
            return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
    }
      , Ot = 0;
    function It(e, t, r, n, i, o, a, s, c, l) {
        Object.defineProperty(this, "id", {
            value: Ot++
        }),
        this.uuid = Et.generateUUID(),
        this.name = "",
        this.image = void 0 !== e ? e : It.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== t ? t : It.DEFAULT_MAPPING,
        this.wrapS = void 0 !== r ? r : he,
        this.wrapT = void 0 !== n ? n : he,
        this.magFilter = void 0 !== i ? i : ve,
        this.minFilter = void 0 !== o ? o : ye,
        this.anisotropy = void 0 !== c ? c : 1,
        this.format = void 0 !== a ? a : Ie,
        this.type = void 0 !== s ? s : be,
        this.offset = new Tt(0,0),
        this.repeat = new Tt(1,1),
        this.center = new Tt(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Ct,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== l ? l : ft,
        this.version = 0,
        this.onUpdate = null
    }
    function Nt(e, t, r, n) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = r || 0,
        this.w = void 0 !== n ? n : 1
    }
    function Dt(e, t, r) {
        this.width = e,
        this.height = t,
        this.scissor = new Nt(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Nt(0,0,e,t),
        r = r || {},
        this.texture = new It(void 0,void 0,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),
        this.texture.generateMipmaps = void 0 !== r.generateMipmaps && r.generateMipmaps,
        this.texture.minFilter = void 0 !== r.minFilter ? r.minFilter : ve,
        this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer,
        this.stencilBuffer = void 0 === r.stencilBuffer || r.stencilBuffer,
        this.depthTexture = void 0 !== r.depthTexture ? r.depthTexture : null
    }
    function Bt(e, t, r) {
        Dt.call(this, e, t, r),
        this.samples = 4
    }
    function zt(e, t, r) {
        Dt.call(this, e, t, r),
        this.activeCubeFace = 0,
        this.activeMipMapLevel = 0
    }
    function Gt(e, t, r, n, i, o, a, s, c, l, u, h) {
        It.call(this, null, o, a, s, c, l, n, i, u, h),
        this.image = {
            data: e,
            width: t,
            height: r
        },
        this.magFilter = void 0 !== c ? c : de,
        this.minFilter = void 0 !== l ? l : de,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
    function Ut(e, t) {
        this.min = void 0 !== e ? e : new Pt(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new Pt(-1 / 0,-1 / 0,-1 / 0)
    }
    function jt(e, t) {
        this.center = void 0 !== e ? e : new Pt,
        this.radius = void 0 !== t ? t : 0
    }
    function Ft(e, t) {
        this.normal = void 0 !== e ? e : new Pt(1,0,0),
        this.constant = void 0 !== t ? t : 0
    }
    function kt(e, t, r, n, i, o) {
        this.planes = [void 0 !== e ? e : new Ft, void 0 !== t ? t : new Ft, void 0 !== r ? r : new Ft, void 0 !== n ? n : new Ft, void 0 !== i ? i : new Ft, void 0 !== o ? o : new Ft]
    }
    It.DEFAULT_IMAGE = void 0,
    It.DEFAULT_MAPPING = 300,
    It.prototype = Object.assign(Object.create(i.prototype), {
        constructor: It,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name,
            this.image = e.image,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.encoding = e.encoding,
            this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
                return e.textures[this.uuid];
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = Et.generateUUID()),
                !t && void 0 === e.images[n.uuid]) {
                    var i;
                    if (Array.isArray(n)) {
                        i = [];
                        for (var o = 0, a = n.length; o < a; o++)
                            i.push(Rt.getDataURL(n[o]))
                    } else
                        i = Rt.getDataURL(n);
                    e.images[n.uuid] = {
                        uuid: n.uuid,
                        url: i
                    }
                }
                r.image = n.uuid
            }
            return t || (e.textures[this.uuid] = r),
            r
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (300 !== this.mapping)
                return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
                switch (this.wrapS) {
                case ue:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case he:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case pe:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                case ue:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case he:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case pe:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
            return this.flipY && (e.y = 1 - e.y),
            e
        }
    }),
    Object.defineProperty(It.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(Nt.prototype, {
        isVector4: !0,
        set: function(e, t, r, n) {
            return this.x = e,
            this.y = t,
            this.z = r,
            this.w = n,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this.w = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setW: function(e) {
            return this.w = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = void 0 !== e.w ? e.w : 1,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , r = this.y
              , n = this.z
              , i = this.w
              , o = e.elements;
            return this.x = o[0] * t + o[4] * r + o[8] * n + o[12] * i,
            this.y = o[1] * t + o[5] * r + o[9] * n + o[13] * i,
            this.z = o[2] * t + o[6] * r + o[10] * n + o[14] * i,
            this.w = o[3] * t + o[7] * r + o[11] * n + o[15] * i,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t, r, n, i, o = e.elements, a = o[0], s = o[4], c = o[8], l = o[1], u = o[5], h = o[9], p = o[2], d = o[6], f = o[10];
            if (Math.abs(s - l) < .01 && Math.abs(c - p) < .01 && Math.abs(h - d) < .01) {
                if (Math.abs(s + l) < .1 && Math.abs(c + p) < .1 && Math.abs(h + d) < .1 && Math.abs(a + u + f - 3) < .1)
                    return this.set(1, 0, 0, 0),
                    this;
                t = Math.PI;
                var m = (a + 1) / 2
                  , v = (u + 1) / 2
                  , g = (f + 1) / 2
                  , y = (s + l) / 4
                  , b = (c + p) / 4
                  , x = (h + d) / 4;
                return m > v && m > g ? m < .01 ? (r = 0,
                n = .707106781,
                i = .707106781) : (n = y / (r = Math.sqrt(m)),
                i = b / r) : v > g ? v < .01 ? (r = .707106781,
                n = 0,
                i = .707106781) : (r = y / (n = Math.sqrt(v)),
                i = x / n) : g < .01 ? (r = .707106781,
                n = .707106781,
                i = 0) : (r = b / (i = Math.sqrt(g)),
                n = x / i),
                this.set(r, n, i, t),
                this
            }
            var w = Math.sqrt((d - h) * (d - h) + (c - p) * (c - p) + (l - s) * (l - s));
            return Math.abs(w) < .001 && (w = 1),
            this.x = (d - h) / w,
            this.y = (c - p) / w,
            this.z = (l - s) / w,
            this.w = Math.acos((a + u + f - 1) / 2),
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        },
        clampScalar: function() {
            var e, t;
            return function(r, n) {
                return void 0 === e && (e = new Nt,
                t = new Nt),
                e.set(r, r, r, r),
                t.set(n, n, n, n),
                this.clamp(e, t)
            }
        }(),
        clampLength: function(e, t) {
            var r = this.length();
            return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        },
        lerpVectors: function(e, t, r) {
            return this.subVectors(t, e).multiplyScalar(r).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        },
        fromBufferAttribute: function(e, t, r) {
            return void 0 !== r && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        }
    }),
    Dt.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Dt,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e,
            this.height = t,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width,
            this.height = e.height,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            this.depthTexture = e.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Bt.prototype = Object.assign(Object.create(Dt.prototype), {
        constructor: Bt,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return Dt.prototype.copy.call(this, e),
            this.samples = e.samples,
            this
        }
    }),
    zt.prototype = Object.create(Dt.prototype),
    zt.prototype.constructor = zt,
    zt.prototype.isWebGLRenderTargetCube = !0,
    Gt.prototype = Object.create(It.prototype),
    Gt.prototype.constructor = Gt,
    Gt.prototype.isDataTexture = !0,
    Object.assign(Ut.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
                var l = e[s]
                  , u = e[s + 1]
                  , h = e[s + 2];
                l < t && (t = l),
                u < r && (r = u),
                h < n && (n = h),
                l > i && (i = l),
                u > o && (o = u),
                h > a && (a = h)
            }
            return this.min.set(t, r, n),
            this.max.set(i, o, a),
            this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, r = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = e.count; s < c; s++) {
                var l = e.getX(s)
                  , u = e.getY(s)
                  , h = e.getZ(s);
                l < t && (t = l),
                u < r && (r = u),
                h < n && (n = h),
                l > i && (i = l),
                u > o && (o = u),
                h > a && (a = h)
            }
            return this.min.set(t, r, n),
            this.max.set(i, o, a),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, r = e.length; t < r; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new Pt;
            return function(t, r) {
                var n = e.copy(r).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
        }(),
        setFromObject: function(e) {
            return this.makeEmpty(),
            this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"),
            e = new Pt),
            this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"),
            e = new Pt),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        expandByObject: function() {
            var e, t, r, n = new Pt;
            function i(i) {
                var o = i.geometry;
                if (void 0 !== o)
                    if (o.isGeometry) {
                        var a = o.vertices;
                        for (t = 0,
                        r = a.length; t < r; t++)
                            n.copy(a[t]),
                            n.applyMatrix4(i.matrixWorld),
                            e.expandByPoint(n)
                    } else if (o.isBufferGeometry) {
                        var s = o.attributes.position;
                        if (void 0 !== s)
                            for (t = 0,
                            r = s.count; t < r; t++)
                                n.fromBufferAttribute(s, t).applyMatrix4(i.matrixWorld),
                                e.expandByPoint(n)
                    }
            }
            return function(t) {
                return e = this,
                t.updateMatrixWorld(!0),
                t.traverse(i),
                this
            }
        }(),
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"),
            t = new Pt),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var e = new Pt;
            return function(t) {
                return this.clampPoint(t.center, e),
                e.distanceToSquared(t.center) <= t.radius * t.radius
            }
        }(),
        intersectsPlane: function(e) {
            var t, r;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
            r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            r = e.normal.x * this.min.x),
            e.normal.y > 0 ? (t += e.normal.y * this.min.y,
            r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            r += e.normal.y * this.min.y),
            e.normal.z > 0 ? (t += e.normal.z * this.min.z,
            r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            r += e.normal.z * this.min.z),
            t <= -e.constant && r >= -e.constant
        },
        intersectsTriangle: function() {
            var e = new Pt
              , t = new Pt
              , r = new Pt
              , n = new Pt
              , i = new Pt
              , o = new Pt
              , a = new Pt
              , s = new Pt
              , c = new Pt
              , l = new Pt;
            function u(n) {
                var i, o;
                for (i = 0,
                o = n.length - 3; i <= o; i += 3) {
                    a.fromArray(n, i);
                    var s = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z)
                      , l = e.dot(a)
                      , u = t.dot(a)
                      , h = r.dot(a);
                    if (Math.max(-Math.max(l, u, h), Math.min(l, u, h)) > s)
                        return !1
                }
                return !0
            }
            return function(a) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(s),
                c.subVectors(this.max, s),
                e.subVectors(a.a, s),
                t.subVectors(a.b, s),
                r.subVectors(a.c, s),
                n.subVectors(t, e),
                i.subVectors(r, t),
                o.subVectors(e, r);
                var h = [0, -n.z, n.y, 0, -i.z, i.y, 0, -o.z, o.y, n.z, 0, -n.x, i.z, 0, -i.x, o.z, 0, -o.x, -n.y, n.x, 0, -i.y, i.x, 0, -o.y, o.x, 0];
                return !!u(h) && (!!u(h = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (l.crossVectors(n, i),
                u(h = [l.x, l.y, l.z])))
            }
        }(),
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            t = new Pt),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new Pt;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function() {
            var e = new Pt;
            return function(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"),
                t = new jt),
                this.getCenter(t.center),
                t.radius = .5 * this.getSize(e).length(),
                t
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        applyMatrix4: function() {
            var e = [new Pt, new Pt, new Pt, new Pt, new Pt, new Pt, new Pt, new Pt];
            return function(t) {
                return this.isEmpty() ? this : (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(e),
                this)
            }
        }(),
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(jt.prototype, {
        set: function(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        },
        setFromPoints: function() {
            var e = new Ut;
            return function(t, r) {
                var n = this.center;
                void 0 !== r ? n.copy(r) : e.setFromPoints(t).getCenter(n);
                for (var i = 0, o = 0, a = t.length; o < a; o++)
                    i = Math.max(i, n.distanceToSquared(t[o]));
                return this.radius = Math.sqrt(i),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var r = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            t = new Pt),
            t.copy(e),
            r > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            e = new Ut),
            e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e),
            this.radius = this.radius * e.getMaxScaleOnAxis(),
            this
        },
        translate: function(e) {
            return this.center.add(e),
            this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }),
    Object.assign(Ft.prototype, {
        set: function(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        },
        setComponents: function(e, t, r, n) {
            return this.normal.set(e, t, r),
            this.constant = n,
            this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function() {
            var e = new Pt
              , t = new Pt;
            return function(r, n, i) {
                var o = e.subVectors(i, n).cross(t.subVectors(r, n)).normalize();
                return this.setFromNormalAndCoplanarPoint(o, r),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            t = new Pt),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function() {
            var e = new Pt;
            return function(t, r) {
                void 0 === r && (console.warn("THREE.Plane: .intersectLine() target is now required"),
                r = new Pt);
                var n = t.delta(e)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(t.start) ? r.copy(t.start) : void 0;
                var o = -(t.start.dot(this.normal) + this.constant) / i;
                return o < 0 || o > 1 ? void 0 : r.copy(n).multiplyScalar(o).add(t.start)
            }
        }(),
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start)
              , r = this.distanceToPoint(e.end);
            return t < 0 && r > 0 || r < 0 && t > 0
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            e = new Pt),
            e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var e = new Pt
              , t = new Ct;
            return function(r, n) {
                var i = n || t.getNormalMatrix(r)
                  , o = this.coplanarPoint(e).applyMatrix4(r)
                  , a = this.normal.applyMatrix3(i).normalize();
                return this.constant = -o.dot(a),
                this
            }
        }(),
        translate: function(e) {
            return this.constant -= e.dot(this.normal),
            this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }),
    Object.assign(kt.prototype, {
        set: function(e, t, r, n, i, o) {
            var a = this.planes;
            return a[0].copy(e),
            a[1].copy(t),
            a[2].copy(r),
            a[3].copy(n),
            a[4].copy(i),
            a[5].copy(o),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, r = 0; r < 6; r++)
                t[r].copy(e.planes[r]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes
              , r = e.elements
              , n = r[0]
              , i = r[1]
              , o = r[2]
              , a = r[3]
              , s = r[4]
              , c = r[5]
              , l = r[6]
              , u = r[7]
              , h = r[8]
              , p = r[9]
              , d = r[10]
              , f = r[11]
              , m = r[12]
              , v = r[13]
              , g = r[14]
              , y = r[15];
            return t[0].setComponents(a - n, u - s, f - h, y - m).normalize(),
            t[1].setComponents(a + n, u + s, f + h, y + m).normalize(),
            t[2].setComponents(a + i, u + c, f + p, y + v).normalize(),
            t[3].setComponents(a - i, u - c, f - p, y - v).normalize(),
            t[4].setComponents(a - o, u - l, f - d, y - g).normalize(),
            t[5].setComponents(a + o, u + l, f + d, y + g).normalize(),
            this
        },
        intersectsObject: function() {
            var e = new jt;
            return function(t) {
                var r = t.geometry;
                return null === r.boundingSphere && r.computeBoundingSphere(),
                e.copy(r.boundingSphere).applyMatrix4(t.matrixWorld),
                this.intersectsSphere(e)
            }
        }(),
        intersectsSprite: function() {
            var e = new jt;
            return function(t) {
                return e.center.set(0, 0, 0),
                e.radius = .7071067811865476,
                e.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function(e) {
            for (var t = this.planes, r = e.center, n = -e.radius, i = 0; i < 6; i++) {
                if (t[i].distanceToPoint(r) < n)
                    return !1
            }
            return !0
        },
        intersectsBox: function() {
            var e = new Pt;
            return function(t) {
                for (var r = this.planes, n = 0; n < 6; n++) {
                    var i = r[n];
                    if (e.x = i.normal.x > 0 ? t.max.x : t.min.x,
                    e.y = i.normal.y > 0 ? t.max.y : t.min.y,
                    e.z = i.normal.z > 0 ? t.max.z : t.min.z,
                    i.distanceToPoint(e) < 0)
                        return !1
                }
                return !0
            }
        }(),
        containsPoint: function(e) {
            for (var t = this.planes, r = 0; r < 6; r++)
                if (t[r].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
    });
    var Ht = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    };
    function Vt(e) {
        var t = {};
        for (var r in e)
            for (var n in t[r] = {},
            e[r]) {
                var i = e[r][n];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[r][n] = i.clone() : Array.isArray(i) ? t[r][n] = i.slice() : t[r][n] = i
            }
        return t
    }
    function Wt(e) {
        for (var t = {}, r = 0; r < e.length; r++) {
            var n = Vt(e[r]);
            for (var i in n)
                t[i] = n[i]
        }
        return t
    }
    var qt = {
        clone: Vt,
        merge: Wt
    }
      , Xt = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    function Yt(e, t, r) {
        return void 0 === t && void 0 === r ? this.set(e) : this.setRGB(e, t, r)
    }
    Object.assign(Yt.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
            this
        },
        setScalar: function(e) {
            return this.r = e,
            this.g = e,
            this.b = e,
            this
        },
        setHex: function(e) {
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (255 & e) / 255,
            this
        },
        setRGB: function(e, t, r) {
            return this.r = e,
            this.g = t,
            this.b = r,
            this
        },
        setHSL: function() {
            function e(e, t, r) {
                return r < 0 && (r += 1),
                r > 1 && (r -= 1),
                r < 1 / 6 ? e + 6 * (t - e) * r : r < .5 ? t : r < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - r) : e
            }
            return function(t, r, n) {
                if (t = Et.euclideanModulo(t, 1),
                r = Et.clamp(r, 0, 1),
                n = Et.clamp(n, 0, 1),
                0 === r)
                    this.r = this.g = this.b = n;
                else {
                    var i = n <= .5 ? n * (1 + r) : n + r - n * r
                      , o = 2 * n - i;
                    this.r = e(o, i, t + 1 / 3),
                    this.g = e(o, i, t),
                    this.b = e(o, i, t - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            var r;
            if (r = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var n, i = r[1], o = r[2];
                switch (i) {
                case "rgb":
                case "rgba":
                    if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                        return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(n[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(n[3], 10)) / 255,
                        t(n[5]),
                        this;
                    if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                        return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(n[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(n[3], 10)) / 100,
                        t(n[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                        var a = parseFloat(n[1]) / 360
                          , s = parseInt(n[2], 10) / 100
                          , c = parseInt(n[3], 10) / 100;
                        return t(n[5]),
                        this.setHSL(a, s, c)
                    }
                }
            } else if (r = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                var l, u = (l = r[1]).length;
                if (3 === u)
                    return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255,
                    this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255,
                    this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255,
                    this;
                if (6 === u)
                    return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255,
                    this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255,
                    this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255,
                    this
            }
            e && e.length > 0 && (void 0 !== (l = Xt[e]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e));
            return this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2),
            this.r = Math.pow(e.r, t),
            this.g = Math.pow(e.g, t),
            this.b = Math.pow(e.b, t),
            this
        },
        copyLinearToGamma: function(e, t) {
            void 0 === t && (t = 2);
            var r = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, r),
            this.g = Math.pow(e.g, r),
            this.b = Math.pow(e.b, r),
            this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e),
            this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e),
            this
        },
        copySRGBToLinear: function() {
            function e(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            return function(t) {
                return this.r = e(t.r),
                this.g = e(t.g),
                this.b = e(t.b),
                this
            }
        }(),
        copyLinearToSRGB: function() {
            function e(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            return function(t) {
                return this.r = e(t.r),
                this.g = e(t.g),
                this.b = e(t.b),
                this
            }
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"),
            e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, r, n = this.r, i = this.g, o = this.b, a = Math.max(n, i, o), s = Math.min(n, i, o), c = (s + a) / 2;
            if (s === a)
                t = 0,
                r = 0;
            else {
                var l = a - s;
                switch (r = c <= .5 ? l / (a + s) : l / (2 - a - s),
                a) {
                case n:
                    t = (i - o) / l + (i < o ? 6 : 0);
                    break;
                case i:
                    t = (o - n) / l + 2;
                    break;
                case o:
                    t = (n - i) / l + 4
                }
                t /= 6
            }
            return e.h = t,
            e.s = r,
            e.l = c,
            e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function() {
            var e = {};
            return function(t, r, n) {
                return this.getHSL(e),
                e.h += t,
                e.s += r,
                e.l += n,
                this.setHSL(e.h, e.s, e.l),
                this
            }
        }(),
        add: function(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        },
        addScalar: function(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        },
        multiply: function(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        },
        multiplyScalar: function(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        },
        lerpHSL: function() {
            var e = {
                h: 0,
                s: 0,
                l: 0
            }
              , t = {
                h: 0,
                s: 0,
                l: 0
            };
            return function(r, n) {
                this.getHSL(e),
                r.getHSL(t);
                var i = Et.lerp(e.h, t.h, n)
                  , o = Et.lerp(e.s, t.s, n)
                  , a = Et.lerp(e.l, t.l, n);
                return this.setHSL(i, o, a),
                this
            }
        }(),
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.r = e[t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var Jt = {
        common: {
            diffuse: {
                value: new Yt(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Ct
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Tt(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Yt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Yt(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Ct
            }
        },
        sprite: {
            diffuse: {
                value: new Yt(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Tt(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Ct
            }
        }
    }
      , Zt = {
        basic: {
            uniforms: Wt([Jt.common, Jt.specularmap, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.fog]),
            vertexShader: Ht.meshbasic_vert,
            fragmentShader: Ht.meshbasic_frag
        },
        lambert: {
            uniforms: Wt([Jt.common, Jt.specularmap, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.emissivemap, Jt.fog, Jt.lights, {
                emissive: {
                    value: new Yt(0)
                }
            }]),
            vertexShader: Ht.meshlambert_vert,
            fragmentShader: Ht.meshlambert_frag
        },
        phong: {
            uniforms: Wt([Jt.common, Jt.specularmap, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.emissivemap, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, Jt.gradientmap, Jt.fog, Jt.lights, {
                emissive: {
                    value: new Yt(0)
                },
                specular: {
                    value: new Yt(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Ht.meshphong_vert,
            fragmentShader: Ht.meshphong_frag
        },
        standard: {
            uniforms: Wt([Jt.common, Jt.envmap, Jt.aomap, Jt.lightmap, Jt.emissivemap, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, Jt.roughnessmap, Jt.metalnessmap, Jt.fog, Jt.lights, {
                emissive: {
                    value: new Yt(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Ht.meshphysical_vert,
            fragmentShader: Ht.meshphysical_frag
        },
        matcap: {
            uniforms: Wt([Jt.common, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, Jt.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Ht.meshmatcap_vert,
            fragmentShader: Ht.meshmatcap_frag
        },
        points: {
            uniforms: Wt([Jt.points, Jt.fog]),
            vertexShader: Ht.points_vert,
            fragmentShader: Ht.points_frag
        },
        dashed: {
            uniforms: Wt([Jt.common, Jt.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Ht.linedashed_vert,
            fragmentShader: Ht.linedashed_frag
        },
        depth: {
            uniforms: Wt([Jt.common, Jt.displacementmap]),
            vertexShader: Ht.depth_vert,
            fragmentShader: Ht.depth_frag
        },
        normal: {
            uniforms: Wt([Jt.common, Jt.bumpmap, Jt.normalmap, Jt.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ht.normal_vert,
            fragmentShader: Ht.normal_frag
        },
        sprite: {
            uniforms: Wt([Jt.sprite, Jt.fog]),
            vertexShader: Ht.sprite_vert,
            fragmentShader: Ht.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Ct
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: Ht.background_vert,
            fragmentShader: Ht.background_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Ht.cube_vert,
            fragmentShader: Ht.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Ht.equirect_vert,
            fragmentShader: Ht.equirect_frag
        },
        distanceRGBA: {
            uniforms: Wt([Jt.common, Jt.displacementmap, {
                referencePosition: {
                    value: new Pt
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Ht.distanceRGBA_vert,
            fragmentShader: Ht.distanceRGBA_frag
        },
        shadow: {
            uniforms: Wt([Jt.lights, Jt.fog, {
                color: {
                    value: new Yt(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Ht.shadow_vert,
            fragmentShader: Ht.shadow_frag
        }
    };
    function Kt() {
        var e = null
          , t = !1
          , r = null;
        function n(i, o) {
            !1 !== t && (r(i, o),
            e.requestAnimationFrame(n))
        }
        return {
            start: function() {
                !0 !== t && null !== r && (e.requestAnimationFrame(n),
                t = !0)
            },
            stop: function() {
                t = !1
            },
            setAnimationLoop: function(e) {
                r = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }
    function Qt(e) {
        var t = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data),
                t.get(e)
            },
            remove: function(r) {
                r.isInterleavedBufferAttribute && (r = r.data);
                var n = t.get(r);
                n && (e.deleteBuffer(n.buffer),
                t.delete(r))
            },
            update: function(r, n) {
                r.isInterleavedBufferAttribute && (r = r.data);
                var i = t.get(r);
                void 0 === i ? t.set(r, function(t, r) {
                    var n = t.array
                      , i = t.dynamic ? 35048 : 35044
                      , o = e.createBuffer();
                    e.bindBuffer(r, o),
                    e.bufferData(r, n, i),
                    t.onUploadCallback();
                    var a = 5126;
                    return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121),
                    {
                        buffer: o,
                        type: a,
                        bytesPerElement: n.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(r, n)) : i.version < r.version && (function(t, r, n) {
                    var i = r.array
                      , o = r.updateRange;
                    e.bindBuffer(n, t),
                    !1 === r.dynamic ? e.bufferData(n, i, 35044) : -1 === o.count ? e.bufferSubData(n, 0, i) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(n, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)),
                    o.count = -1)
                }(i.buffer, r, n),
                i.version = r.version)
            }
        }
    }
    function $t(e, t, r, n, i, o) {
        this.a = e,
        this.b = t,
        this.c = r,
        this.normal = n && n.isVector3 ? n : new Pt,
        this.vertexNormals = Array.isArray(n) ? n : [],
        this.color = i && i.isColor ? i : new Yt,
        this.vertexColors = Array.isArray(i) ? i : [],
        this.materialIndex = void 0 !== o ? o : 0
    }
    function er(e, t, r, n) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = r || 0,
        this._order = n || er.DefaultOrder
    }
    function tr() {
        this.mask = 1
    }
    Zt.physical = {
        uniforms: Wt([Zt.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: Ht.meshphysical_vert,
        fragmentShader: Ht.meshphysical_frag
    },
    Object.assign($t.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.normal.copy(e.normal),
            this.color.copy(e.color),
            this.materialIndex = e.materialIndex;
            for (var t = 0, r = e.vertexNormals.length; t < r; t++)
                this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0,
            r = e.vertexColors.length; t < r; t++)
                this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }),
    er.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
    er.DefaultOrder = "XYZ",
    Object.defineProperties(er.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(er.prototype, {
        isEuler: !0,
        set: function(e, t, r, n) {
            return this._x = e,
            this._y = t,
            this._z = r,
            this._order = n || this._order,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e, t, r) {
            var n = Et.clamp
              , i = e.elements
              , o = i[0]
              , a = i[4]
              , s = i[8]
              , c = i[1]
              , l = i[5]
              , u = i[9]
              , h = i[2]
              , p = i[6]
              , d = i[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(s, -1, 1)),
            Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, d),
            this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, l),
            this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(u, -1, 1)),
            Math.abs(u) < .99999 ? (this._y = Math.atan2(s, d),
            this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o),
            this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(p, -1, 1)),
            Math.abs(p) < .99999 ? (this._y = Math.atan2(-h, d),
            this._z = Math.atan2(-a, l)) : (this._y = 0,
            this._z = Math.atan2(c, o))) : "ZYX" === t ? (this._y = Math.asin(-n(h, -1, 1)),
            Math.abs(h) < .99999 ? (this._x = Math.atan2(p, d),
            this._z = Math.atan2(c, o)) : (this._x = 0,
            this._z = Math.atan2(-a, l))) : "YZX" === t ? (this._z = Math.asin(n(c, -1, 1)),
            Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, l),
            this._y = Math.atan2(-h, o)) : (this._x = 0,
            this._y = Math.atan2(s, d))) : "XZY" === t ? (this._z = Math.asin(-n(a, -1, 1)),
            Math.abs(a) < .99999 ? (this._x = Math.atan2(p, l),
            this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, d),
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t),
            this._order = t,
            !1 !== r && this.onChangeCallback(),
            this
        },
        setFromQuaternion: function() {
            var e = new At;
            return function(t, r, n) {
                return e.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(e, r, n)
            }
        }(),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: function() {
            var e = new Lt;
            return function(t) {
                return e.setFromEuler(this),
                this.setFromQuaternion(e, t)
            }
        }(),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new Pt(this._x,this._y,this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(tr.prototype, {
        set: function(e) {
            this.mask = 1 << e | 0
        },
        enable: function(e) {
            this.mask |= 1 << e | 0
        },
        toggle: function(e) {
            this.mask ^= 1 << e | 0
        },
        disable: function(e) {
            this.mask &= ~(1 << e | 0)
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var rr = 0;
    function nr() {
        Object.defineProperty(this, "id", {
            value: rr++
        }),
        this.uuid = Et.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = nr.DefaultUp.clone();
        var e = new Pt
          , t = new er
          , r = new Lt
          , n = new Pt(1,1,1);
        t.onChange(function() {
            r.setFromEuler(t, !1)
        }),
        r.onChange(function() {
            t.setFromQuaternion(r, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new At
            },
            normalMatrix: {
                value: new Ct
            }
        }),
        this.matrix = new At,
        this.matrixWorld = new At,
        this.matrixAutoUpdate = nr.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new tr,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    nr.DefaultUp = new Pt(0,1,0),
    nr.DefaultMatrixAutoUpdate = !0,
    nr.prototype = Object.assign(Object.create(i.prototype), {
        constructor: nr,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(e) {
            this.matrix.multiplyMatrices(e, this.matrix),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e),
            this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function() {
            var e = new Lt;
            return function(t, r) {
                return e.setFromAxisAngle(t, r),
                this.quaternion.multiply(e),
                this
            }
        }(),
        rotateOnWorldAxis: function() {
            var e = new Lt;
            return function(t, r) {
                return e.setFromAxisAngle(t, r),
                this.quaternion.premultiply(e),
                this
            }
        }(),
        rotateX: function() {
            var e = new Pt(1,0,0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function() {
            var e = new Pt(0,1,0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function() {
            var e = new Pt(0,0,1);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function() {
            var e = new Pt;
            return function(t, r) {
                return e.copy(t).applyQuaternion(this.quaternion),
                this.position.add(e.multiplyScalar(r)),
                this
            }
        }(),
        translateX: function() {
            var e = new Pt(1,0,0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function() {
            var e = new Pt(0,1,0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function() {
            var e = new Pt(0,0,1);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var e = new At;
            return function(t) {
                return t.applyMatrix4(e.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var e = new Lt
              , t = new At
              , r = new Pt
              , n = new Pt;
            return function(i, o, a) {
                i.isVector3 ? r.copy(i) : r.set(i, o, a);
                var s = this.parent;
                this.updateWorldMatrix(!0, !1),
                n.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? t.lookAt(n, r, this.up) : t.lookAt(r, n, this.up),
                this.quaternion.setFromRotationMatrix(t),
                s && (t.extractRotation(s.matrixWorld),
                e.setFromRotationMatrix(t),
                this.quaternion.premultiply(e.inverse()))
            }
        }(),
        add: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
            this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
            e.parent = this,
            e.dispatchEvent({
                type: "added"
            }),
            this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
            this)
        },
        remove: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            var r = this.children.indexOf(e);
            return -1 !== r && (e.parent = null,
            e.dispatchEvent({
                type: "removed"
            }),
            this.children.splice(r, 1)),
            this
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t)
                return this;
            for (var r = 0, n = this.children.length; r < n; r++) {
                var i = this.children[r].getObjectByProperty(e, t);
                if (void 0 !== i)
                    return i
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            e = new Pt),
            this.updateMatrixWorld(!0),
            e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var e = new Pt
              , t = new Pt;
            return function(r) {
                return void 0 === r && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
                r = new Lt),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(e, r, t),
                r
            }
        }(),
        getWorldScale: function() {
            var e = new Pt
              , t = new Lt;
            return function(r) {
                return void 0 === r && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
                r = new Pt),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(e, t, r),
                r
            }
        }(),
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            e = new Pt),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, r = 0, n = t.length; r < n; r++)
                t[r].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, r = 0, n = t.length; r < n; r++)
                    t[r].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t),
            t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            e = !0);
            for (var t = this.children, r = 0, n = t.length; r < n; r++)
                t[r].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var r = this.parent;
            if (!0 === e && null !== r && r.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t)
                for (var n = this.children, i = 0, o = n.length; i < o; i++)
                    n[i].updateWorldMatrix(!1, !0)
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e
              , r = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var n = {};
            function i(t, r) {
                return void 0 === t[r.uuid] && (t[r.uuid] = r.toJSON(e)),
                r.uuid
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            !0 === this.castShadow && (n.castShadow = !0),
            !0 === this.receiveShadow && (n.receiveShadow = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.frustumCulled && (n.frustumCulled = !1),
            0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            n.layers = this.layers.mask,
            n.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
            this.isMesh && this.drawMode !== ht && (n.drawMode = this.drawMode),
            this.isMesh || this.isLine || this.isPoints) {
                n.geometry = i(e.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) {
                    var a = o.shapes;
                    if (Array.isArray(a))
                        for (var s = 0, c = a.length; s < c; s++) {
                            var l = a[s];
                            i(e.shapes, l)
                        }
                    else
                        i(e.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var u = [];
                    for (s = 0,
                    c = this.material.length; s < c; s++)
                        u.push(i(e.materials, this.material[s]));
                    n.material = u
                } else
                    n.material = i(e.materials, this.material);
            if (this.children.length > 0) {
                n.children = [];
                for (s = 0; s < this.children.length; s++)
                    n.children.push(this.children[s].toJSON(e).object)
            }
            if (t) {
                var h = m(e.geometries)
                  , p = m(e.materials)
                  , d = m(e.textures)
                  , f = m(e.images);
                a = m(e.shapes);
                h.length > 0 && (r.geometries = h),
                p.length > 0 && (r.materials = p),
                d.length > 0 && (r.textures = d),
                f.length > 0 && (r.images = f),
                a.length > 0 && (r.shapes = a)
            }
            return r.object = n,
            r;
            function m(e) {
                var t = [];
                for (var r in e) {
                    var n = e[r];
                    delete n.metadata,
                    t.push(n)
                }
                return t
            }
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0),
            this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
                for (var r = 0; r < e.children.length; r++) {
                    var n = e.children[r];
                    this.add(n.clone())
                }
            return this
        }
    });
    var ir = 0;
    function or() {
        Object.defineProperty(this, "id", {
            value: ir += 2
        }),
        this.uuid = Et.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function ar(e, t, r) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = !0 === r,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function sr(e, t, r) {
        ar.call(this, new Int8Array(e), t, r)
    }
    function cr(e, t, r) {
        ar.call(this, new Uint8Array(e), t, r)
    }
    function lr(e, t, r) {
        ar.call(this, new Uint8ClampedArray(e), t, r)
    }
    function ur(e, t, r) {
        ar.call(this, new Int16Array(e), t, r)
    }
    function hr(e, t, r) {
        ar.call(this, new Uint16Array(e), t, r)
    }
    function pr(e, t, r) {
        ar.call(this, new Int32Array(e), t, r)
    }
    function dr(e, t, r) {
        ar.call(this, new Uint32Array(e), t, r)
    }
    function fr(e, t, r) {
        ar.call(this, new Float32Array(e), t, r)
    }
    function mr(e, t, r) {
        ar.call(this, new Float64Array(e), t, r)
    }
    function vr() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.verticesNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function gr(e) {
        if (0 === e.length)
            return -1 / 0;
        for (var t = e[0], r = 1, n = e.length; r < n; ++r)
            e[r] > t && (t = e[r]);
        return t
    }
    or.prototype = Object.assign(Object.create(i.prototype), {
        constructor: or,
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new Ct).getNormalMatrix(e), r = 0, n = this.vertices.length; r < n; r++) {
                this.vertices[r].applyMatrix4(e)
            }
            for (r = 0,
            n = this.faces.length; r < n; r++) {
                var i = this.faces[r];
                i.normal.applyMatrix3(t).normalize();
                for (var o = 0, a = i.vertexNormals.length; o < a; o++)
                    i.vertexNormals[o].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0,
            this.normalsNeedUpdate = !0,
            this
        },
        rotateX: function() {
            var e = new At;
            return function(t) {
                return e.makeRotationX(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateY: function() {
            var e = new At;
            return function(t) {
                return e.makeRotationY(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateZ: function() {
            var e = new At;
            return function(t) {
                return e.makeRotationZ(t),
                this.applyMatrix(e),
                this
            }
        }(),
        translate: function() {
            var e = new At;
            return function(t, r, n) {
                return e.makeTranslation(t, r, n),
                this.applyMatrix(e),
                this
            }
        }(),
        scale: function() {
            var e = new At;
            return function(t, r, n) {
                return e.makeScale(t, r, n),
                this.applyMatrix(e),
                this
            }
        }(),
        lookAt: function() {
            var e = new nr;
            return function(t) {
                e.lookAt(t),
                e.updateMatrix(),
                this.applyMatrix(e.matrix)
            }
        }(),
        fromBufferGeometry: function(e) {
            var t = this
              , r = null !== e.index ? e.index.array : void 0
              , n = e.attributes
              , i = n.position.array
              , o = void 0 !== n.normal ? n.normal.array : void 0
              , a = void 0 !== n.color ? n.color.array : void 0
              , s = void 0 !== n.uv ? n.uv.array : void 0
              , c = void 0 !== n.uv2 ? n.uv2.array : void 0;
            void 0 !== c && (this.faceVertexUvs[1] = []);
            for (var l = 0, u = 0; l < i.length; l += 3,
            u += 2)
                t.vertices.push((new Pt).fromArray(i, l)),
                void 0 !== a && t.colors.push((new Yt).fromArray(a, l));
            function h(e, r, n, i) {
                var l = void 0 === a ? [] : [t.colors[e].clone(), t.colors[r].clone(), t.colors[n].clone()]
                  , u = new $t(e,r,n,void 0 === o ? [] : [(new Pt).fromArray(o, 3 * e), (new Pt).fromArray(o, 3 * r), (new Pt).fromArray(o, 3 * n)],l,i);
                t.faces.push(u),
                void 0 !== s && t.faceVertexUvs[0].push([(new Tt).fromArray(s, 2 * e), (new Tt).fromArray(s, 2 * r), (new Tt).fromArray(s, 2 * n)]),
                void 0 !== c && t.faceVertexUvs[1].push([(new Tt).fromArray(c, 2 * e), (new Tt).fromArray(c, 2 * r), (new Tt).fromArray(c, 2 * n)])
            }
            var p = e.groups;
            if (p.length > 0)
                for (l = 0; l < p.length; l++)
                    for (var d = p[l], f = d.start, m = (u = f,
                    f + d.count); u < m; u += 3)
                        void 0 !== r ? h(r[u], r[u + 1], r[u + 2], d.materialIndex) : h(u, u + 1, u + 2, d.materialIndex);
            else if (void 0 !== r)
                for (l = 0; l < r.length; l += 3)
                    h(r[l], r[l + 1], r[l + 2]);
            else
                for (l = 0; l < i.length / 3; l += 3)
                    h(l, l + 1, l + 2);
            return this.computeFaceNormals(),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            this
        },
        center: function() {
            var e = new Pt;
            return function() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(e).negate(),
                this.translate(e.x, e.y, e.z),
                this
            }
        }(),
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center
              , t = this.boundingSphere.radius
              , r = 0 === t ? 1 : 1 / t
              , n = new At;
            return n.set(r, 0, 0, -r * e.x, 0, r, 0, -r * e.y, 0, 0, r, -r * e.z, 0, 0, 0, 1),
            this.applyMatrix(n),
            this
        },
        computeFaceNormals: function() {
            for (var e = new Pt, t = new Pt, r = 0, n = this.faces.length; r < n; r++) {
                var i = this.faces[r]
                  , o = this.vertices[i.a]
                  , a = this.vertices[i.b]
                  , s = this.vertices[i.c];
                e.subVectors(s, a),
                t.subVectors(o, a),
                e.cross(t),
                e.normalize(),
                i.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t, r, n, i, o, a;
            for (void 0 === e && (e = !0),
            a = new Array(this.vertices.length),
            t = 0,
            r = this.vertices.length; t < r; t++)
                a[t] = new Pt;
            if (e) {
                var s, c, l, u = new Pt, h = new Pt;
                for (n = 0,
                i = this.faces.length; n < i; n++)
                    o = this.faces[n],
                    s = this.vertices[o.a],
                    c = this.vertices[o.b],
                    l = this.vertices[o.c],
                    u.subVectors(l, c),
                    h.subVectors(s, c),
                    u.cross(h),
                    a[o.a].add(u),
                    a[o.b].add(u),
                    a[o.c].add(u)
            } else
                for (this.computeFaceNormals(),
                n = 0,
                i = this.faces.length; n < i; n++)
                    a[(o = this.faces[n]).a].add(o.normal),
                    a[o.b].add(o.normal),
                    a[o.c].add(o.normal);
            for (t = 0,
            r = this.vertices.length; t < r; t++)
                a[t].normalize();
            for (n = 0,
            i = this.faces.length; n < i; n++) {
                var p = (o = this.faces[n]).vertexNormals;
                3 === p.length ? (p[0].copy(a[o.a]),
                p[1].copy(a[o.b]),
                p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(),
                p[1] = a[o.b].clone(),
                p[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e, t, r;
            for (this.computeFaceNormals(),
            e = 0,
            t = this.faces.length; e < t; e++) {
                var n = (r = this.faces[e]).vertexNormals;
                3 === n.length ? (n[0].copy(r.normal),
                n[1].copy(r.normal),
                n[2].copy(r.normal)) : (n[0] = r.normal.clone(),
                n[1] = r.normal.clone(),
                n[2] = r.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, r, n, i;
            for (r = 0,
            n = this.faces.length; r < n; r++)
                for ((i = this.faces[r]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(),
                i.__originalVertexNormals || (i.__originalVertexNormals = []),
                e = 0,
                t = i.vertexNormals.length; e < t; e++)
                    i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
            var o = new or;
            for (o.faces = this.faces,
            e = 0,
            t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {},
                    this.morphNormals[e].faceNormals = [],
                    this.morphNormals[e].vertexNormals = [];
                    var a = this.morphNormals[e].faceNormals
                      , s = this.morphNormals[e].vertexNormals;
                    for (r = 0,
                    n = this.faces.length; r < n; r++)
                        c = new Pt,
                        l = {
                            a: new Pt,
                            b: new Pt,
                            c: new Pt
                        },
                        a.push(c),
                        s.push(l)
                }
                var c, l, u = this.morphNormals[e];
                for (o.vertices = this.morphTargets[e].vertices,
                o.computeFaceNormals(),
                o.computeVertexNormals(),
                r = 0,
                n = this.faces.length; r < n; r++)
                    i = this.faces[r],
                    c = u.faceNormals[r],
                    l = u.vertexNormals[r],
                    c.copy(i.normal),
                    l.a.copy(i.vertexNormals[0]),
                    l.b.copy(i.vertexNormals[1]),
                    l.c.copy(i.vertexNormals[2])
            }
            for (r = 0,
            n = this.faces.length; r < n; r++)
                (i = this.faces[r]).normal = i.__originalFaceNormal,
                i.vertexNormals = i.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Ut),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new jt),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, r) {
            if (e && e.isGeometry) {
                var n, i = this.vertices.length, o = this.vertices, a = e.vertices, s = this.faces, c = e.faces, l = this.faceVertexUvs[0], u = e.faceVertexUvs[0], h = this.colors, p = e.colors;
                void 0 === r && (r = 0),
                void 0 !== t && (n = (new Ct).getNormalMatrix(t));
                for (var d = 0, f = a.length; d < f; d++) {
                    var m = a[d].clone();
                    void 0 !== t && m.applyMatrix4(t),
                    o.push(m)
                }
                for (d = 0,
                f = p.length; d < f; d++)
                    h.push(p[d].clone());
                for (d = 0,
                f = c.length; d < f; d++) {
                    var v, g, y, b = c[d], x = b.vertexNormals, w = b.vertexColors;
                    (v = new $t(b.a + i,b.b + i,b.c + i)).normal.copy(b.normal),
                    void 0 !== n && v.normal.applyMatrix3(n).normalize();
                    for (var _ = 0, M = x.length; _ < M; _++)
                        g = x[_].clone(),
                        void 0 !== n && g.applyMatrix3(n).normalize(),
                        v.vertexNormals.push(g);
                    v.color.copy(b.color);
                    for (_ = 0,
                    M = w.length; _ < M; _++)
                        y = w[_],
                        v.vertexColors.push(y.clone());
                    v.materialIndex = b.materialIndex + r,
                    s.push(v)
                }
                for (d = 0,
                f = u.length; d < f; d++) {
                    var S = u[d]
                      , E = [];
                    if (void 0 !== S) {
                        for (_ = 0,
                        M = S.length; _ < M; _++)
                            E.push(S[_].clone());
                        l.push(E)
                    }
                }
            } else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(),
            this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function() {
            var e, t, r, n, i, o, a, s, c = {}, l = [], u = [], h = Math.pow(10, 4);
            for (r = 0,
            n = this.vertices.length; r < n; r++)
                e = this.vertices[r],
                void 0 === c[t = Math.round(e.x * h) + "_" + Math.round(e.y * h) + "_" + Math.round(e.z * h)] ? (c[t] = r,
                l.push(this.vertices[r]),
                u[r] = l.length - 1) : u[r] = u[c[t]];
            var p = [];
            for (r = 0,
            n = this.faces.length; r < n; r++) {
                (i = this.faces[r]).a = u[i.a],
                i.b = u[i.b],
                i.c = u[i.c],
                o = [i.a, i.b, i.c];
                for (var d = 0; d < 3; d++)
                    if (o[d] === o[(d + 1) % 3]) {
                        p.push(r);
                        break
                    }
            }
            for (r = p.length - 1; r >= 0; r--) {
                var f = p[r];
                for (this.faces.splice(f, 1),
                a = 0,
                s = this.faceVertexUvs.length; a < s; a++)
                    this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - l.length;
            return this.vertices = l,
            m
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, r = e.length; t < r; t++) {
                var n = e[t];
                this.vertices.push(new Pt(n.x,n.y,n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, r = 0; r < t; r++)
                e[r]._id = r;
            e.sort(function(e, t) {
                return e.materialIndex - t.materialIndex
            });
            var n, i, o = this.faceVertexUvs[0], a = this.faceVertexUvs[1];
            o && o.length === t && (n = []),
            a && a.length === t && (i = []);
            for (r = 0; r < t; r++) {
                var s = e[r]._id;
                n && n.push(o[s]),
                i && i.push(a[s])
            }
            n && (this.faceVertexUvs[0] = n),
            i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var r in t)
                    void 0 !== t[r] && (e[r] = t[r]);
                return e
            }
            for (var n = [], i = 0; i < this.vertices.length; i++) {
                var o = this.vertices[i];
                n.push(o.x, o.y, o.z)
            }
            var a = []
              , s = []
              , c = {}
              , l = []
              , u = {}
              , h = []
              , p = {};
            for (i = 0; i < this.faces.length; i++) {
                var d = this.faces[i]
                  , f = void 0 !== this.faceVertexUvs[0][i]
                  , m = d.normal.length() > 0
                  , v = d.vertexNormals.length > 0
                  , g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b
                  , y = d.vertexColors.length > 0
                  , b = 0;
                if (b = M(b = M(b = M(b = M(b = M(b = M(b = M(b = M(b, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, v), 6, g), 7, y),
                a.push(b),
                a.push(d.a, d.b, d.c),
                a.push(d.materialIndex),
                f) {
                    var x = this.faceVertexUvs[0][i];
                    a.push(T(x[0]), T(x[1]), T(x[2]))
                }
                if (m && a.push(S(d.normal)),
                v) {
                    var w = d.vertexNormals;
                    a.push(S(w[0]), S(w[1]), S(w[2]))
                }
                if (g && a.push(E(d.color)),
                y) {
                    var _ = d.vertexColors;
                    a.push(E(_[0]), E(_[1]), E(_[2]))
                }
            }
            function M(e, t, r) {
                return r ? e | 1 << t : e & ~(1 << t)
            }
            function S(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== c[t] ? c[t] : (c[t] = s.length / 3,
                s.push(e.x, e.y, e.z),
                c[t])
            }
            function E(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== u[t] ? u[t] : (u[t] = l.length,
                l.push(e.getHex()),
                u[t])
            }
            function T(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== p[t] ? p[t] : (p[t] = h.length / 2,
                h.push(e.x, e.y),
                p[t])
            }
            return e.data = {},
            e.data.vertices = n,
            e.data.normals = s,
            l.length > 0 && (e.data.colors = l),
            h.length > 0 && (e.data.uvs = [h]),
            e.data.faces = a,
            e
        },
        clone: function() {
            return (new or).copy(this)
        },
        copy: function(e) {
            var t, r, n, i, o, a;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var s = e.vertices;
            for (t = 0,
            r = s.length; t < r; t++)
                this.vertices.push(s[t].clone());
            var c = e.colors;
            for (t = 0,
            r = c.length; t < r; t++)
                this.colors.push(c[t].clone());
            var l = e.faces;
            for (t = 0,
            r = l.length; t < r; t++)
                this.faces.push(l[t].clone());
            for (t = 0,
            r = e.faceVertexUvs.length; t < r; t++) {
                var u = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []),
                n = 0,
                i = u.length; n < i; n++) {
                    var h = u[n]
                      , p = [];
                    for (o = 0,
                    a = h.length; o < a; o++) {
                        var d = h[o];
                        p.push(d.clone())
                    }
                    this.faceVertexUvs[t].push(p)
                }
            }
            var f = e.morphTargets;
            for (t = 0,
            r = f.length; t < r; t++) {
                var m = {};
                if (m.name = f[t].name,
                void 0 !== f[t].vertices)
                    for (m.vertices = [],
                    n = 0,
                    i = f[t].vertices.length; n < i; n++)
                        m.vertices.push(f[t].vertices[n].clone());
                if (void 0 !== f[t].normals)
                    for (m.normals = [],
                    n = 0,
                    i = f[t].normals.length; n < i; n++)
                        m.normals.push(f[t].normals[n].clone());
                this.morphTargets.push(m)
            }
            var v = e.morphNormals;
            for (t = 0,
            r = v.length; t < r; t++) {
                var g = {};
                if (void 0 !== v[t].vertexNormals)
                    for (g.vertexNormals = [],
                    n = 0,
                    i = v[t].vertexNormals.length; n < i; n++) {
                        var y = v[t].vertexNormals[n]
                          , b = {};
                        b.a = y.a.clone(),
                        b.b = y.b.clone(),
                        b.c = y.c.clone(),
                        g.vertexNormals.push(b)
                    }
                if (void 0 !== v[t].faceNormals)
                    for (g.faceNormals = [],
                    n = 0,
                    i = v[t].faceNormals.length; n < i; n++)
                        g.faceNormals.push(v[t].faceNormals[n].clone());
                this.morphNormals.push(g)
            }
            var x = e.skinWeights;
            for (t = 0,
            r = x.length; t < r; t++)
                this.skinWeights.push(x[t].clone());
            var w = e.skinIndices;
            for (t = 0,
            r = w.length; t < r; t++)
                this.skinIndices.push(w[t].clone());
            var _ = e.lineDistances;
            for (t = 0,
            r = _.length; t < r; t++)
                this.lineDistances.push(_[t]);
            var M = e.boundingBox;
            null !== M && (this.boundingBox = M.clone());
            var S = e.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()),
            this.elementsNeedUpdate = e.elementsNeedUpdate,
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(ar.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(ar.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, r) {
            e *= this.itemSize,
            r *= t.itemSize;
            for (var n = 0, i = this.itemSize; n < i; n++)
                this.array[e + n] = t.array[r + n];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e),
            this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
                o = new Yt),
                t[r++] = o.r,
                t[r++] = o.g,
                t[r++] = o.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
                o = new Tt),
                t[r++] = o.x,
                t[r++] = o.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
                o = new Pt),
                t[r++] = o.x,
                t[r++] = o.y,
                t[r++] = o.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, r = 0, n = 0, i = e.length; n < i; n++) {
                var o = e[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
                o = new Nt),
                t[r++] = o.x,
                t[r++] = o.y,
                t[r++] = o.z,
                t[r++] = o.w
            }
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t,
            this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t,
            this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t,
            this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t,
            this
        },
        setXY: function(e, t, r) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this
        },
        setXYZ: function(e, t, r, n) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this.array[e + 2] = n,
            this
        },
        setXYZW: function(e, t, r, n, i) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = r,
            this.array[e + 2] = n,
            this.array[e + 3] = i,
            this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
    }),
    sr.prototype = Object.create(ar.prototype),
    sr.prototype.constructor = sr,
    cr.prototype = Object.create(ar.prototype),
    cr.prototype.constructor = cr,
    lr.prototype = Object.create(ar.prototype),
    lr.prototype.constructor = lr,
    ur.prototype = Object.create(ar.prototype),
    ur.prototype.constructor = ur,
    hr.prototype = Object.create(ar.prototype),
    hr.prototype.constructor = hr,
    pr.prototype = Object.create(ar.prototype),
    pr.prototype.constructor = pr,
    dr.prototype = Object.create(ar.prototype),
    dr.prototype.constructor = dr,
    fr.prototype = Object.create(ar.prototype),
    fr.prototype.constructor = fr,
    mr.prototype = Object.create(ar.prototype),
    mr.prototype.constructor = mr,
    Object.assign(vr.prototype, {
        computeGroups: function(e) {
            for (var t, r = [], n = void 0, i = e.faces, o = 0; o < i.length; o++) {
                var a = i[o];
                a.materialIndex !== n && (n = a.materialIndex,
                void 0 !== t && (t.count = 3 * o - t.start,
                r.push(t)),
                t = {
                    start: 3 * o,
                    materialIndex: n
                })
            }
            void 0 !== t && (t.count = 3 * o - t.start,
            r.push(t)),
            this.groups = r
        },
        fromGeometry: function(e) {
            var t, r = e.faces, n = e.vertices, i = e.faceVertexUvs, o = i[0] && i[0].length > 0, a = i[1] && i[1].length > 0, s = e.morphTargets, c = s.length;
            if (c > 0) {
                t = [];
                for (var l = 0; l < c; l++)
                    t[l] = {
                        name: s[l].name,
                        data: []
                    };
                this.morphTargets.position = t
            }
            var u, h = e.morphNormals, p = h.length;
            if (p > 0) {
                u = [];
                for (l = 0; l < p; l++)
                    u[l] = {
                        name: h[l].name,
                        data: []
                    };
                this.morphTargets.normal = u
            }
            var d = e.skinIndices
              , f = e.skinWeights
              , m = d.length === n.length
              , v = f.length === n.length;
            n.length > 0 && 0 === r.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (l = 0; l < r.length; l++) {
                var g = r[l];
                this.vertices.push(n[g.a], n[g.b], n[g.c]);
                var y = g.vertexNormals;
                if (3 === y.length)
                    this.normals.push(y[0], y[1], y[2]);
                else {
                    var b = g.normal;
                    this.normals.push(b, b, b)
                }
                var x, w = g.vertexColors;
                if (3 === w.length)
                    this.colors.push(w[0], w[1], w[2]);
                else {
                    var _ = g.color;
                    this.colors.push(_, _, _)
                }
                if (!0 === o)
                    void 0 !== (x = i[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l),
                    this.uvs.push(new Tt, new Tt, new Tt));
                if (!0 === a)
                    void 0 !== (x = i[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l),
                    this.uvs2.push(new Tt, new Tt, new Tt));
                for (var M = 0; M < c; M++) {
                    var S = s[M].vertices;
                    t[M].data.push(S[g.a], S[g.b], S[g.c])
                }
                for (M = 0; M < p; M++) {
                    var E = h[M].vertexNormals[l];
                    u[M].data.push(E.a, E.b, E.c)
                }
                m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]),
                v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
            }
            return this.computeGroups(e),
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        }
    });
    var yr = 1;
    function br() {
        Object.defineProperty(this, "id", {
            value: yr += 2
        }),
        this.uuid = Et.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    function xr(e, t, r, n, i, o) {
        or.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: n,
            heightSegments: i,
            depthSegments: o
        },
        this.fromBufferGeometry(new wr(e,t,r,n,i,o)),
        this.mergeVertices()
    }
    function wr(e, t, r, n, i, o) {
        br.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: n,
            heightSegments: i,
            depthSegments: o
        };
        var a = this;
        e = e || 1,
        t = t || 1,
        r = r || 1,
        n = Math.floor(n) || 1,
        i = Math.floor(i) || 1;
        var s = []
          , c = []
          , l = []
          , u = []
          , h = 0
          , p = 0;
        function d(e, t, r, n, i, o, d, f, m, v, g) {
            var y, b, x = o / m, w = d / v, _ = o / 2, M = d / 2, S = f / 2, E = m + 1, T = v + 1, A = 0, L = 0, P = new Pt;
            for (b = 0; b < T; b++) {
                var C = b * w - M;
                for (y = 0; y < E; y++) {
                    var R = y * x - _;
                    P[e] = R * n,
                    P[t] = C * i,
                    P[r] = S,
                    c.push(P.x, P.y, P.z),
                    P[e] = 0,
                    P[t] = 0,
                    P[r] = f > 0 ? 1 : -1,
                    l.push(P.x, P.y, P.z),
                    u.push(y / m),
                    u.push(1 - b / v),
                    A += 1
                }
            }
            for (b = 0; b < v; b++)
                for (y = 0; y < m; y++) {
                    var O = h + y + E * b
                      , I = h + y + E * (b + 1)
                      , N = h + (y + 1) + E * (b + 1)
                      , D = h + (y + 1) + E * b;
                    s.push(O, I, D),
                    s.push(I, N, D),
                    L += 6
                }
            a.addGroup(p, L, g),
            p += L,
            h += A
        }
        d("z", "y", "x", -1, -1, r, t, e, o = Math.floor(o) || 1, i, 0),
        d("z", "y", "x", 1, -1, r, t, -e, o, i, 1),
        d("x", "z", "y", 1, 1, e, r, t, n, o, 2),
        d("x", "z", "y", 1, -1, e, r, -t, n, o, 3),
        d("x", "y", "z", 1, -1, e, t, r, n, i, 4),
        d("x", "y", "z", -1, -1, e, t, -r, n, i, 5),
        this.setIndex(s),
        this.addAttribute("position", new fr(c,3)),
        this.addAttribute("normal", new fr(l,3)),
        this.addAttribute("uv", new fr(u,2))
    }
    function _r(e, t, r, n) {
        or.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: n
        },
        this.fromBufferGeometry(new Mr(e,t,r,n)),
        this.mergeVertices()
    }
    function Mr(e, t, r, n) {
        br.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: n
        };
        var i, o, a = (e = e || 1) / 2, s = (t = t || 1) / 2, c = Math.floor(r) || 1, l = Math.floor(n) || 1, u = c + 1, h = l + 1, p = e / c, d = t / l, f = [], m = [], v = [], g = [];
        for (o = 0; o < h; o++) {
            var y = o * d - s;
            for (i = 0; i < u; i++) {
                var b = i * p - a;
                m.push(b, -y, 0),
                v.push(0, 0, 1),
                g.push(i / c),
                g.push(1 - o / l)
            }
        }
        for (o = 0; o < l; o++)
            for (i = 0; i < c; i++) {
                var x = i + u * o
                  , w = i + u * (o + 1)
                  , _ = i + 1 + u * (o + 1)
                  , M = i + 1 + u * o;
                f.push(x, w, M),
                f.push(w, _, M)
            }
        this.setIndex(f),
        this.addAttribute("position", new fr(m,3)),
        this.addAttribute("normal", new fr(v,3)),
        this.addAttribute("uv", new fr(g,2))
    }
    br.prototype = Object.assign(Object.create(i.prototype), {
        constructor: br,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new (gr(e) > 65535 ? dr : hr)(e,1) : this.index = e
        },
        addAttribute: function(e, t) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(t),
            this) : (this.attributes[e] = t,
            this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.addAttribute(e, new ar(arguments[1],arguments[2])))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        removeAttribute: function(e) {
            return delete this.attributes[e],
            this
        },
        addGroup: function(e, t, r) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== r ? r : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t),
            t.needsUpdate = !0);
            var r = this.attributes.normal;
            void 0 !== r && ((new Ct).getNormalMatrix(e).applyToBufferAttribute(r),
            r.needsUpdate = !0);
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function() {
            var e = new At;
            return function(t) {
                return e.makeRotationX(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateY: function() {
            var e = new At;
            return function(t) {
                return e.makeRotationY(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateZ: function() {
            var e = new At;
            return function(t) {
                return e.makeRotationZ(t),
                this.applyMatrix(e),
                this
            }
        }(),
        translate: function() {
            var e = new At;
            return function(t, r, n) {
                return e.makeTranslation(t, r, n),
                this.applyMatrix(e),
                this
            }
        }(),
        scale: function() {
            var e = new At;
            return function(t, r, n) {
                return e.makeScale(t, r, n),
                this.applyMatrix(e),
                this
            }
        }(),
        lookAt: function() {
            var e = new nr;
            return function(t) {
                e.lookAt(t),
                e.updateMatrix(),
                this.applyMatrix(e.matrix)
            }
        }(),
        center: function() {
            var e = new Pt;
            return function() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(e).negate(),
                this.translate(e.x, e.y, e.z),
                this
            }
        }(),
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var r = new fr(3 * t.vertices.length,3)
                  , n = new fr(3 * t.colors.length,3);
                if (this.addAttribute("position", r.copyVector3sArray(t.vertices)),
                this.addAttribute("color", n.copyColorsArray(t.colors)),
                t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var i = new fr(t.lineDistances.length,1);
                    this.addAttribute("lineDistance", i.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else
                e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function(e) {
            for (var t = [], r = 0, n = e.length; r < n; r++) {
                var i = e[r];
                t.push(i.x, i.y, i.z || 0)
            }
            return this.addAttribute("position", new fr(t,3)),
            this
        },
        updateFromObject: function(e) {
            var t, r = e.geometry;
            if (e.isMesh) {
                var n = r.__directGeometry;
                if (!0 === r.elementsNeedUpdate && (n = void 0,
                r.elementsNeedUpdate = !1),
                void 0 === n)
                    return this.fromGeometry(r);
                n.verticesNeedUpdate = r.verticesNeedUpdate,
                n.normalsNeedUpdate = r.normalsNeedUpdate,
                n.colorsNeedUpdate = r.colorsNeedUpdate,
                n.uvsNeedUpdate = r.uvsNeedUpdate,
                n.groupsNeedUpdate = r.groupsNeedUpdate,
                r.verticesNeedUpdate = !1,
                r.normalsNeedUpdate = !1,
                r.colorsNeedUpdate = !1,
                r.uvsNeedUpdate = !1,
                r.groupsNeedUpdate = !1,
                r = n
            }
            return !0 === r.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(r.vertices),
            t.needsUpdate = !0),
            r.verticesNeedUpdate = !1),
            !0 === r.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(r.normals),
            t.needsUpdate = !0),
            r.normalsNeedUpdate = !1),
            !0 === r.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(r.colors),
            t.needsUpdate = !0),
            r.colorsNeedUpdate = !1),
            r.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(r.uvs),
            t.needsUpdate = !0),
            r.uvsNeedUpdate = !1),
            r.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(r.lineDistances),
            t.needsUpdate = !0),
            r.lineDistancesNeedUpdate = !1),
            r.groupsNeedUpdate && (r.computeGroups(e.geometry),
            this.groups = r.groups,
            r.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new vr).fromGeometry(e),
            this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.addAttribute("position", new ar(t,3).copyVector3sArray(e.vertices)),
            e.normals.length > 0) {
                var r = new Float32Array(3 * e.normals.length);
                this.addAttribute("normal", new ar(r,3).copyVector3sArray(e.normals))
            }
            if (e.colors.length > 0) {
                var n = new Float32Array(3 * e.colors.length);
                this.addAttribute("color", new ar(n,3).copyColorsArray(e.colors))
            }
            if (e.uvs.length > 0) {
                var i = new Float32Array(2 * e.uvs.length);
                this.addAttribute("uv", new ar(i,2).copyVector2sArray(e.uvs))
            }
            if (e.uvs2.length > 0) {
                var o = new Float32Array(2 * e.uvs2.length);
                this.addAttribute("uv2", new ar(o,2).copyVector2sArray(e.uvs2))
            }
            for (var a in this.groups = e.groups,
            e.morphTargets) {
                for (var s = [], c = e.morphTargets[a], l = 0, u = c.length; l < u; l++) {
                    var h = c[l]
                      , p = new fr(3 * h.data.length,3);
                    p.name = h.name,
                    s.push(p.copyVector3sArray(h.data))
                }
                this.morphAttributes[a] = s
            }
            if (e.skinIndices.length > 0) {
                var d = new fr(4 * e.skinIndices.length,4);
                this.addAttribute("skinIndex", d.copyVector4sArray(e.skinIndices))
            }
            if (e.skinWeights.length > 0) {
                var f = new fr(4 * e.skinWeights.length,4);
                this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Ut);
            var e = this.attributes.position;
            void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(),
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            var e = new Ut
              , t = new Pt;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new jt);
                var r = this.attributes.position;
                if (r) {
                    var n = this.boundingSphere.center;
                    e.setFromBufferAttribute(r),
                    e.getCenter(n);
                    for (var i = 0, o = 0, a = r.count; o < a; o++)
                        t.x = r.getX(o),
                        t.y = r.getY(o),
                        t.z = r.getZ(o),
                        i = Math.max(i, n.distanceToSquared(t));
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index
              , t = this.attributes;
            if (t.position) {
                var r = t.position.array;
                if (void 0 === t.normal)
                    this.addAttribute("normal", new ar(new Float32Array(r.length),3));
                else
                    for (var n = t.normal.array, i = 0, o = n.length; i < o; i++)
                        n[i] = 0;
                var a, s, c, l = t.normal.array, u = new Pt, h = new Pt, p = new Pt, d = new Pt, f = new Pt;
                if (e) {
                    var m = e.array;
                    for (i = 0,
                    o = e.count; i < o; i += 3)
                        a = 3 * m[i + 0],
                        s = 3 * m[i + 1],
                        c = 3 * m[i + 2],
                        u.fromArray(r, a),
                        h.fromArray(r, s),
                        p.fromArray(r, c),
                        d.subVectors(p, h),
                        f.subVectors(u, h),
                        d.cross(f),
                        l[a] += d.x,
                        l[a + 1] += d.y,
                        l[a + 2] += d.z,
                        l[s] += d.x,
                        l[s + 1] += d.y,
                        l[s + 2] += d.z,
                        l[c] += d.x,
                        l[c + 1] += d.y,
                        l[c + 2] += d.z
                } else
                    for (i = 0,
                    o = r.length; i < o; i += 9)
                        u.fromArray(r, i),
                        h.fromArray(r, i + 3),
                        p.fromArray(r, i + 6),
                        d.subVectors(p, h),
                        f.subVectors(u, h),
                        d.cross(f),
                        l[i] = d.x,
                        l[i + 1] = d.y,
                        l[i + 2] = d.z,
                        l[i + 3] = d.x,
                        l[i + 4] = d.y,
                        l[i + 5] = d.z,
                        l[i + 6] = d.x,
                        l[i + 7] = d.y,
                        l[i + 8] = d.z;
                this.normalizeNormals(),
                t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var r = this.attributes;
                for (var n in r)
                    if (void 0 !== e.attributes[n])
                        for (var i = r[n].array, o = e.attributes[n], a = o.array, s = 0, c = o.itemSize * t; s < a.length; s++,
                        c++)
                            i[c] = a[s];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: function() {
            var e = new Pt;
            return function() {
                for (var t = this.attributes.normal, r = 0, n = t.count; r < n; r++)
                    e.x = t.getX(r),
                    e.y = t.getY(r),
                    e.z = t.getZ(r),
                    e.normalize(),
                    t.setXYZ(r, e.x, e.y, e.z)
            }
        }(),
        toNonIndexed: function() {
            function e(e, t) {
                for (var r = e.array, n = e.itemSize, i = new r.constructor(t.length * n), o = 0, a = 0, s = 0, c = t.length; s < c; s++) {
                    o = t[s] * n;
                    for (var l = 0; l < n; l++)
                        i[a++] = r[o++]
                }
                return new ar(i,n)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var t = new br
              , r = this.index.array
              , n = this.attributes;
            for (var i in n) {
                var o = e(n[i], r);
                t.addAttribute(i, o)
            }
            var a = this.morphAttributes;
            for (i in a) {
                for (var s = [], c = a[i], l = 0, u = c.length; l < u; l++) {
                    o = e(c[l], r);
                    s.push(o)
                }
                t.morphAttributes[i] = s
            }
            for (var h = this.groups, p = (l = 0,
            h.length); l < p; l++) {
                var d = h[l];
                t.addGroup(d.start, d.count, d.materialIndex)
            }
            return t
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var r in t)
                    void 0 !== t[r] && (e[r] = t[r]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var n = this.index;
            if (null !== n) {
                var i = Array.prototype.slice.call(n.array);
                e.data.index = {
                    type: n.array.constructor.name,
                    array: i
                }
            }
            var o = this.attributes;
            for (var r in o) {
                var a = o[r];
                i = Array.prototype.slice.call(a.array);
                e.data.attributes[r] = {
                    itemSize: a.itemSize,
                    type: a.array.constructor.name,
                    array: i,
                    normalized: a.normalized
                }
            }
            var s = this.groups;
            s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
            var c = this.boundingSphere;
            return null !== c && (e.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            }),
            e
        },
        clone: function() {
            return (new br).copy(this)
        },
        copy: function(e) {
            var t, r, n;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var i = e.index;
            null !== i && this.setIndex(i.clone());
            var o = e.attributes;
            for (t in o) {
                var a = o[t];
                this.addAttribute(t, a.clone())
            }
            var s = e.morphAttributes;
            for (t in s) {
                var c = []
                  , l = s[t];
                for (r = 0,
                n = l.length; r < n; r++)
                    c.push(l[r].clone());
                this.morphAttributes[t] = c
            }
            var u = e.groups;
            for (r = 0,
            n = u.length; r < n; r++) {
                var h = u[r];
                this.addGroup(h.start, h.count, h.materialIndex)
            }
            var p = e.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var d = e.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    xr.prototype = Object.create(or.prototype),
    xr.prototype.constructor = xr,
    wr.prototype = Object.create(br.prototype),
    wr.prototype.constructor = wr,
    _r.prototype = Object.create(or.prototype),
    _r.prototype.constructor = _r,
    Mr.prototype = Object.create(br.prototype),
    Mr.prototype.constructor = Mr;
    var Sr = 0;
    function Er() {
        Object.defineProperty(this, "id", {
            value: Sr++
        }),
        this.uuid = Et.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.lights = !0,
        this.blending = b,
        this.side = p,
        this.flatShading = !1,
        this.vertexColors = m,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = I,
        this.blendDst = N,
        this.blendEquation = S,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = H,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.userData = {},
        this.needsUpdate = !0
    }
    function Tr(e) {
        Er.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(e))
    }
    function Ar(e, t) {
        this.origin = void 0 !== e ? e : new Pt,
        this.direction = void 0 !== t ? t : new Pt
    }
    function Lr(e, t, r) {
        this.a = void 0 !== e ? e : new Pt,
        this.b = void 0 !== t ? t : new Pt,
        this.c = void 0 !== r ? r : new Pt
    }
    function Pr(e) {
        Er.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new Yt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Y,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Cr(e, t) {
        nr.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== e ? e : new br,
        this.material = void 0 !== t ? t : new Pr({
            color: 16777215 * Math.random()
        }),
        this.drawMode = ht,
        this.updateMorphTargets()
    }
    function Rr(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }
    function Or(e, t, r, n, i, o, a, s, c, l) {
        e = void 0 !== e ? e : [],
        t = void 0 !== t ? t : ne,
        It.call(this, e, t, r, n, i, o, a, s, c, l),
        this.flipY = !1
    }
    function Ir(e, t, r, n) {
        It.call(this, null),
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: n
        },
        this.magFilter = de,
        this.minFilter = de,
        this.generateMipmaps = !1,
        this.flipY = !1
    }
    Er.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Er,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var r = e[t];
                    if (void 0 !== r)
                        if ("shading" !== t) {
                            var n = this[t];
                            void 0 !== n ? n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[t] = r : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                        } else
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = 1 === r;
                    else
                        console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                }
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function n(e) {
                var t = [];
                for (var r in e) {
                    var n = e[r];
                    delete n.metadata,
                    t.push(n)
                }
                return t
            }
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            this.color && this.color.isColor && (r.color = this.color.getHex()),
            void 0 !== this.roughness && (r.roughness = this.roughness),
            void 0 !== this.metalness && (r.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (r.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
            void 0 !== this.shininess && (r.shininess = this.shininess),
            void 0 !== this.clearCoat && (r.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (r.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
            r.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
            r.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
            r.normalMapType = this.normalMapType,
            r.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
            r.displacementScale = this.displacementScale,
            r.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
            r.reflectivity = this.reflectivity,
            void 0 !== this.combine && (r.combine = this.combine),
            void 0 !== this.envMapIntensity && (r.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (r.size = this.size),
            void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation),
            this.blending !== b && (r.blending = this.blending),
            !0 === this.flatShading && (r.flatShading = this.flatShading),
            this.side !== p && (r.side = this.side),
            this.vertexColors !== m && (r.vertexColors = this.vertexColors),
            this.opacity < 1 && (r.opacity = this.opacity),
            !0 === this.transparent && (r.transparent = this.transparent),
            r.depthFunc = this.depthFunc,
            r.depthTest = this.depthTest,
            r.depthWrite = this.depthWrite,
            0 !== this.rotation && (r.rotation = this.rotation),
            !0 === this.polygonOffset && (r.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (r.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (r.polygonOffsetUnits = this.polygonOffsetUnits),
            1 !== this.linewidth && (r.linewidth = this.linewidth),
            void 0 !== this.dashSize && (r.dashSize = this.dashSize),
            void 0 !== this.gapSize && (r.gapSize = this.gapSize),
            void 0 !== this.scale && (r.scale = this.scale),
            !0 === this.dithering && (r.dithering = !0),
            this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (r.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (r.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (r.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (r.morphTargets = !0),
            !0 === this.skinning && (r.skinning = !0),
            !1 === this.visible && (r.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
            t) {
                var i = n(e.textures)
                  , o = n(e.images);
                i.length > 0 && (r.textures = i),
                o.length > 0 && (r.images = o)
            }
            return r
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name,
            this.fog = e.fog,
            this.lights = e.lights,
            this.blending = e.blending,
            this.side = e.side,
            this.flatShading = e.flatShading,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.visible = e.visible,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this.clipShadows = e.clipShadows,
            this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes
              , r = null;
            if (null !== t) {
                var n = t.length;
                r = new Array(n);
                for (var i = 0; i !== n; ++i)
                    r[i] = t[i].clone()
            }
            return this.clippingPlanes = r,
            this.shadowSide = e.shadowSide,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Tr.prototype = Object.create(Er.prototype),
    Tr.prototype.constructor = Tr,
    Tr.prototype.isShaderMaterial = !0,
    Tr.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Vt(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.extensions = e.extensions,
        this
    }
    ,
    Tr.prototype.toJSON = function(e) {
        var t = Er.prototype.toJSON.call(this, e);
        for (var r in t.uniforms = {},
        this.uniforms) {
            var n = this.uniforms[r].value;
            n && n.isTexture ? t.uniforms[r] = {
                type: "t",
                value: n.toJSON(e).uuid
            } : n && n.isColor ? t.uniforms[r] = {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: n.toArray()
            } : t.uniforms[r] = {
                value: n
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        var i = {};
        for (var o in this.extensions)
            !0 === this.extensions[o] && (i[o] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
    ,
    Object.assign(Ar.prototype, {
        set: function(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"),
            t = new Pt),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        },
        recast: function() {
            var e = new Pt;
            return function(t) {
                return this.origin.copy(this.at(t, e)),
                this
            }
        }(),
        closestPointToPoint: function(e, t) {
            void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            t = new Pt),
            t.subVectors(e, this.origin);
            var r = t.dot(this.direction);
            return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function() {
            var e = new Pt;
            return function(t) {
                var r = e.subVectors(t, this.origin).dot(this.direction);
                return r < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(r).add(this.origin),
                e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: function() {
            var e = new Pt
              , t = new Pt
              , r = new Pt;
            return function(n, i, o, a) {
                e.copy(n).add(i).multiplyScalar(.5),
                t.copy(i).sub(n).normalize(),
                r.copy(this.origin).sub(e);
                var s, c, l, u, h = .5 * n.distanceTo(i), p = -this.direction.dot(t), d = r.dot(this.direction), f = -r.dot(t), m = r.lengthSq(), v = Math.abs(1 - p * p);
                if (v > 0)
                    if (c = p * d - f,
                    u = h * v,
                    (s = p * f - d) >= 0)
                        if (c >= -u)
                            if (c <= u) {
                                var g = 1 / v;
                                l = (s *= g) * (s + p * (c *= g) + 2 * d) + c * (p * s + c + 2 * f) + m
                            } else
                                c = h,
                                l = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                        else
                            c = -h,
                            l = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                    else
                        c <= -u ? l = -(s = Math.max(0, -(-p * h + d))) * s + (c = s > 0 ? -h : Math.min(Math.max(-h, -f), h)) * (c + 2 * f) + m : c <= u ? (s = 0,
                        l = (c = Math.min(Math.max(-h, -f), h)) * (c + 2 * f) + m) : l = -(s = Math.max(0, -(p * h + d))) * s + (c = s > 0 ? h : Math.min(Math.max(-h, -f), h)) * (c + 2 * f) + m;
                else
                    c = p > 0 ? -h : h,
                    l = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                return o && o.copy(this.direction).multiplyScalar(s).add(this.origin),
                a && a.copy(t).multiplyScalar(c).add(e),
                l
            }
        }(),
        intersectSphere: function() {
            var e = new Pt;
            return function(t, r) {
                e.subVectors(t.center, this.origin);
                var n = e.dot(this.direction)
                  , i = e.dot(e) - n * n
                  , o = t.radius * t.radius;
                if (i > o)
                    return null;
                var a = Math.sqrt(o - i)
                  , s = n - a
                  , c = n + a;
                return s < 0 && c < 0 ? null : s < 0 ? this.at(c, r) : this.at(s, r)
            }
        }(),
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            if (0 === t)
                return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var r = -(this.origin.dot(e.normal) + e.constant) / t;
            return r >= 0 ? r : null
        },
        intersectPlane: function(e, t) {
            var r = this.distanceToPlane(e);
            return null === r ? null : this.at(r, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function(e, t) {
            var r, n, i, o, a, s, c = 1 / this.direction.x, l = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin;
            return c >= 0 ? (r = (e.min.x - h.x) * c,
            n = (e.max.x - h.x) * c) : (r = (e.max.x - h.x) * c,
            n = (e.min.x - h.x) * c),
            l >= 0 ? (i = (e.min.y - h.y) * l,
            o = (e.max.y - h.y) * l) : (i = (e.max.y - h.y) * l,
            o = (e.min.y - h.y) * l),
            r > o || i > n ? null : ((i > r || r != r) && (r = i),
            (o < n || n != n) && (n = o),
            u >= 0 ? (a = (e.min.z - h.z) * u,
            s = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u,
            s = (e.min.z - h.z) * u),
            r > s || a > n ? null : ((a > r || r != r) && (r = a),
            (s < n || n != n) && (n = s),
            n < 0 ? null : this.at(r >= 0 ? r : n, t)))
        },
        intersectsBox: function() {
            var e = new Pt;
            return function(t) {
                return null !== this.intersectBox(t, e)
            }
        }(),
        intersectTriangle: function() {
            var e = new Pt
              , t = new Pt
              , r = new Pt
              , n = new Pt;
            return function(i, o, a, s, c) {
                t.subVectors(o, i),
                r.subVectors(a, i),
                n.crossVectors(t, r);
                var l, u = this.direction.dot(n);
                if (u > 0) {
                    if (s)
                        return null;
                    l = 1
                } else {
                    if (!(u < 0))
                        return null;
                    l = -1,
                    u = -u
                }
                e.subVectors(this.origin, i);
                var h = l * this.direction.dot(r.crossVectors(e, r));
                if (h < 0)
                    return null;
                var p = l * this.direction.dot(t.cross(e));
                if (p < 0)
                    return null;
                if (h + p > u)
                    return null;
                var d = -l * e.dot(n);
                return d < 0 ? null : this.at(d / u, c)
            }
        }(),
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }),
    Object.assign(Lr, {
        getNormal: function() {
            var e = new Pt;
            return function(t, r, n, i) {
                void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"),
                i = new Pt),
                i.subVectors(n, r),
                e.subVectors(t, r),
                i.cross(e);
                var o = i.lengthSq();
                return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0)
            }
        }(),
        getBarycoord: function() {
            var e = new Pt
              , t = new Pt
              , r = new Pt;
            return function(n, i, o, a, s) {
                e.subVectors(a, i),
                t.subVectors(o, i),
                r.subVectors(n, i);
                var c = e.dot(e)
                  , l = e.dot(t)
                  , u = e.dot(r)
                  , h = t.dot(t)
                  , p = t.dot(r)
                  , d = c * h - l * l;
                if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
                s = new Pt),
                0 === d)
                    return s.set(-2, -1, -1);
                var f = 1 / d
                  , m = (h * u - l * p) * f
                  , v = (c * p - l * u) * f;
                return s.set(1 - m - v, v, m)
            }
        }(),
        containsPoint: function() {
            var e = new Pt;
            return function(t, r, n, i) {
                return Lr.getBarycoord(t, r, n, i, e),
                e.x >= 0 && e.y >= 0 && e.x + e.y <= 1
            }
        }(),
        getUV: function() {
            var e = new Pt;
            return function(t, r, n, i, o, a, s, c) {
                return this.getBarycoord(t, r, n, i, e),
                c.set(0, 0),
                c.addScaledVector(o, e.x),
                c.addScaledVector(a, e.y),
                c.addScaledVector(s, e.z),
                c
            }
        }()
    }),
    Object.assign(Lr.prototype, {
        set: function(e, t, r) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(r),
            this
        },
        setFromPointsAndIndices: function(e, t, r, n) {
            return this.a.copy(e[t]),
            this.b.copy(e[r]),
            this.c.copy(e[n]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        },
        getArea: function() {
            var e = new Pt
              , t = new Pt;
            return function() {
                return e.subVectors(this.c, this.b),
                t.subVectors(this.a, this.b),
                .5 * e.cross(t).length()
            }
        }(),
        getMidpoint: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            e = new Pt),
            e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return Lr.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            e = new Pt),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return Lr.getBarycoord(e, this.a, this.b, this.c, t)
        },
        containsPoint: function(e) {
            return Lr.containsPoint(e, this.a, this.b, this.c)
        },
        getUV: function(e, t, r, n, i) {
            return Lr.getUV(e, this.a, this.b, this.c, t, r, n, i)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var e = new Pt
              , t = new Pt
              , r = new Pt
              , n = new Pt
              , i = new Pt
              , o = new Pt;
            return function(a, s) {
                void 0 === s && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
                s = new Pt);
                var c, l, u = this.a, h = this.b, p = this.c;
                e.subVectors(h, u),
                t.subVectors(p, u),
                n.subVectors(a, u);
                var d = e.dot(n)
                  , f = t.dot(n);
                if (d <= 0 && f <= 0)
                    return s.copy(u);
                i.subVectors(a, h);
                var m = e.dot(i)
                  , v = t.dot(i);
                if (m >= 0 && v <= m)
                    return s.copy(h);
                var g = d * v - m * f;
                if (g <= 0 && d >= 0 && m <= 0)
                    return c = d / (d - m),
                    s.copy(u).addScaledVector(e, c);
                o.subVectors(a, p);
                var y = e.dot(o)
                  , b = t.dot(o);
                if (b >= 0 && y <= b)
                    return s.copy(p);
                var x = y * f - d * b;
                if (x <= 0 && f >= 0 && b <= 0)
                    return l = f / (f - b),
                    s.copy(u).addScaledVector(t, l);
                var w = m * b - y * v;
                if (w <= 0 && v - m >= 0 && y - b >= 0)
                    return r.subVectors(p, h),
                    l = (v - m) / (v - m + (y - b)),
                    s.copy(h).addScaledVector(r, l);
                var _ = 1 / (w + x + g);
                return c = x * _,
                l = g * _,
                s.copy(u).addScaledVector(e, c).addScaledVector(t, l)
            }
        }(),
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }),
    Pr.prototype = Object.create(Er.prototype),
    Pr.prototype.constructor = Pr,
    Pr.prototype.isMeshBasicMaterial = !0,
    Pr.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    Cr.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: Cr,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return nr.prototype.copy.call(this, e),
            this.drawMode = e.drawMode,
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var e, t, r, n = this.geometry;
            if (n.isBufferGeometry) {
                var i = n.morphAttributes
                  , o = Object.keys(i);
                if (o.length > 0) {
                    var a = i[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        e = 0,
                        t = a.length; e < t; e++)
                            r = a[e].name || String(e),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[r] = e
                }
            } else {
                var s = n.morphTargets;
                void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function() {
            var e = new At
              , t = new Ar
              , r = new jt
              , n = new Pt
              , i = new Pt
              , o = new Pt
              , a = new Pt
              , s = new Pt
              , c = new Pt
              , l = new Tt
              , u = new Tt
              , h = new Tt
              , p = new Pt
              , m = new Pt;
            function v(e, t, r, n, i, o, a, s) {
                if (null === (t.side === d ? n.intersectTriangle(a, o, i, !0, s) : n.intersectTriangle(i, o, a, t.side !== f, s)))
                    return null;
                m.copy(s),
                m.applyMatrix4(e.matrixWorld);
                var c = r.ray.origin.distanceTo(m);
                return c < r.near || c > r.far ? null : {
                    distance: c,
                    point: m.clone(),
                    object: e
                }
            }
            function g(e, t, r, a, s, c, d, f, m) {
                n.fromBufferAttribute(s, d),
                i.fromBufferAttribute(s, f),
                o.fromBufferAttribute(s, m);
                var g = v(e, t, r, a, n, i, o, p);
                if (g) {
                    c && (l.fromBufferAttribute(c, d),
                    u.fromBufferAttribute(c, f),
                    h.fromBufferAttribute(c, m),
                    g.uv = Lr.getUV(p, n, i, o, l, u, h, new Tt));
                    var y = new $t(d,f,m);
                    Lr.getNormal(n, i, o, y.normal),
                    g.face = y
                }
                return g
            }
            return function(d, f) {
                var m, y = this.geometry, b = this.material, x = this.matrixWorld;
                if (void 0 !== b && (null === y.boundingSphere && y.computeBoundingSphere(),
                r.copy(y.boundingSphere),
                r.applyMatrix4(x),
                !1 !== d.ray.intersectsSphere(r) && (e.getInverse(x),
                t.copy(d.ray).applyMatrix4(e),
                null === y.boundingBox || !1 !== t.intersectsBox(y.boundingBox))))
                    if (y.isBufferGeometry) {
                        var w, _, M, S, E, T, A, L, P, C = y.index, R = y.attributes.position, O = y.attributes.uv, I = y.groups, N = y.drawRange;
                        if (null !== C)
                            if (Array.isArray(b))
                                for (S = 0,
                                T = I.length; S < T; S++)
                                    for (P = b[(L = I[S]).materialIndex],
                                    E = Math.max(L.start, N.start),
                                    A = Math.min(L.start + L.count, N.start + N.count); E < A; E += 3)
                                        w = C.getX(E),
                                        _ = C.getX(E + 1),
                                        M = C.getX(E + 2),
                                        (m = g(this, P, d, t, R, O, w, _, M)) && (m.faceIndex = Math.floor(E / 3),
                                        m.face.materialIndex = L.materialIndex,
                                        f.push(m));
                            else
                                for (S = Math.max(0, N.start),
                                T = Math.min(C.count, N.start + N.count); S < T; S += 3)
                                    w = C.getX(S),
                                    _ = C.getX(S + 1),
                                    M = C.getX(S + 2),
                                    (m = g(this, b, d, t, R, O, w, _, M)) && (m.faceIndex = Math.floor(S / 3),
                                    f.push(m));
                        else if (void 0 !== R)
                            if (Array.isArray(b))
                                for (S = 0,
                                T = I.length; S < T; S++)
                                    for (P = b[(L = I[S]).materialIndex],
                                    E = Math.max(L.start, N.start),
                                    A = Math.min(L.start + L.count, N.start + N.count); E < A; E += 3)
                                        (m = g(this, P, d, t, R, O, w = E, _ = E + 1, M = E + 2)) && (m.faceIndex = Math.floor(E / 3),
                                        m.face.materialIndex = L.materialIndex,
                                        f.push(m));
                            else
                                for (S = Math.max(0, N.start),
                                T = Math.min(R.count, N.start + N.count); S < T; S += 3)
                                    (m = g(this, b, d, t, R, O, w = S, _ = S + 1, M = S + 2)) && (m.faceIndex = Math.floor(S / 3),
                                    f.push(m))
                    } else if (y.isGeometry) {
                        var D, B, z, G, U = Array.isArray(b), j = y.vertices, F = y.faces, k = y.faceVertexUvs[0];
                        k.length > 0 && (G = k);
                        for (var H = 0, V = F.length; H < V; H++) {
                            var W = F[H]
                              , q = U ? b[W.materialIndex] : b;
                            if (void 0 !== q) {
                                if (D = j[W.a],
                                B = j[W.b],
                                z = j[W.c],
                                !0 === q.morphTargets) {
                                    var X = y.morphTargets
                                      , Y = this.morphTargetInfluences;
                                    n.set(0, 0, 0),
                                    i.set(0, 0, 0),
                                    o.set(0, 0, 0);
                                    for (var J = 0, Z = X.length; J < Z; J++) {
                                        var K = Y[J];
                                        if (0 !== K) {
                                            var Q = X[J].vertices;
                                            n.addScaledVector(a.subVectors(Q[W.a], D), K),
                                            i.addScaledVector(s.subVectors(Q[W.b], B), K),
                                            o.addScaledVector(c.subVectors(Q[W.c], z), K)
                                        }
                                    }
                                    n.add(D),
                                    i.add(B),
                                    o.add(z),
                                    D = n,
                                    B = i,
                                    z = o
                                }
                                if (m = v(this, q, d, t, D, B, z, p)) {
                                    if (G && G[H]) {
                                        var $ = G[H];
                                        l.copy($[0]),
                                        u.copy($[1]),
                                        h.copy($[2]),
                                        m.uv = Lr.getUV(p, D, B, z, l, u, h, new Tt)
                                    }
                                    m.face = W,
                                    m.faceIndex = H,
                                    f.push(m)
                                }
                            }
                        }
                    }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Or.prototype = Object.create(It.prototype),
    Or.prototype.constructor = Or,
    Or.prototype.isCubeTexture = !0,
    Object.defineProperty(Or.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }),
    Ir.prototype = Object.create(It.prototype),
    Ir.prototype.constructor = Ir,
    Ir.prototype.isDataTexture3D = !0;
    var Nr = new It
      , Dr = new Ir
      , Br = new Or;
    function zr() {
        this.seq = [],
        this.map = {}
    }
    var Gr = []
      , Ur = []
      , jr = new Float32Array(16)
      , Fr = new Float32Array(9)
      , kr = new Float32Array(4);
    function Hr(e, t, r) {
        var n = e[0];
        if (n <= 0 || n > 0)
            return e;
        var i = t * r
          , o = Gr[i];
        if (void 0 === o && (o = new Float32Array(i),
        Gr[i] = o),
        0 !== t) {
            n.toArray(o, 0);
            for (var a = 1, s = 0; a !== t; ++a)
                s += r,
                e[a].toArray(o, s)
        }
        return o
    }
    function Vr(e, t) {
        if (e.length !== t.length)
            return !1;
        for (var r = 0, n = e.length; r < n; r++)
            if (e[r] !== t[r])
                return !1;
        return !0
    }
    function Wr(e, t) {
        for (var r = 0, n = t.length; r < n; r++)
            e[r] = t[r]
    }
    function qr(e, t) {
        var r = Ur[t];
        void 0 === r && (r = new Int32Array(t),
        Ur[t] = r);
        for (var n = 0; n !== t; ++n)
            r[n] = e.allocTextureUnit();
        return r
    }
    function Xr(e, t) {
        var r = this.cache;
        r[0] !== t && (e.uniform1f(this.addr, t),
        r[0] = t)
    }
    function Yr(e, t) {
        var r = this.cache;
        r[0] !== t && (e.uniform1i(this.addr, t),
        r[0] = t)
    }
    function Jr(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
            r[0] === t.x && r[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
            r[0] = t.x,
            r[1] = t.y);
        else {
            if (Vr(r, t))
                return;
            e.uniform2fv(this.addr, t),
            Wr(r, t)
        }
    }
    function Zr(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
            r[0] === t.x && r[1] === t.y && r[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
            r[0] = t.x,
            r[1] = t.y,
            r[2] = t.z);
        else if (void 0 !== t.r)
            r[0] === t.r && r[1] === t.g && r[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
            r[0] = t.r,
            r[1] = t.g,
            r[2] = t.b);
        else {
            if (Vr(r, t))
                return;
            e.uniform3fv(this.addr, t),
            Wr(r, t)
        }
    }
    function Kr(e, t) {
        var r = this.cache;
        if (void 0 !== t.x)
            r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            r[0] = t.x,
            r[1] = t.y,
            r[2] = t.z,
            r[3] = t.w);
        else {
            if (Vr(r, t))
                return;
            e.uniform4fv(this.addr, t),
            Wr(r, t)
        }
    }
    function Qr(e, t) {
        var r = this.cache
          , n = t.elements;
        if (void 0 === n) {
            if (Vr(r, t))
                return;
            e.uniformMatrix2fv(this.addr, !1, t),
            Wr(r, t)
        } else {
            if (Vr(r, n))
                return;
            kr.set(n),
            e.uniformMatrix2fv(this.addr, !1, kr),
            Wr(r, n)
        }
    }
    function $r(e, t) {
        var r = this.cache
          , n = t.elements;
        if (void 0 === n) {
            if (Vr(r, t))
                return;
            e.uniformMatrix3fv(this.addr, !1, t),
            Wr(r, t)
        } else {
            if (Vr(r, n))
                return;
            Fr.set(n),
            e.uniformMatrix3fv(this.addr, !1, Fr),
            Wr(r, n)
        }
    }
    function en(e, t) {
        var r = this.cache
          , n = t.elements;
        if (void 0 === n) {
            if (Vr(r, t))
                return;
            e.uniformMatrix4fv(this.addr, !1, t),
            Wr(r, t)
        } else {
            if (Vr(r, n))
                return;
            jr.set(n),
            e.uniformMatrix4fv(this.addr, !1, jr),
            Wr(r, n)
        }
    }
    function tn(e, t, r) {
        var n = this.cache
          , i = r.allocTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i),
        n[0] = i),
        r.setTexture2D(t || Nr, i)
    }
    function rn(e, t, r) {
        var n = this.cache
          , i = r.allocTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i),
        n[0] = i),
        r.setTexture3D(t || Dr, i)
    }
    function nn(e, t, r) {
        var n = this.cache
          , i = r.allocTextureUnit();
        n[0] !== i && (e.uniform1i(this.addr, i),
        n[0] = i),
        r.setTextureCube(t || Br, i)
    }
    function on(e, t) {
        var r = this.cache;
        Vr(r, t) || (e.uniform2iv(this.addr, t),
        Wr(r, t))
    }
    function an(e, t) {
        var r = this.cache;
        Vr(r, t) || (e.uniform3iv(this.addr, t),
        Wr(r, t))
    }
    function sn(e, t) {
        var r = this.cache;
        Vr(r, t) || (e.uniform4iv(this.addr, t),
        Wr(r, t))
    }
    function cn(e, t) {
        var r = this.cache;
        Vr(r, t) || (e.uniform1fv(this.addr, t),
        Wr(r, t))
    }
    function ln(e, t) {
        var r = this.cache;
        Vr(r, t) || (e.uniform1iv(this.addr, t),
        Wr(r, t))
    }
    function un(e, t) {
        var r = this.cache
          , n = Hr(t, this.size, 2);
        Vr(r, n) || (e.uniform2fv(this.addr, n),
        this.updateCache(n))
    }
    function hn(e, t) {
        var r = this.cache
          , n = Hr(t, this.size, 3);
        Vr(r, n) || (e.uniform3fv(this.addr, n),
        this.updateCache(n))
    }
    function pn(e, t) {
        var r = this.cache
          , n = Hr(t, this.size, 4);
        Vr(r, n) || (e.uniform4fv(this.addr, n),
        this.updateCache(n))
    }
    function dn(e, t) {
        var r = this.cache
          , n = Hr(t, this.size, 4);
        Vr(r, n) || (e.uniformMatrix2fv(this.addr, !1, n),
        this.updateCache(n))
    }
    function fn(e, t) {
        var r = this.cache
          , n = Hr(t, this.size, 9);
        Vr(r, n) || (e.uniformMatrix3fv(this.addr, !1, n),
        this.updateCache(n))
    }
    function mn(e, t) {
        var r = this.cache
          , n = Hr(t, this.size, 16);
        Vr(r, n) || (e.uniformMatrix4fv(this.addr, !1, n),
        this.updateCache(n))
    }
    function vn(e, t, r) {
        var n = this.cache
          , i = t.length
          , o = qr(r, i);
        !1 === Vr(n, o) && (e.uniform1iv(this.addr, o),
        Wr(n, o));
        for (var a = 0; a !== i; ++a)
            r.setTexture2D(t[a] || Nr, o[a])
    }
    function gn(e, t, r) {
        var n = this.cache
          , i = t.length
          , o = qr(r, i);
        !1 === Vr(n, o) && (e.uniform1iv(this.addr, o),
        Wr(n, o));
        for (var a = 0; a !== i; ++a)
            r.setTextureCube(t[a] || Br, o[a])
    }
    function yn(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Xr;
            case 35664:
                return Jr;
            case 35665:
                return Zr;
            case 35666:
                return Kr;
            case 35674:
                return Qr;
            case 35675:
                return $r;
            case 35676:
                return en;
            case 35678:
            case 36198:
                return tn;
            case 35679:
                return rn;
            case 35680:
                return nn;
            case 5124:
            case 35670:
                return Yr;
            case 35667:
            case 35671:
                return on;
            case 35668:
            case 35672:
                return an;
            case 35669:
            case 35673:
                return sn
            }
        }(t.type)
    }
    function bn(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return cn;
            case 35664:
                return un;
            case 35665:
                return hn;
            case 35666:
                return pn;
            case 35674:
                return dn;
            case 35675:
                return fn;
            case 35676:
                return mn;
            case 35678:
                return vn;
            case 35680:
                return gn;
            case 5124:
            case 35670:
                return ln;
            case 35667:
            case 35671:
                return on;
            case 35668:
            case 35672:
                return an;
            case 35669:
            case 35673:
                return sn
            }
        }(t.type)
    }
    function xn(e) {
        this.id = e,
        zr.call(this)
    }
    bn.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
        Wr(t, e)
    }
    ,
    xn.prototype.setValue = function(e, t, r) {
        for (var n = this.seq, i = 0, o = n.length; i !== o; ++i) {
            var a = n[i];
            a.setValue(e, t[a.id], r)
        }
    }
    ;
    var wn = /([\w\d_]+)(\])?(\[|\.)?/g;
    function _n(e, t) {
        e.seq.push(t),
        e.map[t.id] = t
    }
    function Mn(e, t, r) {
        var n = e.name
          , i = n.length;
        for (wn.lastIndex = 0; ; ) {
            var o = wn.exec(n)
              , a = wn.lastIndex
              , s = o[1]
              , c = "]" === o[2]
              , l = o[3];
            if (c && (s |= 0),
            void 0 === l || "[" === l && a + 2 === i) {
                _n(r, void 0 === l ? new yn(s,e,t) : new bn(s,e,t));
                break
            }
            var u = r.map[s];
            void 0 === u && _n(r, u = new xn(s)),
            r = u
        }
    }
    function Sn(e, t, r) {
        zr.call(this),
        this.renderer = r;
        for (var n = e.getProgramParameter(t, 35718), i = 0; i < n; ++i) {
            var o = e.getActiveUniform(t, i);
            Mn(o, e.getUniformLocation(t, o.name), this)
        }
    }
    function En(e, t, r) {
        var n = e.createShader(t);
        return e.shaderSource(n, r),
        e.compileShader(n),
        !1 === e.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== e.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(n), function(e) {
            for (var t = e.split("\n"), r = 0; r < t.length; r++)
                t[r] = r + 1 + ": " + t[r];
            return t.join("\n")
        }(r)),
        n
    }
    Sn.prototype.setValue = function(e, t, r) {
        var n = this.map[t];
        void 0 !== n && n.setValue(e, r, this.renderer)
    }
    ,
    Sn.prototype.setOptional = function(e, t, r) {
        var n = t[r];
        void 0 !== n && this.setValue(e, r, n)
    }
    ,
    Sn.upload = function(e, t, r, n) {
        for (var i = 0, o = t.length; i !== o; ++i) {
            var a = t[i]
              , s = r[a.id];
            !1 !== s.needsUpdate && a.setValue(e, s.value, n)
        }
    }
    ,
    Sn.seqWithValue = function(e, t) {
        for (var r = [], n = 0, i = e.length; n !== i; ++n) {
            var o = e[n];
            o.id in t && r.push(o)
        }
        return r
    }
    ;
    var Tn = 0;
    function An(e) {
        switch (e) {
        case ft:
            return ["Linear", "( value )"];
        case mt:
            return ["sRGB", "( value )"];
        case gt:
            return ["RGBE", "( value )"];
        case yt:
            return ["RGBM", "( value, 7.0 )"];
        case bt:
            return ["RGBM", "( value, 16.0 )"];
        case xt:
            return ["RGBD", "( value, 256.0 )"];
        case vt:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw new Error("unsupported encoding: " + e)
        }
    }
    function Ln(e, t) {
        var r = An(t);
        return "vec4 " + e + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }"
    }
    function Pn(e) {
        return "" !== e
    }
    function Cn(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }
    function Rn(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    function On(e) {
        return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, t) {
            var r = Ht[t];
            if (void 0 === r)
                throw new Error("Can not resolve #include <" + t + ">");
            return On(r)
        })
    }
    function In(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(e, t, r, n) {
            for (var i = "", o = parseInt(t); o < parseInt(r); o++)
                i += n.replace(/\[ i \]/g, "[ " + o + " ]");
            return i
        })
    }
    function Nn(e, t, r, n, i, o, a) {
        var s = e.context
          , c = n.defines
          , l = i.vertexShader
          , p = i.fragmentShader
          , d = "SHADOWMAP_TYPE_BASIC";
        o.shadowMapType === u ? d = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === h && (d = "SHADOWMAP_TYPE_PCF_SOFT");
        var f = "ENVMAP_TYPE_CUBE"
          , m = "ENVMAP_MODE_REFLECTION"
          , v = "ENVMAP_BLENDING_MULTIPLY";
        if (o.envMap) {
            switch (n.envMap.mapping) {
            case ne:
            case ie:
                f = "ENVMAP_TYPE_CUBE";
                break;
            case ce:
            case le:
                f = "ENVMAP_TYPE_CUBE_UV";
                break;
            case oe:
            case ae:
                f = "ENVMAP_TYPE_EQUIREC";
                break;
            case se:
                f = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
            case ie:
            case ae:
                m = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
            case Y:
                v = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case J:
                v = "ENVMAP_BLENDING_MIX";
                break;
            case Z:
                v = "ENVMAP_BLENDING_ADD"
            }
        }
        var g, y, b = e.gammaFactor > 0 ? e.gammaFactor : 1, x = a.isWebGL2 ? "" : function(e, t, r) {
            return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && r.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && r.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && r.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Pn).join("\n")
        }(n.extensions, o, t), w = function(e) {
            var t = [];
            for (var r in e) {
                var n = e[r];
                !1 !== n && t.push("#define " + r + " " + n)
            }
            return t.join("\n")
        }(c), _ = s.createProgram();
        if (n.isRawShaderMaterial ? ((g = [w].filter(Pn).join("\n")).length > 0 && (g += "\n"),
        (y = [x, w].filter(Pn).join("\n")).length > 0 && (y += "\n")) : (g = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + b, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Pn).join("\n"),
        y = [x, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + b, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.envMap ? "#define " + v : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== K ? "#define TONE_MAPPING" : "", o.toneMapping !== K ? Ht.tonemapping_pars_fragment : "", o.toneMapping !== K ? function(e, t) {
            var r;
            switch (t) {
            case Q:
                r = "Linear";
                break;
            case $:
                r = "Reinhard";
                break;
            case ee:
                r = "Uncharted2";
                break;
            case te:
                r = "OptimizedCineon";
                break;
            case re:
                r = "ACESFilmic";
                break;
            default:
                throw new Error("unsupported toneMapping: " + t)
            }
            return "vec3 " + e + "( vec3 color ) { return " + r + "ToneMapping( color ); }"
        }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? Ht.encodings_pars_fragment : "", o.mapEncoding ? Ln("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Ln("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Ln("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ln("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? function(e, t) {
            var r = An(t);
            return "vec4 " + e + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }"
        }("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Pn).join("\n")),
        l = Rn(l = Cn(l = On(l), o), o),
        p = Rn(p = Cn(p = On(p), o), o),
        l = In(l),
        p = In(p),
        a.isWebGL2 && !n.isRawShaderMaterial) {
            var M = !1
              , S = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== l.match(S) && null !== p.match(S) && (M = !0,
            l = l.replace(S, ""),
            p = p.replace(S, "")),
            g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
            y = ["#version 300 es\n", "#define varying in", M ? "" : "out highp vec4 pc_fragColor;", M ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y
        }
        var E = y + p
          , T = En(s, 35633, g + l)
          , A = En(s, 35632, E);
        s.attachShader(_, T),
        s.attachShader(_, A),
        void 0 !== n.index0AttributeName ? s.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === o.morphTargets && s.bindAttribLocation(_, 0, "position"),
        s.linkProgram(_);
        var L, P, C = s.getProgramInfoLog(_).trim(), R = s.getShaderInfoLog(T).trim(), O = s.getShaderInfoLog(A).trim(), I = !0, N = !0;
        return !1 === s.getProgramParameter(_, 35714) ? (I = !1,
        console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(_, 35715), "gl.getProgramInfoLog", C, R, O)) : "" !== C ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C) : "" !== R && "" !== O || (N = !1),
        N && (this.diagnostics = {
            runnable: I,
            material: n,
            programLog: C,
            vertexShader: {
                log: R,
                prefix: g
            },
            fragmentShader: {
                log: O,
                prefix: y
            }
        }),
        s.deleteShader(T),
        s.deleteShader(A),
        this.getUniforms = function() {
            return void 0 === L && (L = new Sn(s,_,e)),
            L
        }
        ,
        this.getAttributes = function() {
            return void 0 === P && (P = function(e, t) {
                for (var r = {}, n = e.getProgramParameter(t, 35721), i = 0; i < n; i++) {
                    var o = e.getActiveAttrib(t, i).name;
                    r[o] = e.getAttribLocation(t, o)
                }
                return r
            }(s, _)),
            P
        }
        ,
        this.destroy = function() {
            s.deleteProgram(_),
            this.program = void 0
        }
        ,
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                    this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes()
                }
            }
        }),
        this.name = i.name,
        this.id = Tn++,
        this.code = r,
        this.usedTimes = 1,
        this.program = _,
        this.vertexShader = T,
        this.fragmentShader = A,
        this
    }
    function Dn(e, t, r) {
        var n = []
          , i = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        function a(e, t) {
            var r;
            return e ? e.isTexture ? r = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            r = e.texture.encoding) : r = ft,
            r === ft && t && (r = vt),
            r
        }
        this.getParameters = function(t, n, o, s, c, l, u) {
            var h = i[t.type]
              , p = u.isSkinnedMesh ? function(e) {
                var t = e.skeleton.bones;
                if (r.floatVertexTextures)
                    return 1024;
                var n = r.maxVertexUniforms
                  , i = Math.floor((n - 20) / 4)
                  , o = Math.min(i, t.length);
                return o < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + o + "."),
                0) : o
            }(u) : 0
              , m = r.precision;
            null !== t.precision && (m = r.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", m, "instead.");
            var v = e.getRenderTarget();
            return {
                shaderID: h,
                precision: m,
                supportsVertexTextures: r.vertexTextures,
                outputEncoding: a(v ? v.texture : null, e.gammaOutput),
                map: !!t.map,
                mapEncoding: a(t.map, e.gammaInput),
                matcap: !!t.matcap,
                matcapEncoding: a(t.matcap, e.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: a(t.envMap, e.gammaInput),
                envMapCubeUV: !!t.envMap && (t.envMap.mapping === ce || t.envMap.mapping === le),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: a(t.emissiveMap, e.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                objectSpaceNormalMap: t.normalMapType === St,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                combine: t.combine,
                vertexColors: t.vertexColors,
                fog: !!s,
                useFog: t.fog,
                fogExp: s && s.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: r.logarithmicDepthBuffer,
                skinning: t.skinning && p > 0,
                maxBones: p,
                useVertexTexture: r.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: n.directional.length,
                numPointLights: n.point.length,
                numSpotLights: n.spot.length,
                numRectAreaLights: n.rectArea.length,
                numHemiLights: n.hemi.length,
                numClippingPlanes: c,
                numClipIntersection: l,
                dithering: t.dithering,
                shadowMapEnabled: e.shadowMap.enabled && u.receiveShadow && o.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: t.side === f,
                flipSided: t.side === d,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }
        ,
        this.getProgramCode = function(t, r) {
            var n = [];
            if (r.shaderID ? n.push(r.shaderID) : (n.push(t.fragmentShader),
            n.push(t.vertexShader)),
            void 0 !== t.defines)
                for (var i in t.defines)
                    n.push(i),
                    n.push(t.defines[i]);
            for (var a = 0; a < o.length; a++)
                n.push(r[o[a]]);
            return n.push(t.onBeforeCompile.toString()),
            n.push(e.gammaOutput),
            n.push(e.gammaFactor),
            n.join()
        }
        ,
        this.acquireProgram = function(i, o, a, s) {
            for (var c, l = 0, u = n.length; l < u; l++) {
                var h = n[l];
                if (h.code === s) {
                    ++(c = h).usedTimes;
                    break
                }
            }
            return void 0 === c && (c = new Nn(e,t,s,i,o,a,r),
            n.push(c)),
            c
        }
        ,
        this.releaseProgram = function(e) {
            if (0 == --e.usedTimes) {
                var t = n.indexOf(e);
                n[t] = n[n.length - 1],
                n.pop(),
                e.destroy()
            }
        }
        ,
        this.programs = n
    }
    function Bn(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }
    function zn(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }
    function Gn() {
        var e = []
          , t = 0
          , r = []
          , n = [];
        function i(r, n, i, o, a, s) {
            var c = e[t];
            return void 0 === c ? (c = {
                id: r.id,
                object: r,
                geometry: n,
                material: i,
                program: i.program,
                groupOrder: o,
                renderOrder: r.renderOrder,
                z: a,
                group: s
            },
            e[t] = c) : (c.id = r.id,
            c.object = r,
            c.geometry = n,
            c.material = i,
            c.program = i.program,
            c.groupOrder = o,
            c.renderOrder = r.renderOrder,
            c.z = a,
            c.group = s),
            t++,
            c
        }
        return {
            opaque: r,
            transparent: n,
            init: function() {
                t = 0,
                r.length = 0,
                n.length = 0
            },
            push: function(e, t, o, a, s, c) {
                var l = i(e, t, o, a, s, c);
                (!0 === o.transparent ? n : r).push(l)
            },
            unshift: function(e, t, o, a, s, c) {
                var l = i(e, t, o, a, s, c);
                (!0 === o.transparent ? n : r).unshift(l)
            },
            sort: function() {
                r.length > 1 && r.sort(Bn),
                n.length > 1 && n.sort(zn)
            }
        }
    }
    var Un = 0;
    function jn() {
        var e = new function() {
            var e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id])
                        return e[t.id];
                    var r;
                    switch (t.type) {
                    case "DirectionalLight":
                        r = {
                            direction: new Pt,
                            color: new Yt,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Tt
                        };
                        break;
                    case "SpotLight":
                        r = {
                            position: new Pt,
                            direction: new Pt,
                            color: new Yt,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Tt
                        };
                        break;
                    case "PointLight":
                        r = {
                            position: new Pt,
                            color: new Yt,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Tt,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case "HemisphereLight":
                        r = {
                            direction: new Pt,
                            skyColor: new Yt,
                            groundColor: new Yt
                        };
                        break;
                    case "RectAreaLight":
                        r = {
                            color: new Yt,
                            position: new Pt,
                            halfWidth: new Pt,
                            halfHeight: new Pt
                        }
                    }
                    return e[t.id] = r,
                    r
                }
            }
        }
          , t = {
            id: Un++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }
          , r = new Pt
          , n = new At
          , i = new At;
        return {
            setup: function(o, a, s) {
                for (var c = 0, l = 0, u = 0, h = 0, p = 0, d = 0, f = 0, m = 0, v = s.matrixWorldInverse, g = 0, y = o.length; g < y; g++) {
                    var b = o[g]
                      , x = b.color
                      , w = b.intensity
                      , _ = b.distance
                      , M = b.shadow && b.shadow.map ? b.shadow.map.texture : null;
                    if (b.isAmbientLight)
                        c += x.r * w,
                        l += x.g * w,
                        u += x.b * w;
                    else if (b.isDirectionalLight) {
                        if ((E = e.get(b)).color.copy(b.color).multiplyScalar(b.intensity),
                        E.direction.setFromMatrixPosition(b.matrixWorld),
                        r.setFromMatrixPosition(b.target.matrixWorld),
                        E.direction.sub(r),
                        E.direction.transformDirection(v),
                        E.shadow = b.castShadow,
                        b.castShadow) {
                            var S = b.shadow;
                            E.shadowBias = S.bias,
                            E.shadowRadius = S.radius,
                            E.shadowMapSize = S.mapSize
                        }
                        t.directionalShadowMap[h] = M,
                        t.directionalShadowMatrix[h] = b.shadow.matrix,
                        t.directional[h] = E,
                        h++
                    } else if (b.isSpotLight)
                        (E = e.get(b)).position.setFromMatrixPosition(b.matrixWorld),
                        E.position.applyMatrix4(v),
                        E.color.copy(x).multiplyScalar(w),
                        E.distance = _,
                        E.direction.setFromMatrixPosition(b.matrixWorld),
                        r.setFromMatrixPosition(b.target.matrixWorld),
                        E.direction.sub(r),
                        E.direction.transformDirection(v),
                        E.coneCos = Math.cos(b.angle),
                        E.penumbraCos = Math.cos(b.angle * (1 - b.penumbra)),
                        E.decay = b.decay,
                        E.shadow = b.castShadow,
                        b.castShadow && (S = b.shadow,
                        E.shadowBias = S.bias,
                        E.shadowRadius = S.radius,
                        E.shadowMapSize = S.mapSize),
                        t.spotShadowMap[d] = M,
                        t.spotShadowMatrix[d] = b.shadow.matrix,
                        t.spot[d] = E,
                        d++;
                    else if (b.isRectAreaLight)
                        (E = e.get(b)).color.copy(x).multiplyScalar(w),
                        E.position.setFromMatrixPosition(b.matrixWorld),
                        E.position.applyMatrix4(v),
                        i.identity(),
                        n.copy(b.matrixWorld),
                        n.premultiply(v),
                        i.extractRotation(n),
                        E.halfWidth.set(.5 * b.width, 0, 0),
                        E.halfHeight.set(0, .5 * b.height, 0),
                        E.halfWidth.applyMatrix4(i),
                        E.halfHeight.applyMatrix4(i),
                        t.rectArea[f] = E,
                        f++;
                    else if (b.isPointLight)
                        (E = e.get(b)).position.setFromMatrixPosition(b.matrixWorld),
                        E.position.applyMatrix4(v),
                        E.color.copy(b.color).multiplyScalar(b.intensity),
                        E.distance = b.distance,
                        E.decay = b.decay,
                        E.shadow = b.castShadow,
                        b.castShadow && (S = b.shadow,
                        E.shadowBias = S.bias,
                        E.shadowRadius = S.radius,
                        E.shadowMapSize = S.mapSize,
                        E.shadowCameraNear = S.camera.near,
                        E.shadowCameraFar = S.camera.far),
                        t.pointShadowMap[p] = M,
                        t.pointShadowMatrix[p] = b.shadow.matrix,
                        t.point[p] = E,
                        p++;
                    else if (b.isHemisphereLight) {
                        var E;
                        (E = e.get(b)).direction.setFromMatrixPosition(b.matrixWorld),
                        E.direction.transformDirection(v),
                        E.direction.normalize(),
                        E.skyColor.copy(b.color).multiplyScalar(w),
                        E.groundColor.copy(b.groundColor).multiplyScalar(w),
                        t.hemi[m] = E,
                        m++
                    }
                }
                t.ambient[0] = c,
                t.ambient[1] = l,
                t.ambient[2] = u,
                t.directional.length = h,
                t.spot.length = d,
                t.rectArea.length = f,
                t.point.length = p,
                t.hemi.length = m,
                t.hash.stateID = t.id,
                t.hash.directionalLength = h,
                t.hash.pointLength = p,
                t.hash.spotLength = d,
                t.hash.rectAreaLength = f,
                t.hash.hemiLength = m,
                t.hash.shadowsLength = a.length
            },
            state: t
        }
    }
    function Fn() {
        var e = new jn
          , t = []
          , r = [];
        return {
            init: function() {
                t.length = 0,
                r.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: r,
                lights: e
            },
            setupLights: function(n) {
                e.setup(t, r, n)
            },
            pushLight: function(e) {
                t.push(e)
            },
            pushShadow: function(e) {
                r.push(e)
            }
        }
    }
    function kn(e) {
        Er.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = wt,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Hn(e) {
        Er.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Pt,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Vn(e, t, r) {
        for (var n = new kt, i = new At, o = new Tt, a = new Tt(r,r), s = new Pt, c = new Pt, l = 1, h = 2, m = 1 + (l | h), v = new Array(m), g = new Array(m), b = {}, x = {
            0: d,
            1: p,
            2: f
        }, w = [new Pt(1,0,0), new Pt(-1,0,0), new Pt(0,0,1), new Pt(0,0,-1), new Pt(0,1,0), new Pt(0,-1,0)], _ = [new Pt(0,1,0), new Pt(0,1,0), new Pt(0,1,0), new Pt(0,1,0), new Pt(0,0,1), new Pt(0,0,-1)], M = [new Nt, new Nt, new Nt, new Nt, new Nt, new Nt], S = 0; S !== m; ++S) {
            var E = 0 != (S & l)
              , T = 0 != (S & h)
              , A = new kn({
                depthPacking: _t,
                morphTargets: E,
                skinning: T
            });
            v[S] = A;
            var L = new Hn({
                morphTargets: E,
                skinning: T
            });
            g[S] = L
        }
        var P = this;
        function C(t, r, n, i, o, a) {
            var s = t.geometry
              , c = null
              , u = v
              , p = t.customDepthMaterial;
            if (n && (u = g,
            p = t.customDistanceMaterial),
            p)
                c = p;
            else {
                var d = !1;
                r.morphTargets && (s && s.isBufferGeometry ? d = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (d = s.morphTargets && s.morphTargets.length > 0)),
                t.isSkinnedMesh && !1 === r.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
                var f = t.isSkinnedMesh && r.skinning
                  , m = 0;
                d && (m |= l),
                f && (m |= h),
                c = u[m]
            }
            if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
                var y = c.uuid
                  , w = r.uuid
                  , _ = b[y];
                void 0 === _ && (_ = {},
                b[y] = _);
                var M = _[w];
                void 0 === M && (M = c.clone(),
                _[w] = M),
                c = M
            }
            return c.visible = r.visible,
            c.wireframe = r.wireframe,
            c.side = null != r.shadowSide ? r.shadowSide : x[r.side],
            c.clipShadows = r.clipShadows,
            c.clippingPlanes = r.clippingPlanes,
            c.clipIntersection = r.clipIntersection,
            c.wireframeLinewidth = r.wireframeLinewidth,
            c.linewidth = r.linewidth,
            n && c.isMeshDistanceMaterial && (c.referencePosition.copy(i),
            c.nearDistance = o,
            c.farDistance = a),
            c
        }
        function R(r, i, o, a) {
            if (!1 !== r.visible) {
                if (r.layers.test(i.layers) && (r.isMesh || r.isLine || r.isPoints) && r.castShadow && (!r.frustumCulled || n.intersectsObject(r))) {
                    r.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, r.matrixWorld);
                    var s = t.update(r)
                      , l = r.material;
                    if (Array.isArray(l))
                        for (var u = s.groups, h = 0, p = u.length; h < p; h++) {
                            var d = u[h]
                              , f = l[d.materialIndex];
                            if (f && f.visible) {
                                var m = C(r, f, a, c, o.near, o.far);
                                e.renderBufferDirect(o, null, s, m, r, d)
                            }
                        }
                    else if (l.visible) {
                        m = C(r, l, a, c, o.near, o.far);
                        e.renderBufferDirect(o, null, s, m, r, null)
                    }
                }
                for (var v = r.children, g = 0, y = v.length; g < y; g++)
                    R(v[g], i, o, a)
            }
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = u,
        this.render = function(t, r, l) {
            if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== t.length) {
                var u, h = e.state;
                h.setBlending(y),
                h.buffers.color.setClear(1, 1, 1, 1),
                h.buffers.depth.setTest(!0),
                h.setScissorTest(!1);
                for (var p = 0, d = t.length; p < d; p++) {
                    var f = t[p]
                      , m = f.shadow
                      , v = f && f.isPointLight;
                    if (void 0 !== m) {
                        var g = m.camera;
                        if (o.copy(m.mapSize),
                        o.min(a),
                        v) {
                            var b = o.x
                              , x = o.y;
                            M[0].set(2 * b, x, b, x),
                            M[1].set(0, x, b, x),
                            M[2].set(3 * b, x, b, x),
                            M[3].set(b, x, b, x),
                            M[4].set(3 * b, 0, b, x),
                            M[5].set(b, 0, b, x),
                            o.x *= 4,
                            o.y *= 2
                        }
                        if (null === m.map) {
                            var S = {
                                minFilter: de,
                                magFilter: de,
                                format: Ie
                            };
                            m.map = new Dt(o.x,o.y,S),
                            m.map.texture.name = f.name + ".shadowMap",
                            g.updateProjectionMatrix()
                        }
                        m.isSpotLightShadow && m.update(f);
                        var E = m.map
                          , T = m.matrix;
                        c.setFromMatrixPosition(f.matrixWorld),
                        g.position.copy(c),
                        v ? (u = 6,
                        T.makeTranslation(-c.x, -c.y, -c.z)) : (u = 1,
                        s.setFromMatrixPosition(f.target.matrixWorld),
                        g.lookAt(s),
                        g.updateMatrixWorld(),
                        T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        T.multiply(g.projectionMatrix),
                        T.multiply(g.matrixWorldInverse)),
                        e.setRenderTarget(E),
                        e.clear();
                        for (var A = 0; A < u; A++) {
                            if (v) {
                                s.copy(g.position),
                                s.add(w[A]),
                                g.up.copy(_[A]),
                                g.lookAt(s),
                                g.updateMatrixWorld();
                                var L = M[A];
                                h.viewport(L)
                            }
                            i.multiplyMatrices(g.projectionMatrix, g.matrixWorldInverse),
                            n.setFromMatrix(i),
                            R(r, l, g, v)
                        }
                    } else
                        console.warn("THREE.WebGLShadowMap:", f, "has no shadow.")
                }
                P.needsUpdate = !1
            }
        }
    }
    function Wn(e, t, r, n, i, o, a) {
        var s, c = {};
        function l(e, t, r, n) {
            var i = 1;
            if ((e.width > n || e.height > n) && (i = n / Math.max(e.width, e.height)),
            i < 1 || !0 === t) {
                if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap) {
                    void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"));
                    var o = r ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : s
                      , a = t ? Et.floorPowerOfTwo : Math.floor;
                    return o.width = a(i * e.width),
                    o.height = a(i * e.height),
                    o.getContext("2d").drawImage(e, 0, 0, o.width, o.height),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o.width + "x" + o.height + ")."),
                    o
                }
                return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                e
            }
            return e
        }
        function u(e) {
            return Et.isPowerOfTwo(e.width) && Et.isPowerOfTwo(e.height)
        }
        function h(e, t) {
            return e.generateMipmaps && t && e.minFilter !== de && e.minFilter !== ve
        }
        function p(t, r, i, o) {
            e.generateMipmap(t),
            n.get(r).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E
        }
        function d(e, r) {
            if (!i.isWebGL2)
                return e;
            var n = e;
            return 6403 === e && (5126 === r && (n = 33326),
            5131 === r && (n = 33325),
            5121 === r && (n = 33321)),
            6407 === e && (5126 === r && (n = 34837),
            5131 === r && (n = 34843),
            5121 === r && (n = 32849)),
            6408 === e && (5126 === r && (n = 34836),
            5131 === r && (n = 34842),
            5121 === r && (n = 32856)),
            33325 === n || 33326 === n || 34842 === n || 34836 === n ? t.get("EXT_color_buffer_float") : 34843 !== n && 34837 !== n || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."),
            n
        }
        function f(e) {
            return e === de || e === fe || e === me ? 9728 : 9729
        }
        function m(t) {
            var r = t.target;
            r.removeEventListener("dispose", m),
            function(t) {
                var r = n.get(t);
                if (t.image && r.__image__webglTextureCube)
                    e.deleteTexture(r.__image__webglTextureCube);
                else {
                    if (void 0 === r.__webglInit)
                        return;
                    e.deleteTexture(r.__webglTexture)
                }
                n.remove(t)
            }(r),
            r.isVideoTexture && delete c[r.id],
            a.memory.textures--
        }
        function v(t) {
            var r = t.target;
            r.removeEventListener("dispose", v),
            function(t) {
                var r = n.get(t)
                  , i = n.get(t.texture);
                if (!t)
                    return;
                void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture);
                t.depthTexture && t.depthTexture.dispose();
                if (t.isWebGLRenderTargetCube)
                    for (var o = 0; o < 6; o++)
                        e.deleteFramebuffer(r.__webglFramebuffer[o]),
                        r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[o]);
                else
                    e.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer);
                n.remove(t.texture),
                n.remove(t)
            }(r),
            a.memory.textures--
        }
        function g(e, t) {
            var i = n.get(e);
            if (e.isVideoTexture && function(e) {
                var t = e.id
                  , r = a.render.frame;
                c[t] !== r && (c[t] = r,
                e.update())
            }(e),
            e.version > 0 && i.__version !== e.version) {
                var o = e.image;
                if (void 0 === o)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== o.complete)
                        return void b(i, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            r.activeTexture(33984 + t),
            r.bindTexture(3553, i.__webglTexture)
        }
        function y(r, a, s) {
            var c;
            if (s ? (e.texParameteri(r, 10242, o.convert(a.wrapS)),
            e.texParameteri(r, 10243, o.convert(a.wrapT)),
            e.texParameteri(r, 10240, o.convert(a.magFilter)),
            e.texParameteri(r, 10241, o.convert(a.minFilter))) : (e.texParameteri(r, 10242, 33071),
            e.texParameteri(r, 10243, 33071),
            a.wrapS === he && a.wrapT === he || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            e.texParameteri(r, 10240, f(a.magFilter)),
            e.texParameteri(r, 10241, f(a.minFilter)),
            a.minFilter !== de && a.minFilter !== ve && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            c = t.get("EXT_texture_filter_anisotropic")) {
                if (a.type === Ee && null === t.get("OES_texture_float_linear"))
                    return;
                if (a.type === Te && null === (i.isWebGL2 || t.get("OES_texture_half_float_linear")))
                    return;
                (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (e.texParameterf(r, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())),
                n.get(a).__currentAnisotropy = a.anisotropy)
            }
        }
        function b(t, n, s) {
            var c;
            c = n.isDataTexture3D ? 32879 : 3553,
            void 0 === t.__webglInit && (t.__webglInit = !0,
            n.addEventListener("dispose", m),
            t.__webglTexture = e.createTexture(),
            a.memory.textures++),
            r.activeTexture(33984 + s),
            r.bindTexture(c, t.__webglTexture),
            e.pixelStorei(37440, n.flipY),
            e.pixelStorei(37441, n.premultiplyAlpha),
            e.pixelStorei(3317, n.unpackAlignment);
            var f = function(e) {
                return !i.isWebGL2 && (e.wrapS !== he || e.wrapT !== he || e.minFilter !== de && e.minFilter !== ve)
            }(n) && !1 === u(n.image)
              , v = l(n.image, f, !1, i.maxTextureSize)
              , g = u(v) || i.isWebGL2
              , b = o.convert(n.format)
              , x = o.convert(n.type)
              , w = d(b, x);
            y(c, n, g);
            var _, M = n.mipmaps;
            if (n.isDepthTexture) {
                if (w = 6402,
                n.type === Ee) {
                    if (!i.isWebGL2)
                        throw new Error("Float Depth Texture only supported in WebGL2.0");
                    w = 36012
                } else
                    i.isWebGL2 && (w = 33189);
                n.format === ze && 6402 === w && n.type !== _e && n.type !== Se && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                n.type = _e,
                x = o.convert(n.type)),
                n.format === Ge && (w = 34041,
                n.type !== Ce && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                n.type = Ce,
                x = o.convert(n.type))),
                r.texImage2D(3553, 0, w, v.width, v.height, 0, b, x, null)
            } else if (n.isDataTexture)
                if (M.length > 0 && g) {
                    for (var S = 0, E = M.length; S < E; S++)
                        _ = M[S],
                        r.texImage2D(3553, S, w, _.width, _.height, 0, b, x, _.data);
                    n.generateMipmaps = !1,
                    t.__maxMipLevel = M.length - 1
                } else
                    r.texImage2D(3553, 0, w, v.width, v.height, 0, b, x, v.data),
                    t.__maxMipLevel = 0;
            else if (n.isCompressedTexture) {
                for (S = 0,
                E = M.length; S < E; S++)
                    _ = M[S],
                    n.format !== Ie && n.format !== Oe ? r.getCompressedTextureFormats().indexOf(b) > -1 ? r.compressedTexImage2D(3553, S, w, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(3553, S, w, _.width, _.height, 0, b, x, _.data);
                t.__maxMipLevel = M.length - 1
            } else if (n.isDataTexture3D)
                r.texImage3D(32879, 0, w, v.width, v.height, v.depth, 0, b, x, v.data),
                t.__maxMipLevel = 0;
            else if (M.length > 0 && g) {
                for (S = 0,
                E = M.length; S < E; S++)
                    _ = M[S],
                    r.texImage2D(3553, S, w, b, x, _);
                n.generateMipmaps = !1,
                t.__maxMipLevel = M.length - 1
            } else
                r.texImage2D(3553, 0, w, b, x, v),
                t.__maxMipLevel = 0;
            h(n, g) && p(3553, n, v.width, v.height),
            t.__version = n.version,
            n.onUpdate && n.onUpdate(n)
        }
        function x(t, i, a, s) {
            var c = o.convert(i.texture.format)
              , l = o.convert(i.texture.type)
              , u = d(c, l);
            r.texImage2D(s, 0, u, i.width, i.height, 0, c, l, null),
            e.bindFramebuffer(36160, t),
            e.framebufferTexture2D(36160, a, s, n.get(i.texture).__webglTexture, 0),
            e.bindFramebuffer(36160, null)
        }
        function w(t, r, n) {
            if (e.bindRenderbuffer(36161, t),
            r.depthBuffer && !r.stencilBuffer) {
                if (n) {
                    var i = M(r);
                    e.renderbufferStorageMultisample(36161, i, 33189, r.width, r.height)
                } else
                    e.renderbufferStorage(36161, 33189, r.width, r.height);
                e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (r.depthBuffer && r.stencilBuffer) {
                if (n) {
                    i = M(r);
                    e.renderbufferStorageMultisample(36161, i, 34041, r.width, r.height)
                } else
                    e.renderbufferStorage(36161, 34041, r.width, r.height);
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
                var a = d(o.convert(r.texture.format), o.convert(r.texture.type));
                if (n) {
                    i = M(r);
                    e.renderbufferStorageMultisample(36161, i, a, r.width, r.height)
                } else
                    e.renderbufferStorage(36161, a, r.width, r.height)
            }
            e.bindRenderbuffer(36161, null)
        }
        function _(t) {
            var r = n.get(t)
              , i = !0 === t.isWebGLRenderTargetCube;
            if (t.depthTexture) {
                if (i)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                !function(t, r) {
                    if (r && r.isWebGLRenderTargetCube)
                        throw new Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, t),
                    !r.depthTexture || !r.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    n.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                    r.depthTexture.image.height = r.height,
                    r.depthTexture.needsUpdate = !0),
                    g(r.depthTexture, 0);
                    var i = n.get(r.depthTexture).__webglTexture;
                    if (r.depthTexture.format === ze)
                        e.framebufferTexture2D(36160, 36096, 3553, i, 0);
                    else {
                        if (r.depthTexture.format !== Ge)
                            throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, i, 0)
                    }
                }(r.__webglFramebuffer, t)
            } else if (i) {
                r.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++)
                    e.bindFramebuffer(36160, r.__webglFramebuffer[o]),
                    r.__webglDepthbuffer[o] = e.createRenderbuffer(),
                    w(r.__webglDepthbuffer[o], t)
            } else
                e.bindFramebuffer(36160, r.__webglFramebuffer),
                r.__webglDepthbuffer = e.createRenderbuffer(),
                w(r.__webglDepthbuffer, t);
            e.bindFramebuffer(36160, null)
        }
        function M(e) {
            return i.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(i.maxSamples, e.samples) : 0
        }
        this.setTexture2D = g,
        this.setTexture3D = function(e, t) {
            var i = n.get(e);
            e.version > 0 && i.__version !== e.version ? b(i, e, t) : (r.activeTexture(33984 + t),
            r.bindTexture(32879, i.__webglTexture))
        }
        ,
        this.setTextureCube = function(t, s) {
            var c = n.get(t);
            if (6 === t.image.length)
                if (t.version > 0 && c.__version !== t.version) {
                    c.__image__webglTextureCube || (t.addEventListener("dispose", m),
                    c.__image__webglTextureCube = e.createTexture(),
                    a.memory.textures++),
                    r.activeTexture(33984 + s),
                    r.bindTexture(34067, c.__image__webglTextureCube),
                    e.pixelStorei(37440, t.flipY);
                    for (var f = t && t.isCompressedTexture, v = t.image[0] && t.image[0].isDataTexture, g = [], b = 0; b < 6; b++)
                        g[b] = f || v ? v ? t.image[b].image : t.image[b] : l(t.image[b], !1, !0, i.maxCubemapSize);
                    var x = g[0]
                      , w = u(x) || i.isWebGL2
                      , _ = o.convert(t.format)
                      , M = o.convert(t.type)
                      , S = d(_, M);
                    for (y(34067, t, w),
                    b = 0; b < 6; b++)
                        if (f)
                            for (var E, T = g[b].mipmaps, A = 0, L = T.length; A < L; A++)
                                E = T[A],
                                t.format !== Ie && t.format !== Oe ? r.getCompressedTextureFormats().indexOf(_) > -1 ? r.compressedTexImage2D(34069 + b, A, S, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(34069 + b, A, S, E.width, E.height, 0, _, M, E.data);
                        else
                            v ? r.texImage2D(34069 + b, 0, S, g[b].width, g[b].height, 0, _, M, g[b].data) : r.texImage2D(34069 + b, 0, S, _, M, g[b]);
                    c.__maxMipLevel = f ? T.length - 1 : 0,
                    h(t, w) && p(34067, t, x.width, x.height),
                    c.__version = t.version,
                    t.onUpdate && t.onUpdate(t)
                } else
                    r.activeTexture(33984 + s),
                    r.bindTexture(34067, c.__image__webglTextureCube)
        }
        ,
        this.setTextureCubeDynamic = function(e, t) {
            r.activeTexture(33984 + t),
            r.bindTexture(34067, n.get(e).__webglTexture)
        }
        ,
        this.setupRenderTarget = function(t) {
            var s = n.get(t)
              , c = n.get(t.texture);
            t.addEventListener("dispose", v),
            c.__webglTexture = e.createTexture(),
            a.memory.textures++;
            var l = !0 === t.isWebGLRenderTargetCube
              , f = !0 === t.isWebGLMultisampleRenderTarget
              , m = u(t) || i.isWebGL2;
            if (l) {
                s.__webglFramebuffer = [];
                for (var g = 0; g < 6; g++)
                    s.__webglFramebuffer[g] = e.createFramebuffer()
            } else if (s.__webglFramebuffer = e.createFramebuffer(),
            f)
                if (i.isWebGL2) {
                    s.__webglMultisampledFramebuffer = e.createFramebuffer(),
                    s.__webglColorRenderbuffer = e.createRenderbuffer(),
                    e.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
                    var b = d(o.convert(t.texture.format), o.convert(t.texture.type))
                      , S = M(t);
                    e.renderbufferStorageMultisample(36161, S, b, t.width, t.height),
                    e.bindFramebuffer(36160, s.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer),
                    e.bindRenderbuffer(36161, null),
                    t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(),
                    w(s.__webglDepthRenderbuffer, t, !0)),
                    e.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (l) {
                for (r.bindTexture(34067, c.__webglTexture),
                y(34067, t.texture, m),
                g = 0; g < 6; g++)
                    x(s.__webglFramebuffer[g], t, 36064, 34069 + g);
                h(t.texture, m) && p(34067, t.texture, t.width, t.height),
                r.bindTexture(34067, null)
            } else
                r.bindTexture(3553, c.__webglTexture),
                y(3553, t.texture, m),
                x(s.__webglFramebuffer, t, 36064, 3553),
                h(t.texture, m) && p(3553, t.texture, t.width, t.height),
                r.bindTexture(3553, null);
            t.depthBuffer && _(t)
        }
        ,
        this.updateRenderTargetMipmap = function(e) {
            var t = e.texture;
            if (h(t, u(e) || i.isWebGL2)) {
                var o = e.isWebGLRenderTargetCube ? 34067 : 3553
                  , a = n.get(t).__webglTexture;
                r.bindTexture(o, a),
                p(o, t, e.width, e.height),
                r.bindTexture(o, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (i.isWebGL2) {
                    var r = n.get(t);
                    e.bindFramebuffer(36008, r.__webglMultisampledFramebuffer),
                    e.bindFramebuffer(36009, r.__webglFramebuffer);
                    var o = t.width
                      , a = t.height
                      , s = 16384;
                    t.depthBuffer && (s |= 256),
                    t.stencilBuffer && (s |= 1024),
                    e.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, 9728)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
    }
    function qn(e, t, r) {
        return {
            convert: function(e) {
                var n;
                if (e === ue)
                    return 10497;
                if (e === he)
                    return 33071;
                if (e === pe)
                    return 33648;
                if (e === de)
                    return 9728;
                if (e === fe)
                    return 9984;
                if (e === me)
                    return 9986;
                if (e === ve)
                    return 9729;
                if (e === ge)
                    return 9985;
                if (e === ye)
                    return 9987;
                if (e === be)
                    return 5121;
                if (e === Ae)
                    return 32819;
                if (e === Le)
                    return 32820;
                if (e === Pe)
                    return 33635;
                if (e === xe)
                    return 5120;
                if (e === we)
                    return 5122;
                if (e === _e)
                    return 5123;
                if (e === Me)
                    return 5124;
                if (e === Se)
                    return 5125;
                if (e === Ee)
                    return 5126;
                if (e === Te) {
                    if (r.isWebGL2)
                        return 5131;
                    if (null !== (n = t.get("OES_texture_half_float")))
                        return n.HALF_FLOAT_OES
                }
                if (e === Re)
                    return 6406;
                if (e === Oe)
                    return 6407;
                if (e === Ie)
                    return 6408;
                if (e === Ne)
                    return 6409;
                if (e === De)
                    return 6410;
                if (e === ze)
                    return 6402;
                if (e === Ge)
                    return 34041;
                if (e === Ue)
                    return 6403;
                if (e === S)
                    return 32774;
                if (e === E)
                    return 32778;
                if (e === T)
                    return 32779;
                if (e === P)
                    return 0;
                if (e === C)
                    return 1;
                if (e === R)
                    return 768;
                if (e === O)
                    return 769;
                if (e === I)
                    return 770;
                if (e === N)
                    return 771;
                if (e === D)
                    return 772;
                if (e === B)
                    return 773;
                if (e === z)
                    return 774;
                if (e === G)
                    return 775;
                if (e === U)
                    return 776;
                if ((e === je || e === Fe || e === ke || e === He) && null !== (n = t.get("WEBGL_compressed_texture_s3tc"))) {
                    if (e === je)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === Fe)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === ke)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === He)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((e === Ve || e === We || e === qe || e === Xe) && null !== (n = t.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (e === Ve)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === We)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === qe)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === Xe)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e === Ye && null !== (n = t.get("WEBGL_compressed_texture_etc1")))
                    return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((e === Je || e === Ze || e === Ke || e === Qe || e === $e || e === et || e === tt || e === rt || e === nt || e === it || e === ot || e === at || e === st || e === ct) && null !== (n = t.get("WEBGL_compressed_texture_astc")))
                    return e;
                if (e === A || e === L) {
                    if (r.isWebGL2) {
                        if (e === A)
                            return 32775;
                        if (e === L)
                            return 32776
                    }
                    if (null !== (n = t.get("EXT_blend_minmax"))) {
                        if (e === A)
                            return n.MIN_EXT;
                        if (e === L)
                            return n.MAX_EXT
                    }
                }
                if (e === Ce) {
                    if (r.isWebGL2)
                        return 34042;
                    if (null !== (n = t.get("WEBGL_depth_texture")))
                        return n.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }
    function Xn() {
        nr.call(this),
        this.type = "Group"
    }
    function Yn() {
        nr.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new At,
        this.projectionMatrix = new At,
        this.projectionMatrixInverse = new At
    }
    function Jn(e, t, r, n) {
        Yn.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== e ? e : 50,
        this.zoom = 1,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== n ? n : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== t ? t : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function Zn(e) {
        Jn.call(this),
        this.cameras = e || []
    }
    kn.prototype = Object.create(Er.prototype),
    kn.prototype.constructor = kn,
    kn.prototype.isMeshDepthMaterial = !0,
    kn.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.depthPacking = e.depthPacking,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
    ,
    Hn.prototype = Object.create(Er.prototype),
    Hn.prototype.constructor = Hn,
    Hn.prototype.isMeshDistanceMaterial = !0,
    Hn.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
    ,
    Xn.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: Xn,
        isGroup: !0
    }),
    Yn.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: Yn,
        isCamera: !0,
        copy: function(e, t) {
            return nr.prototype.copy.call(this, e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            e = new Pt),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            nr.prototype.updateMatrixWorld.call(this, e),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Jn.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Jn,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return Yn.prototype.copy.call(this, e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        },
        setFocalLength: function(e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * Et.RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * Et.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * Et.RAD2DEG * Math.atan(Math.tan(.5 * Et.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, r, n, i, o) {
            this.aspect = e / t,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = r,
            this.view.offsetY = n,
            this.view.width = i,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near
              , t = e * Math.tan(.5 * Et.DEG2RAD * this.fov) / this.zoom
              , r = 2 * t
              , n = this.aspect * r
              , i = -.5 * n
              , o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth
                  , s = o.fullHeight;
                i += o.offsetX * n / a,
                t -= o.offsetY * r / s,
                n *= o.width / a,
                r *= o.height / s
            }
            var c = this.filmOffset;
            0 !== c && (i += e * c / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(i, i + n, t, t - r, e, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = nr.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    }),
    Zn.prototype = Object.assign(Object.create(Jn.prototype), {
        constructor: Zn,
        isArrayCamera: !0
    });
    var Kn, Qn = new Pt, $n = new Pt;
    function ei(e, t, r) {
        Qn.setFromMatrixPosition(t.matrixWorld),
        $n.setFromMatrixPosition(r.matrixWorld);
        var n = Qn.distanceTo($n)
          , i = t.projectionMatrix.elements
          , o = r.projectionMatrix.elements
          , a = i[14] / (i[10] - 1)
          , s = i[14] / (i[10] + 1)
          , c = (i[9] + 1) / i[5]
          , l = (i[9] - 1) / i[5]
          , u = (i[8] - 1) / i[0]
          , h = (o[8] + 1) / o[0]
          , p = a * u
          , d = a * h
          , f = n / (-u + h)
          , m = f * -u;
        t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
        e.translateX(m),
        e.translateZ(f),
        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
        e.matrixWorldInverse.getInverse(e.matrixWorld);
        var v = a + f
          , g = s + f
          , y = p - m
          , b = d + (n - m)
          , x = c * s / g * v
          , w = l * s / g * v;
        e.projectionMatrix.makePerspective(y, b, x, w, v, g)
    }
    function ti(e) {
        var t = this
          , r = null
          , n = null
          , i = null
          , o = []
          , a = new At
          , s = new At
          , c = 1
          , l = "stage";
        "undefined" != typeof window && "VRFrameData"in window && (n = new window.VRFrameData,
        window.addEventListener("vrdisplaypresentchange", b, !1));
        var u = new At
          , h = new Lt
          , p = new Pt
          , d = new Jn;
        d.bounds = new Nt(0,0,.5,1),
        d.layers.enable(1);
        var f = new Jn;
        f.bounds = new Nt(.5,0,.5,1),
        f.layers.enable(2);
        var m, v, g = new Zn([d, f]);
        function y() {
            return null !== r && !0 === r.isPresenting
        }
        function b() {
            if (y()) {
                var n = r.getEyeParameters("left")
                  , i = n.renderWidth * c
                  , o = n.renderHeight * c;
                v = e.getPixelRatio(),
                m = e.getSize(),
                e.setDrawingBufferSize(2 * i, o, 1),
                _.start()
            } else
                t.enabled && e.setDrawingBufferSize(m.width, m.height, v),
                _.stop()
        }
        g.layers.enable(1),
        g.layers.enable(2);
        var x = [];
        function w(e) {
            for (var t = navigator.getGamepads && navigator.getGamepads(), r = 0, n = 0, i = t.length; r < i; r++) {
                var o = t[r];
                if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("Spatial Controller"))) {
                    if (n === e)
                        return o;
                    n++
                }
            }
        }
        this.enabled = !1,
        this.getController = function(e) {
            var t = o[e];
            return void 0 === t && ((t = new Xn).matrixAutoUpdate = !1,
            t.visible = !1,
            o[e] = t),
            t
        }
        ,
        this.getDevice = function() {
            return r
        }
        ,
        this.setDevice = function(e) {
            void 0 !== e && (r = e),
            _.setContext(e)
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            c = e
        }
        ,
        this.setFrameOfReferenceType = function(e) {
            l = e
        }
        ,
        this.setPoseTarget = function(e) {
            void 0 !== e && (i = e)
        }
        ,
        this.getCamera = function(e) {
            var t = "stage" === l ? 1.6 : 0;
            if (null === r)
                return e.position.set(0, t, 0),
                e;
            if (r.depthNear = e.near,
            r.depthFar = e.far,
            r.getFrameData(n),
            "stage" === l) {
                var c = r.stageParameters;
                c ? a.fromArray(c.sittingToStandingTransform) : a.makeTranslation(0, t, 0)
            }
            var m = n.pose
              , v = null !== i ? i : e;
            if (v.matrix.copy(a),
            v.matrix.decompose(v.position, v.quaternion, v.scale),
            null !== m.orientation && (h.fromArray(m.orientation),
            v.quaternion.multiply(h)),
            null !== m.position && (h.setFromRotationMatrix(a),
            p.fromArray(m.position),
            p.applyQuaternion(h),
            v.position.add(p)),
            v.updateMatrixWorld(),
            !1 === r.isPresenting)
                return e;
            d.near = e.near,
            f.near = e.near,
            d.far = e.far,
            f.far = e.far,
            d.matrixWorldInverse.fromArray(n.leftViewMatrix),
            f.matrixWorldInverse.fromArray(n.rightViewMatrix),
            s.getInverse(a),
            "stage" === l && (d.matrixWorldInverse.multiply(s),
            f.matrixWorldInverse.multiply(s));
            var y = v.parent;
            null !== y && (u.getInverse(y.matrixWorld),
            d.matrixWorldInverse.multiply(u),
            f.matrixWorldInverse.multiply(u)),
            d.matrixWorld.getInverse(d.matrixWorldInverse),
            f.matrixWorld.getInverse(f.matrixWorldInverse),
            d.projectionMatrix.fromArray(n.leftProjectionMatrix),
            f.projectionMatrix.fromArray(n.rightProjectionMatrix),
            ei(g, d, f);
            var b = r.getLayers();
            if (b.length) {
                var _ = b[0];
                null !== _.leftBounds && 4 === _.leftBounds.length && d.bounds.fromArray(_.leftBounds),
                null !== _.rightBounds && 4 === _.rightBounds.length && f.bounds.fromArray(_.rightBounds)
            }
            return function() {
                for (var e = 0; e < o.length; e++) {
                    var t = o[e]
                      , r = w(e);
                    if (void 0 !== r && void 0 !== r.pose) {
                        if (null === r.pose)
                            return;
                        var n = r.pose;
                        !1 === n.hasPosition && t.position.set(.2, -.6, -.05),
                        null !== n.position && t.position.fromArray(n.position),
                        null !== n.orientation && t.quaternion.fromArray(n.orientation),
                        t.matrix.compose(t.position, t.quaternion, t.scale),
                        t.matrix.premultiply(a),
                        t.matrix.decompose(t.position, t.quaternion, t.scale),
                        t.matrixWorldNeedsUpdate = !0,
                        t.visible = !0;
                        var i = "Daydream Controller" === r.id ? 0 : 1;
                        x[e] !== r.buttons[i].pressed && (x[e] = r.buttons[i].pressed,
                        !0 === x[e] ? t.dispatchEvent({
                            type: "selectstart"
                        }) : (t.dispatchEvent({
                            type: "selectend"
                        }),
                        t.dispatchEvent({
                            type: "select"
                        })))
                    } else
                        t.visible = !1
                }
            }(),
            g
        }
        ,
        this.getStandingMatrix = function() {
            return a
        }
        ,
        this.isPresenting = y;
        var _ = new Kt;
        this.setAnimationLoop = function(e) {
            _.setAnimationLoop(e)
        }
        ,
        this.submitFrame = function() {
            y() && r.submitFrame()
        }
        ,
        this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", b)
        }
    }
    function ri(e) {
        console.log("THREE.WebGLRenderer", a);
        var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , r = void 0 !== e.context ? e.context : null
          , n = void 0 !== e.alpha && e.alpha
          , i = void 0 === e.depth || e.depth
          , o = void 0 === e.stencil || e.stencil
          , u = void 0 !== e.antialias && e.antialias
          , h = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
          , m = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
          , v = void 0 !== e.powerPreference ? e.powerPreference : "default"
          , g = null
          , E = null;
        this.domElement = t,
        this.context = null,
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.gammaInput = !1,
        this.gammaOutput = !1,
        this.physicallyCorrectLights = !1,
        this.toneMapping = Q,
        this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var T, A, L, P, C, R, O, I, N, D, B, z, G, U, Y, J, Z, K, $ = this, ee = !1, te = null, re = null, ne = null, ie = -1, oe = {
            geometry: null,
            program: null,
            wireframe: !1
        }, ae = null, se = null, ce = new Nt, le = new Nt, ue = null, he = 0, pe = t.width, de = t.height, fe = 1, me = new Nt(0,0,pe,de), ve = new Nt(0,0,pe,de), ge = !1, ye = new kt, xe = new function() {
            var e = this
              , t = null
              , r = 0
              , n = !1
              , i = !1
              , o = new Ft
              , a = new Ct
              , s = {
                value: null,
                needsUpdate: !1
            };
            function c() {
                s.value !== t && (s.value = t,
                s.needsUpdate = r > 0),
                e.numPlanes = r,
                e.numIntersection = 0
            }
            function l(t, r, n, i) {
                var c = null !== t ? t.length : 0
                  , l = null;
                if (0 !== c) {
                    if (l = s.value,
                    !0 !== i || null === l) {
                        var u = n + 4 * c
                          , h = r.matrixWorldInverse;
                        a.getNormalMatrix(h),
                        (null === l || l.length < u) && (l = new Float32Array(u));
                        for (var p = 0, d = n; p !== c; ++p,
                        d += 4)
                            o.copy(t[p]).applyMatrix4(h, a),
                            o.normal.toArray(l, d),
                            l[d + 3] = o.constant
                    }
                    s.value = l,
                    s.needsUpdate = !0
                }
                return e.numPlanes = c,
                l
            }
            this.uniform = s,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(e, i, o) {
                var a = 0 !== e.length || i || 0 !== r || n;
                return n = i,
                t = l(e, o, 0),
                r = e.length,
                a
            }
            ,
            this.beginShadows = function() {
                i = !0,
                l(null)
            }
            ,
            this.endShadows = function() {
                i = !1,
                c()
            }
            ,
            this.setState = function(e, o, a, u, h, p) {
                if (!n || null === e || 0 === e.length || i && !a)
                    i ? l(null) : c();
                else {
                    var d = i ? 0 : r
                      , f = 4 * d
                      , m = h.clippingState || null;
                    s.value = m,
                    m = l(e, u, f, p);
                    for (var v = 0; v !== f; ++v)
                        m[v] = t[v];
                    h.clippingState = m,
                    this.numIntersection = o ? this.numPlanes : 0,
                    this.numPlanes += d
                }
            }
        }
        , we = !1, _e = !1, Me = new At, Se = new Pt;
        function Ae() {
            return null === re ? fe : 1
        }
        try {
            var Le = {
                alpha: n,
                depth: i,
                stencil: o,
                antialias: u,
                premultipliedAlpha: h,
                preserveDrawingBuffer: m,
                powerPreference: v
            };
            if (t.addEventListener("webglcontextlost", Oe, !1),
            t.addEventListener("webglcontextrestored", Ne, !1),
            null === (T = r || t.getContext("webgl", Le) || t.getContext("experimental-webgl", Le)))
                throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === T.getShaderPrecisionFormat && (T.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (e) {
            console.error("THREE.WebGLRenderer: " + e.message)
        }
        function Pe() {
            A = new function(e) {
                var t = {};
                return {
                    get: function(r) {
                        if (void 0 !== t[r])
                            return t[r];
                        var n;
                        switch (r) {
                        case "WEBGL_depth_texture":
                            n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = e.getExtension(r)
                        }
                        return null === n && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."),
                        t[r] = n,
                        n
                    }
                }
            }
            (T),
            (L = new function(e, t, r) {
                var n;
                function i(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                            return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                var o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext
                  , a = void 0 !== r.precision ? r.precision : "highp"
                  , s = i(a);
                s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."),
                a = s);
                var c = !0 === r.logarithmicDepthBuffer
                  , l = e.getParameter(34930)
                  , u = e.getParameter(35660)
                  , h = e.getParameter(3379)
                  , p = e.getParameter(34076)
                  , d = e.getParameter(34921)
                  , f = e.getParameter(36347)
                  , m = e.getParameter(36348)
                  , v = e.getParameter(36349)
                  , g = u > 0
                  , y = o || !!t.get("OES_texture_float");
                return {
                    isWebGL2: o,
                    getMaxAnisotropy: function() {
                        if (void 0 !== n)
                            return n;
                        var r = t.get("EXT_texture_filter_anisotropic");
                        return n = null !== r ? e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: i,
                    precision: a,
                    logarithmicDepthBuffer: c,
                    maxTextures: l,
                    maxVertexTextures: u,
                    maxTextureSize: h,
                    maxCubemapSize: p,
                    maxAttributes: d,
                    maxVertexUniforms: f,
                    maxVaryings: m,
                    maxFragmentUniforms: v,
                    vertexTextures: g,
                    floatFragmentTextures: y,
                    floatVertexTextures: g && y,
                    maxSamples: o ? e.getParameter(36183) : 0
                }
            }
            (T,A,e)).isWebGL2 || (A.get("WEBGL_depth_texture"),
            A.get("OES_texture_float"),
            A.get("OES_texture_half_float"),
            A.get("OES_texture_half_float_linear"),
            A.get("OES_standard_derivatives"),
            A.get("OES_element_index_uint"),
            A.get("ANGLE_instanced_arrays")),
            A.get("OES_texture_float_linear"),
            K = new qn(T,A,L),
            (P = new function(e, t, r, n) {
                var i = new function() {
                    var t = !1
                      , r = new Nt
                      , n = null
                      , i = new Nt(0,0,0,0);
                    return {
                        setMask: function(r) {
                            n === r || t || (e.colorMask(r, r, r, r),
                            n = r)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t, n, o, a, s) {
                            !0 === s && (t *= a,
                            n *= a,
                            o *= a),
                            r.set(t, n, o, a),
                            !1 === i.equals(r) && (e.clearColor(t, n, o, a),
                            i.copy(r))
                        },
                        reset: function() {
                            t = !1,
                            n = null,
                            i.set(-1, 0, 0, 0)
                        }
                    }
                }
                  , o = new function() {
                    var t = !1
                      , r = null
                      , n = null
                      , i = null;
                    return {
                        setTest: function(e) {
                            e ? oe(2929) : ae(2929)
                        },
                        setMask: function(n) {
                            r === n || t || (e.depthMask(n),
                            r = n)
                        },
                        setFunc: function(t) {
                            if (n !== t) {
                                if (t)
                                    switch (t) {
                                    case j:
                                        e.depthFunc(512);
                                        break;
                                    case F:
                                        e.depthFunc(519);
                                        break;
                                    case k:
                                        e.depthFunc(513);
                                        break;
                                    case H:
                                        e.depthFunc(515);
                                        break;
                                    case V:
                                        e.depthFunc(514);
                                        break;
                                    case W:
                                        e.depthFunc(518);
                                        break;
                                    case q:
                                        e.depthFunc(516);
                                        break;
                                    case X:
                                        e.depthFunc(517);
                                        break;
                                    default:
                                        e.depthFunc(515)
                                    }
                                else
                                    e.depthFunc(515);
                                n = t
                            }
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            i !== t && (e.clearDepth(t),
                            i = t)
                        },
                        reset: function() {
                            t = !1,
                            r = null,
                            n = null,
                            i = null
                        }
                    }
                }
                  , a = new function() {
                    var t = !1
                      , r = null
                      , n = null
                      , i = null
                      , o = null
                      , a = null
                      , s = null
                      , c = null
                      , l = null;
                    return {
                        setTest: function(e) {
                            e ? oe(2960) : ae(2960)
                        },
                        setMask: function(n) {
                            r === n || t || (e.stencilMask(n),
                            r = n)
                        },
                        setFunc: function(t, r, a) {
                            n === t && i === r && o === a || (e.stencilFunc(t, r, a),
                            n = t,
                            i = r,
                            o = a)
                        },
                        setOp: function(t, r, n) {
                            a === t && s === r && c === n || (e.stencilOp(t, r, n),
                            a = t,
                            s = r,
                            c = n)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            l !== t && (e.clearStencil(t),
                            l = t)
                        },
                        reset: function() {
                            t = !1,
                            r = null,
                            n = null,
                            i = null,
                            o = null,
                            a = null,
                            s = null,
                            c = null,
                            l = null
                        }
                    }
                }
                  , u = e.getParameter(34921)
                  , h = new Uint8Array(u)
                  , p = new Uint8Array(u)
                  , m = new Uint8Array(u)
                  , v = {}
                  , g = null
                  , E = null
                  , T = null
                  , A = null
                  , L = null
                  , P = null
                  , C = null
                  , R = null
                  , O = null
                  , I = null
                  , N = !1
                  , D = null
                  , B = null
                  , z = null
                  , G = null
                  , U = null
                  , Y = e.getParameter(35661)
                  , J = !1
                  , Z = 0
                  , K = e.getParameter(7938);
                -1 !== K.indexOf("WebGL") ? (Z = parseFloat(/^WebGL\ ([0-9])/.exec(K)[1]),
                J = Z >= 1) : -1 !== K.indexOf("OpenGL ES") && (Z = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(K)[1]),
                J = Z >= 2);
                var Q = null
                  , $ = {}
                  , ee = new Nt
                  , te = new Nt;
                function re(t, r, n) {
                    var i = new Uint8Array(4)
                      , o = e.createTexture();
                    e.bindTexture(t, o),
                    e.texParameteri(t, 10241, 9728),
                    e.texParameteri(t, 10240, 9728);
                    for (var a = 0; a < n; a++)
                        e.texImage2D(r + a, 0, 6408, 1, 1, 0, 6408, 5121, i);
                    return o
                }
                var ne = {};
                function ie(r, i) {
                    h[r] = 1,
                    0 === p[r] && (e.enableVertexAttribArray(r),
                    p[r] = 1),
                    m[r] !== i && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, i),
                    m[r] = i)
                }
                function oe(t) {
                    !0 !== v[t] && (e.enable(t),
                    v[t] = !0)
                }
                function ae(t) {
                    !1 !== v[t] && (e.disable(t),
                    v[t] = !1)
                }
                function se(t, n, i, o, a, s, c, l) {
                    if (t !== y) {
                        if (T || (oe(3042),
                        T = !0),
                        t === M)
                            a = a || n,
                            s = s || i,
                            c = c || o,
                            n === L && a === R || (e.blendEquationSeparate(r.convert(n), r.convert(a)),
                            L = n,
                            R = a),
                            i === P && o === C && s === O && c === I || (e.blendFuncSeparate(r.convert(i), r.convert(o), r.convert(s), r.convert(c)),
                            P = i,
                            C = o,
                            O = s,
                            I = c),
                            A = t,
                            N = null;
                        else if (t !== A || l !== N) {
                            if (L === S && R === S || (e.blendEquation(32774),
                            L = S,
                            R = S),
                            l)
                                switch (t) {
                                case b:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case x:
                                    e.blendFunc(1, 1);
                                    break;
                                case w:
                                    e.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case _:
                                    e.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                                }
                            else
                                switch (t) {
                                case b:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case x:
                                    e.blendFunc(770, 1);
                                    break;
                                case w:
                                    e.blendFunc(0, 769);
                                    break;
                                case _:
                                    e.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                                }
                            P = null,
                            C = null,
                            O = null,
                            I = null,
                            A = t,
                            N = l
                        }
                    } else
                        T && (ae(3042),
                        T = !1)
                }
                function ce(t) {
                    D !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
                    D = t)
                }
                function le(t) {
                    t !== s ? (oe(2884),
                    t !== B && (t === c ? e.cullFace(1029) : t === l ? e.cullFace(1028) : e.cullFace(1032))) : ae(2884),
                    B = t
                }
                function ue(t, r, n) {
                    t ? (oe(32823),
                    G === r && U === n || (e.polygonOffset(r, n),
                    G = r,
                    U = n)) : ae(32823)
                }
                function he(t) {
                    void 0 === t && (t = 33984 + Y - 1),
                    Q !== t && (e.activeTexture(t),
                    Q = t)
                }
                return ne[3553] = re(3553, 3553, 1),
                ne[34067] = re(34067, 34069, 6),
                i.setClear(0, 0, 0, 1),
                o.setClear(1),
                a.setClear(0),
                oe(2929),
                o.setFunc(H),
                ce(!1),
                le(c),
                oe(2884),
                se(y),
                {
                    buffers: {
                        color: i,
                        depth: o,
                        stencil: a
                    },
                    initAttributes: function() {
                        for (var e = 0, t = h.length; e < t; e++)
                            h[e] = 0
                    },
                    enableAttribute: function(e) {
                        ie(e, 0)
                    },
                    enableAttributeAndDivisor: ie,
                    disableUnusedAttributes: function() {
                        for (var t = 0, r = p.length; t !== r; ++t)
                            p[t] !== h[t] && (e.disableVertexAttribArray(t),
                            p[t] = 0)
                    },
                    enable: oe,
                    disable: ae,
                    getCompressedTextureFormats: function() {
                        if (null === g && (g = [],
                        t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                            for (var r = e.getParameter(34467), n = 0; n < r.length; n++)
                                g.push(r[n]);
                        return g
                    },
                    useProgram: function(t) {
                        return E !== t && (e.useProgram(t),
                        E = t,
                        !0)
                    },
                    setBlending: se,
                    setMaterial: function(e, t) {
                        e.side === f ? ae(2884) : oe(2884);
                        var r = e.side === d;
                        t && (r = !r),
                        ce(r),
                        e.blending === b && !1 === e.transparent ? se(y) : se(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                        o.setFunc(e.depthFunc),
                        o.setTest(e.depthTest),
                        o.setMask(e.depthWrite),
                        i.setMask(e.colorWrite),
                        ue(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                    },
                    setFlipSided: ce,
                    setCullFace: le,
                    setLineWidth: function(t) {
                        t !== z && (J && e.lineWidth(t),
                        z = t)
                    },
                    setPolygonOffset: ue,
                    setScissorTest: function(e) {
                        e ? oe(3089) : ae(3089)
                    },
                    activeTexture: he,
                    bindTexture: function(t, r) {
                        null === Q && he();
                        var n = $[Q];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        },
                        $[Q] = n),
                        n.type === t && n.texture === r || (e.bindTexture(t, r || ne[t]),
                        n.type = t,
                        n.texture = r)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(t) {
                        !1 === ee.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                        ee.copy(t))
                    },
                    viewport: function(t) {
                        !1 === te.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                        te.copy(t))
                    },
                    reset: function() {
                        for (var t = 0; t < p.length; t++)
                            1 === p[t] && (e.disableVertexAttribArray(t),
                            p[t] = 0);
                        v = {},
                        g = null,
                        Q = null,
                        $ = {},
                        E = null,
                        A = null,
                        D = null,
                        B = null,
                        i.reset(),
                        o.reset(),
                        a.reset()
                    }
                }
            }
            (T,A,K,L)).scissor(le.copy(ve).multiplyScalar(fe)),
            P.viewport(ce.copy(me).multiplyScalar(fe)),
            C = new function(e) {
                var t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.frame++,
                        t.calls = 0,
                        t.triangles = 0,
                        t.points = 0,
                        t.lines = 0
                    },
                    update: function(e, r, n) {
                        switch (n = n || 1,
                        t.calls++,
                        r) {
                        case 4:
                            t.triangles += n * (e / 3);
                            break;
                        case 5:
                        case 6:
                            t.triangles += n * (e - 2);
                            break;
                        case 1:
                            t.lines += n * (e / 2);
                            break;
                        case 3:
                            t.lines += n * (e - 1);
                            break;
                        case 2:
                            t.lines += n * e;
                            break;
                        case 0:
                            t.points += n * e;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }
            (T),
            R = new function() {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        var r = e.get(t);
                        return void 0 === r && (r = {},
                        e.set(t, r)),
                        r
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, r, n) {
                        e.get(t)[r] = n
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }
            ,
            O = new Wn(T,A,P,R,L,K,C),
            I = new Qt(T),
            N = new function(e, t, r) {
                var n = {}
                  , i = {};
                function o(e) {
                    var a = e.target
                      , s = n[a.id];
                    for (var c in null !== s.index && t.remove(s.index),
                    s.attributes)
                        t.remove(s.attributes[c]);
                    a.removeEventListener("dispose", o),
                    delete n[a.id];
                    var l = i[s.id];
                    l && (t.remove(l),
                    delete i[s.id]),
                    r.memory.geometries--
                }
                return {
                    get: function(e, t) {
                        var i = n[t.id];
                        return i || (t.addEventListener("dispose", o),
                        t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new br).setFromObject(e)),
                        i = t._bufferGeometry),
                        n[t.id] = i,
                        r.memory.geometries++,
                        i)
                    },
                    update: function(e) {
                        var r = e.index
                          , n = e.attributes;
                        for (var i in null !== r && t.update(r, 34963),
                        n)
                            t.update(n[i], 34962);
                        var o = e.morphAttributes;
                        for (var i in o)
                            for (var a = o[i], s = 0, c = a.length; s < c; s++)
                                t.update(a[s], 34962)
                    },
                    getWireframeAttribute: function(e) {
                        var r = i[e.id];
                        if (r)
                            return r;
                        var n, o = [], a = e.index, s = e.attributes;
                        if (null !== a)
                            for (var c = 0, l = (n = a.array).length; c < l; c += 3) {
                                var u = n[c + 0]
                                  , h = n[c + 1]
                                  , p = n[c + 2];
                                o.push(u, h, h, p, p, u)
                            }
                        else
                            for (c = 0,
                            l = (n = s.position.array).length / 3 - 1; c < l; c += 3)
                                u = c + 0,
                                h = c + 1,
                                p = c + 2,
                                o.push(u, h, h, p, p, u);
                        return r = new (gr(o) > 65535 ? dr : hr)(o,1),
                        t.update(r, 34963),
                        i[e.id] = r,
                        r
                    }
                }
            }
            (T,I,C),
            D = new function(e, t) {
                var r = {};
                return {
                    update: function(n) {
                        var i = t.render.frame
                          , o = n.geometry
                          , a = e.get(n, o);
                        return r[a.id] !== i && (o.isGeometry && a.updateFromObject(n),
                        e.update(a),
                        r[a.id] = i),
                        a
                    },
                    dispose: function() {
                        r = {}
                    }
                }
            }
            (N,C),
            Y = new function(e) {
                var t = {}
                  , r = new Float32Array(8);
                return {
                    update: function(n, i, o, a) {
                        var s = n.morphTargetInfluences
                          , c = s.length
                          , l = t[i.id];
                        if (void 0 === l) {
                            l = [];
                            for (var u = 0; u < c; u++)
                                l[u] = [u, 0];
                            t[i.id] = l
                        }
                        var h = o.morphTargets && i.morphAttributes.position
                          , p = o.morphNormals && i.morphAttributes.normal;
                        for (u = 0; u < c; u++)
                            0 !== (d = l[u])[1] && (h && i.removeAttribute("morphTarget" + u),
                            p && i.removeAttribute("morphNormal" + u));
                        for (u = 0; u < c; u++)
                            (d = l[u])[0] = u,
                            d[1] = s[u];
                        for (l.sort(Rr),
                        u = 0; u < 8; u++) {
                            var d;
                            if (d = l[u]) {
                                var f = d[0]
                                  , m = d[1];
                                if (m) {
                                    h && i.addAttribute("morphTarget" + u, h[f]),
                                    p && i.addAttribute("morphNormal" + u, p[f]),
                                    r[u] = m;
                                    continue
                                }
                            }
                            r[u] = 0
                        }
                        a.getUniforms().setValue(e, "morphTargetInfluences", r)
                    }
                }
            }
            (T),
            B = new Dn($,A,L),
            z = new function() {
                var e = {};
                function t(r) {
                    var n = r.target;
                    n.removeEventListener("dispose", t),
                    delete e[n.id]
                }
                return {
                    get: function(r, n) {
                        var i, o = e[r.id];
                        return void 0 === o ? (i = new Gn,
                        e[r.id] = {},
                        e[r.id][n.id] = i,
                        r.addEventListener("dispose", t)) : void 0 === (i = o[n.id]) && (i = new Gn,
                        o[n.id] = i),
                        i
                    },
                    dispose: function() {
                        e = {}
                    }
                }
            }
            ,
            G = new function() {
                var e = {};
                function t(r) {
                    var n = r.target;
                    n.removeEventListener("dispose", t),
                    delete e[n.id]
                }
                return {
                    get: function(r, n) {
                        var i;
                        return void 0 === e[r.id] ? (i = new Fn,
                        e[r.id] = {},
                        e[r.id][n.id] = i,
                        r.addEventListener("dispose", t)) : void 0 === e[r.id][n.id] ? (i = new Fn,
                        e[r.id][n.id] = i) : i = e[r.id][n.id],
                        i
                    },
                    dispose: function() {
                        e = {}
                    }
                }
            }
            ,
            U = new function(e, t, r, n) {
                var i, o, a = new Yt(0), s = 0, c = null, l = 0;
                function u(e, r) {
                    t.buffers.color.setClear(e.r, e.g, e.b, r, n)
                }
                return {
                    getClearColor: function() {
                        return a
                    },
                    setClearColor: function(e, t) {
                        a.set(e),
                        u(a, s = void 0 !== t ? t : 1)
                    },
                    getClearAlpha: function() {
                        return s
                    },
                    setClearAlpha: function(e) {
                        u(a, s = e)
                    },
                    render: function(t, n, h, f) {
                        var m = n.background;
                        if (null === m ? (u(a, s),
                        c = null,
                        l = 0) : m && m.isColor && (u(m, 1),
                        f = !0,
                        c = null,
                        l = 0),
                        (e.autoClear || f) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                        m && (m.isCubeTexture || m.isWebGLRenderTargetCube)) {
                            void 0 === o && ((o = new Cr(new wr(1,1,1),new Tr({
                                type: "BackgroundCubeMaterial",
                                uniforms: Vt(Zt.cube.uniforms),
                                vertexShader: Zt.cube.vertexShader,
                                fragmentShader: Zt.cube.fragmentShader,
                                side: d,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            }))).geometry.removeAttribute("normal"),
                            o.geometry.removeAttribute("uv"),
                            o.onBeforeRender = function(e, t, r) {
                                this.matrixWorld.copyPosition(r.matrixWorld)
                            }
                            ,
                            Object.defineProperty(o.material, "map", {
                                get: function() {
                                    return this.uniforms.tCube.value
                                }
                            }),
                            r.update(o));
                            var v = m.isWebGLRenderTargetCube ? m.texture : m;
                            o.material.uniforms.tCube.value = v,
                            o.material.uniforms.tFlip.value = m.isWebGLRenderTargetCube ? 1 : -1,
                            c === m && l === v.version || (o.material.needsUpdate = !0,
                            c = m,
                            l = v.version),
                            t.unshift(o, o.geometry, o.material, 0, 0, null)
                        } else
                            m && m.isTexture && (void 0 === i && ((i = new Cr(new Mr(2,2),new Tr({
                                type: "BackgroundMaterial",
                                uniforms: Vt(Zt.background.uniforms),
                                vertexShader: Zt.background.vertexShader,
                                fragmentShader: Zt.background.fragmentShader,
                                side: p,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            }))).geometry.removeAttribute("normal"),
                            Object.defineProperty(i.material, "map", {
                                get: function() {
                                    return this.uniforms.t2D.value
                                }
                            }),
                            r.update(i)),
                            i.material.uniforms.t2D.value = m,
                            !0 === m.matrixAutoUpdate && m.updateMatrix(),
                            i.material.uniforms.uvTransform.value.copy(m.matrix),
                            c === m && l === m.version || (i.material.needsUpdate = !0,
                            c = m,
                            l = m.version),
                            t.unshift(i, i.geometry, i.material, 0, 0, null))
                    }
                }
            }
            ($,P,D,h),
            J = new function(e, t, r, n) {
                var i;
                this.setMode = function(e) {
                    i = e
                }
                ,
                this.render = function(t, n) {
                    e.drawArrays(i, t, n),
                    r.update(n, i)
                }
                ,
                this.renderInstances = function(o, a, s) {
                    var c;
                    if (n.isWebGL2)
                        c = e;
                    else if (null === (c = t.get("ANGLE_instanced_arrays")))
                        return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](i, a, s, o.maxInstancedCount),
                    r.update(s, i, o.maxInstancedCount)
                }
            }
            (T,A,C,L),
            Z = new function(e, t, r, n) {
                var i, o, a;
                this.setMode = function(e) {
                    i = e
                }
                ,
                this.setIndex = function(e) {
                    o = e.type,
                    a = e.bytesPerElement
                }
                ,
                this.render = function(t, n) {
                    e.drawElements(i, n, o, t * a),
                    r.update(n, i)
                }
                ,
                this.renderInstances = function(s, c, l) {
                    var u;
                    if (n.isWebGL2)
                        u = e;
                    else if (null === (u = t.get("ANGLE_instanced_arrays")))
                        return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    u[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](i, l, o, c * a, s.maxInstancedCount),
                    r.update(l, i, s.maxInstancedCount)
                }
            }
            (T,A,C,L),
            C.programs = B.programs,
            $.context = T,
            $.capabilities = L,
            $.extensions = A,
            $.properties = R,
            $.renderLists = z,
            $.state = P,
            $.info = C
        }
        Pe();
        var Ce = null;
        "undefined" != typeof navigator && (Ce = "xr"in navigator ? new function(e) {
            var t = e.context
              , r = null
              , n = null
              , i = 1
              , o = null
              , a = "stage"
              , s = null
              , c = []
              , l = [];
            function u() {
                return null !== n && null !== o
            }
            var h = new Jn;
            h.layers.enable(1),
            h.viewport = new Nt;
            var p = new Jn;
            p.layers.enable(2),
            p.viewport = new Nt;
            var d = new Zn([h, p]);
            function f(e) {
                var t = c[l.indexOf(e.inputSource)];
                t && t.dispatchEvent({
                    type: e.type
                })
            }
            function m() {
                e.setFramebuffer(null),
                y.stop()
            }
            function v(e, t) {
                null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                e.matrixWorldInverse.getInverse(e.matrixWorld)
            }
            d.layers.enable(1),
            d.layers.enable(2),
            this.enabled = !1,
            this.getController = function(e) {
                var t = c[e];
                return void 0 === t && ((t = new Xn).matrixAutoUpdate = !1,
                t.visible = !1,
                c[e] = t),
                t
            }
            ,
            this.getDevice = function() {
                return r
            }
            ,
            this.setDevice = function(e) {
                void 0 !== e && (r = e),
                e instanceof XRDevice && t.setCompatibleXRDevice(e)
            }
            ,
            this.setFramebufferScaleFactor = function(e) {
                i = e
            }
            ,
            this.setFrameOfReferenceType = function(e) {
                a = e
            }
            ,
            this.setSession = function(r) {
                null !== (n = r) && (n.addEventListener("select", f),
                n.addEventListener("selectstart", f),
                n.addEventListener("selectend", f),
                n.addEventListener("end", m),
                n.baseLayer = new XRWebGLLayer(n,t,{
                    framebufferScaleFactor: i
                }),
                n.requestFrameOfReference(a).then(function(t) {
                    o = t,
                    e.setFramebuffer(n.baseLayer.framebuffer),
                    y.setContext(n),
                    y.start()
                }),
                l = n.getInputSources(),
                n.addEventListener("inputsourceschange", function() {
                    l = n.getInputSources(),
                    console.log(l);
                    for (var e = 0; e < c.length; e++)
                        c[e].userData.inputSource = l[e]
                }))
            }
            ,
            this.getCamera = function(e) {
                if (u()) {
                    var t = e.parent
                      , r = d.cameras;
                    v(d, t);
                    for (var n = 0; n < r.length; n++)
                        v(r[n], t);
                    e.matrixWorld.copy(d.matrixWorld);
                    for (var i = e.children, o = (n = 0,
                    i.length); n < o; n++)
                        i[n].updateMatrixWorld(!0);
                    return ei(d, h, p),
                    d
                }
                return e
            }
            ,
            this.isPresenting = u;
            var g = null
              , y = new Kt;
            y.setAnimationLoop(function(e, t) {
                if (null !== (s = t.getDevicePose(o)))
                    for (var r = n.baseLayer, i = t.views, a = 0; a < i.length; a++) {
                        var u = i[a]
                          , h = r.getViewport(u)
                          , p = s.getViewMatrix(u)
                          , f = d.cameras[a];
                        f.matrix.fromArray(p).getInverse(f.matrix),
                        f.projectionMatrix.fromArray(u.projectionMatrix),
                        f.viewport.set(h.x, h.y, h.width, h.height),
                        0 === a && d.matrix.copy(f.matrix)
                    }
                for (a = 0; a < c.length; a++) {
                    var m = c[a]
                      , v = l[a];
                    if (v) {
                        var y = t.getInputPose(v, o);
                        if (null !== y) {
                            "targetRay"in y ? m.matrix.elements = y.targetRay.transformMatrix : "pointerMatrix"in y && (m.matrix.elements = y.pointerMatrix),
                            m.matrix.decompose(m.position, m.rotation, m.scale),
                            m.visible = !0;
                            continue
                        }
                    }
                    m.visible = !1
                }
                g && g(e)
            }),
            this.setAnimationLoop = function(e) {
                g = e
            }
            ,
            this.dispose = function() {}
            ,
            this.getStandingMatrix = function() {
                return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."),
                new THREE.Matrix4
            }
            ,
            this.submitFrame = function() {}
        }
        ($) : new ti($)),
        this.vr = Ce;
        var Re = new Vn($,D,L.maxTextureSize);
        function Oe(e) {
            e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            ee = !0
        }
        function Ne() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            ee = !1,
            Pe()
        }
        function De(e) {
            var t = e.target;
            t.removeEventListener("dispose", De),
            function(e) {
                Be(e),
                R.remove(e)
            }(t)
        }
        function Be(e) {
            var t = R.get(e).program;
            e.program = void 0,
            void 0 !== t && B.releaseProgram(t)
        }
        this.shadowMap = Re,
        this.getContext = function() {
            return T
        }
        ,
        this.getContextAttributes = function() {
            return T.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var e = A.get("WEBGL_lose_context");
            e && e.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var e = A.get("WEBGL_lose_context");
            e && e.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return fe
        }
        ,
        this.setPixelRatio = function(e) {
            void 0 !== e && (fe = e,
            this.setSize(pe, de, !1))
        }
        ,
        this.getSize = function() {
            return {
                width: pe,
                height: de
            }
        }
        ,
        this.setSize = function(e, r, n) {
            Ce.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (pe = e,
            de = r,
            t.width = e * fe,
            t.height = r * fe,
            !1 !== n && (t.style.width = e + "px",
            t.style.height = r + "px"),
            this.setViewport(0, 0, e, r))
        }
        ,
        this.getDrawingBufferSize = function() {
            return {
                width: pe * fe,
                height: de * fe
            }
        }
        ,
        this.setDrawingBufferSize = function(e, r, n) {
            pe = e,
            de = r,
            fe = n,
            t.width = e * n,
            t.height = r * n,
            this.setViewport(0, 0, e, r)
        }
        ,
        this.getCurrentViewport = function() {
            return ce
        }
        ,
        this.setViewport = function(e, t, r, n) {
            me.set(e, de - t - n, r, n),
            P.viewport(ce.copy(me).multiplyScalar(fe))
        }
        ,
        this.setScissor = function(e, t, r, n) {
            ve.set(e, de - t - n, r, n),
            P.scissor(le.copy(ve).multiplyScalar(fe))
        }
        ,
        this.setScissorTest = function(e) {
            P.setScissorTest(ge = e)
        }
        ,
        this.getClearColor = function() {
            return U.getClearColor()
        }
        ,
        this.setClearColor = function() {
            U.setClearColor.apply(U, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return U.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            U.setClearAlpha.apply(U, arguments)
        }
        ,
        this.clear = function(e, t, r) {
            var n = 0;
            (void 0 === e || e) && (n |= 16384),
            (void 0 === t || t) && (n |= 256),
            (void 0 === r || r) && (n |= 1024),
            T.clear(n)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", Oe, !1),
            t.removeEventListener("webglcontextrestored", Ne, !1),
            z.dispose(),
            G.dispose(),
            R.dispose(),
            D.dispose(),
            Ce.dispose(),
            Ge.stop()
        }
        ,
        this.renderBufferImmediate = function(e, t) {
            P.initAttributes();
            var r = R.get(e);
            e.hasPositions && !r.position && (r.position = T.createBuffer()),
            e.hasNormals && !r.normal && (r.normal = T.createBuffer()),
            e.hasUvs && !r.uv && (r.uv = T.createBuffer()),
            e.hasColors && !r.color && (r.color = T.createBuffer());
            var n = t.getAttributes();
            e.hasPositions && (T.bindBuffer(34962, r.position),
            T.bufferData(34962, e.positionArray, 35048),
            P.enableAttribute(n.position),
            T.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)),
            e.hasNormals && (T.bindBuffer(34962, r.normal),
            T.bufferData(34962, e.normalArray, 35048),
            P.enableAttribute(n.normal),
            T.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)),
            e.hasUvs && (T.bindBuffer(34962, r.uv),
            T.bufferData(34962, e.uvArray, 35048),
            P.enableAttribute(n.uv),
            T.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)),
            e.hasColors && (T.bindBuffer(34962, r.color),
            T.bufferData(34962, e.colorArray, 35048),
            P.enableAttribute(n.color),
            T.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)),
            P.disableUnusedAttributes(),
            T.drawArrays(4, 0, e.count),
            e.count = 0
        }
        ,
        this.renderBufferDirect = function(e, t, r, n, i, o) {
            var a = i.isMesh && i.normalMatrix.determinant() < 0;
            P.setMaterial(n, a);
            var s = ke(e, t, n, i)
              , c = !1;
            oe.geometry === r.id && oe.program === s.id && oe.wireframe === (!0 === n.wireframe) || (oe.geometry = r.id,
            oe.program = s.id,
            oe.wireframe = !0 === n.wireframe,
            c = !0),
            i.morphTargetInfluences && (Y.update(i, r, n, s),
            c = !0);
            var l, u = r.index, h = r.attributes.position, p = 1;
            !0 === n.wireframe && (u = N.getWireframeAttribute(r),
            p = 2);
            var d = J;
            null !== u && (l = I.get(u),
            (d = Z).setIndex(l)),
            c && (!function(e, t, r) {
                if (r && r.isInstancedBufferGeometry & !L.isWebGL2 && null === A.get("ANGLE_instanced_arrays"))
                    return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                P.initAttributes();
                var n = r.attributes
                  , i = t.getAttributes()
                  , o = e.defaultAttributeValues;
                for (var a in i) {
                    var s = i[a];
                    if (s >= 0) {
                        var c = n[a];
                        if (void 0 !== c) {
                            var l = c.normalized
                              , u = c.itemSize
                              , h = I.get(c);
                            if (void 0 === h)
                                continue;
                            var p = h.buffer
                              , d = h.type
                              , f = h.bytesPerElement;
                            if (c.isInterleavedBufferAttribute) {
                                var m = c.data
                                  , v = m.stride
                                  , g = c.offset;
                                m && m.isInstancedInterleavedBuffer ? (P.enableAttributeAndDivisor(s, m.meshPerAttribute),
                                void 0 === r.maxInstancedCount && (r.maxInstancedCount = m.meshPerAttribute * m.count)) : P.enableAttribute(s),
                                T.bindBuffer(34962, p),
                                T.vertexAttribPointer(s, u, d, l, v * f, g * f)
                            } else
                                c.isInstancedBufferAttribute ? (P.enableAttributeAndDivisor(s, c.meshPerAttribute),
                                void 0 === r.maxInstancedCount && (r.maxInstancedCount = c.meshPerAttribute * c.count)) : P.enableAttribute(s),
                                T.bindBuffer(34962, p),
                                T.vertexAttribPointer(s, u, d, l, 0, 0)
                        } else if (void 0 !== o) {
                            var y = o[a];
                            if (void 0 !== y)
                                switch (y.length) {
                                case 2:
                                    T.vertexAttrib2fv(s, y);
                                    break;
                                case 3:
                                    T.vertexAttrib3fv(s, y);
                                    break;
                                case 4:
                                    T.vertexAttrib4fv(s, y);
                                    break;
                                default:
                                    T.vertexAttrib1fv(s, y)
                                }
                        }
                    }
                }
                P.disableUnusedAttributes()
            }(n, s, r),
            null !== u && T.bindBuffer(34963, l.buffer));
            var f = 1 / 0;
            null !== u ? f = u.count : void 0 !== h && (f = h.count);
            var m = r.drawRange.start * p
              , v = r.drawRange.count * p
              , g = null !== o ? o.start * p : 0
              , y = null !== o ? o.count * p : 1 / 0
              , b = Math.max(m, g)
              , x = Math.min(f, m + v, g + y) - 1
              , w = Math.max(0, x - b + 1);
            if (0 !== w) {
                if (i.isMesh)
                    if (!0 === n.wireframe)
                        P.setLineWidth(n.wireframeLinewidth * Ae()),
                        d.setMode(1);
                    else
                        switch (i.drawMode) {
                        case ht:
                            d.setMode(4);
                            break;
                        case pt:
                            d.setMode(5);
                            break;
                        case dt:
                            d.setMode(6)
                        }
                else if (i.isLine) {
                    var _ = n.linewidth;
                    void 0 === _ && (_ = 1),
                    P.setLineWidth(_ * Ae()),
                    i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else
                    i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
                r && r.isInstancedBufferGeometry ? r.maxInstancedCount > 0 && d.renderInstances(r, b, w) : d.render(b, w)
            }
        }
        ,
        this.compile = function(e, t) {
            (E = G.get(e, t)).init(),
            e.traverse(function(e) {
                e.isLight && (E.pushLight(e),
                e.castShadow && E.pushShadow(e))
            }),
            E.setupLights(t),
            e.traverse(function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var r = 0; r < t.material.length; r++)
                            Fe(t.material[r], e.fog, t);
                    else
                        Fe(t.material, e.fog, t)
            })
        }
        ;
        var ze = null;
        var Ge = new Kt;
        function Ue(e, t, r, n) {
            for (var i = 0, o = e.length; i < o; i++) {
                var a = e[i]
                  , s = a.object
                  , c = a.geometry
                  , l = void 0 === n ? a.material : n
                  , u = a.group;
                if (r.isArrayCamera) {
                    se = r;
                    for (var h = r.cameras, p = 0, d = h.length; p < d; p++) {
                        var f = h[p];
                        if (s.layers.test(f.layers)) {
                            if ("viewport"in f)
                                P.viewport(ce.copy(f.viewport));
                            else {
                                var m = f.bounds
                                  , v = m.x * pe
                                  , g = m.y * de
                                  , y = m.z * pe
                                  , b = m.w * de;
                                P.viewport(ce.set(v, g, y, b).multiplyScalar(fe))
                            }
                            E.setupLights(f),
                            je(s, t, f, c, l, u)
                        }
                    }
                } else
                    se = null,
                    je(s, t, r, c, l, u)
            }
        }
        function je(e, t, r, n, i, o) {
            if (e.onBeforeRender($, t, r, n, i, o),
            E = G.get(t, se || r),
            e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject) {
                P.setMaterial(i);
                var a = ke(r, t.fog, i, e);
                oe.geometry = null,
                oe.program = null,
                oe.wireframe = !1,
                function(e, t) {
                    e.render(function(e) {
                        $.renderBufferImmediate(e, t)
                    })
                }(e, a)
            } else
                $.renderBufferDirect(r, t.fog, n, i, e, o);
            e.onAfterRender($, t, r, n, i, o),
            E = G.get(t, se || r)
        }
        function Fe(e, t, r) {
            var n = R.get(e)
              , i = E.state.lights
              , o = E.state.shadowsArray
              , a = n.lightsHash
              , s = i.state.hash
              , c = B.getParameters(e, i.state, o, t, xe.numPlanes, xe.numIntersection, r)
              , l = B.getProgramCode(e, c)
              , u = n.program
              , h = !0;
            if (void 0 === u)
                e.addEventListener("dispose", De);
            else if (u.code !== l)
                Be(e);
            else if (a.stateID !== s.stateID || a.directionalLength !== s.directionalLength || a.pointLength !== s.pointLength || a.spotLength !== s.spotLength || a.rectAreaLength !== s.rectAreaLength || a.hemiLength !== s.hemiLength || a.shadowsLength !== s.shadowsLength)
                a.stateID = s.stateID,
                a.directionalLength = s.directionalLength,
                a.pointLength = s.pointLength,
                a.spotLength = s.spotLength,
                a.rectAreaLength = s.rectAreaLength,
                a.hemiLength = s.hemiLength,
                a.shadowsLength = s.shadowsLength,
                h = !1;
            else {
                if (void 0 !== c.shaderID)
                    return;
                h = !1
            }
            if (h) {
                if (c.shaderID) {
                    var p = Zt[c.shaderID];
                    n.shader = {
                        name: e.type,
                        uniforms: Vt(p.uniforms),
                        vertexShader: p.vertexShader,
                        fragmentShader: p.fragmentShader
                    }
                } else
                    n.shader = {
                        name: e.type,
                        uniforms: e.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    };
                e.onBeforeCompile(n.shader, $),
                l = B.getProgramCode(e, c),
                u = B.acquireProgram(e, n.shader, c, l),
                n.program = u,
                e.program = u
            }
            var d = u.getAttributes();
            if (e.morphTargets) {
                e.numSupportedMorphTargets = 0;
                for (var f = 0; f < $.maxMorphTargets; f++)
                    d["morphTarget" + f] >= 0 && e.numSupportedMorphTargets++
            }
            if (e.morphNormals) {
                e.numSupportedMorphNormals = 0;
                for (f = 0; f < $.maxMorphNormals; f++)
                    d["morphNormal" + f] >= 0 && e.numSupportedMorphNormals++
            }
            var m = n.shader.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = xe.numPlanes,
            n.numIntersection = xe.numIntersection,
            m.clippingPlanes = xe.uniform),
            n.fog = t,
            void 0 === a && (n.lightsHash = a = {}),
            a.stateID = s.stateID,
            a.directionalLength = s.directionalLength,
            a.pointLength = s.pointLength,
            a.spotLength = s.spotLength,
            a.rectAreaLength = s.rectAreaLength,
            a.hemiLength = s.hemiLength,
            a.shadowsLength = s.shadowsLength,
            e.lights && (m.ambientLightColor.value = i.state.ambient,
            m.directionalLights.value = i.state.directional,
            m.spotLights.value = i.state.spot,
            m.rectAreaLights.value = i.state.rectArea,
            m.pointLights.value = i.state.point,
            m.hemisphereLights.value = i.state.hemi,
            m.directionalShadowMap.value = i.state.directionalShadowMap,
            m.directionalShadowMatrix.value = i.state.directionalShadowMatrix,
            m.spotShadowMap.value = i.state.spotShadowMap,
            m.spotShadowMatrix.value = i.state.spotShadowMatrix,
            m.pointShadowMap.value = i.state.pointShadowMap,
            m.pointShadowMatrix.value = i.state.pointShadowMatrix);
            var v = n.program.getUniforms()
              , g = Sn.seqWithValue(v.seq, m);
            n.uniformsList = g
        }
        function ke(e, t, r, n) {
            he = 0;
            var i = R.get(r)
              , o = E.state.lights
              , a = i.lightsHash
              , s = o.state.hash;
            if (we && (_e || e !== ae)) {
                var c = e === ae && r.id === ie;
                xe.setState(r.clippingPlanes, r.clipIntersection, r.clipShadows, e, i, c)
            }
            !1 === r.needsUpdate && (void 0 === i.program ? r.needsUpdate = !0 : r.fog && i.fog !== t ? r.needsUpdate = !0 : (!r.lights || a.stateID === s.stateID && a.directionalLength === s.directionalLength && a.pointLength === s.pointLength && a.spotLength === s.spotLength && a.rectAreaLength === s.rectAreaLength && a.hemiLength === s.hemiLength && a.shadowsLength === s.shadowsLength) && (void 0 === i.numClippingPlanes || i.numClippingPlanes === xe.numPlanes && i.numIntersection === xe.numIntersection) || (r.needsUpdate = !0)),
            r.needsUpdate && (Fe(r, t, n),
            r.needsUpdate = !1);
            var l = !1
              , u = !1
              , h = !1
              , p = i.program
              , f = p.getUniforms()
              , m = i.shader.uniforms;
            if (P.useProgram(p.program) && (l = !0,
            u = !0,
            h = !0),
            r.id !== ie && (ie = r.id,
            u = !0),
            l || ae !== e) {
                if (f.setValue(T, "projectionMatrix", e.projectionMatrix),
                L.logarithmicDepthBuffer && f.setValue(T, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                ae !== e && (ae = e,
                u = !0,
                h = !0),
                r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshStandardMaterial || r.envMap) {
                    var v = f.map.cameraPosition;
                    void 0 !== v && v.setValue(T, Se.setFromMatrixPosition(e.matrixWorld))
                }
                (r.isMeshPhongMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.skinning) && f.setValue(T, "viewMatrix", e.matrixWorldInverse)
            }
            if (r.skinning) {
                f.setOptional(T, n, "bindMatrix"),
                f.setOptional(T, n, "bindMatrixInverse");
                var g = n.skeleton;
                if (g) {
                    var y = g.bones;
                    if (L.floatVertexTextures) {
                        if (void 0 === g.boneTexture) {
                            var b = Math.sqrt(4 * y.length);
                            b = Et.ceilPowerOfTwo(b),
                            b = Math.max(b, 4);
                            var x = new Float32Array(b * b * 4);
                            x.set(g.boneMatrices);
                            var w = new Gt(x,b,b,Ie,Ee);
                            w.needsUpdate = !0,
                            g.boneMatrices = x,
                            g.boneTexture = w,
                            g.boneTextureSize = b
                        }
                        f.setValue(T, "boneTexture", g.boneTexture),
                        f.setValue(T, "boneTextureSize", g.boneTextureSize)
                    } else
                        f.setOptional(T, g, "boneMatrices")
                }
            }
            return u && (f.setValue(T, "toneMappingExposure", $.toneMappingExposure),
            f.setValue(T, "toneMappingWhitePoint", $.toneMappingWhitePoint),
            r.lights && function(e, t) {
                e.ambientLightColor.needsUpdate = t,
                e.directionalLights.needsUpdate = t,
                e.pointLights.needsUpdate = t,
                e.spotLights.needsUpdate = t,
                e.rectAreaLights.needsUpdate = t,
                e.hemisphereLights.needsUpdate = t
            }(m, h),
            t && r.fog && function(e, t) {
                e.fogColor.value = t.color,
                t.isFog ? (e.fogNear.value = t.near,
                e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            }(m, t),
            r.isMeshBasicMaterial ? He(m, r) : r.isMeshLambertMaterial ? (He(m, r),
            function(e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
            }(m, r)) : r.isMeshPhongMaterial ? (He(m, r),
            r.isMeshToonMaterial ? function(e, t) {
                Ve(e, t),
                t.gradientMap && (e.gradientMap.value = t.gradientMap)
            }(m, r) : Ve(m, r)) : r.isMeshStandardMaterial ? (He(m, r),
            r.isMeshPhysicalMaterial ? function(e, t) {
                We(e, t),
                e.reflectivity.value = t.reflectivity,
                e.clearCoat.value = t.clearCoat,
                e.clearCoatRoughness.value = t.clearCoatRoughness
            }(m, r) : We(m, r)) : r.isMeshMatcapMaterial ? (He(m, r),
            function(e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                e.bumpScale.value = t.bumpScale,
                t.side === d && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap,
                e.normalScale.value.copy(t.normalScale),
                t.side === d && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(m, r)) : r.isMeshDepthMaterial ? (He(m, r),
            function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(m, r)) : r.isMeshDistanceMaterial ? (He(m, r),
            function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias);
                e.referencePosition.value.copy(t.referencePosition),
                e.nearDistance.value = t.nearDistance,
                e.farDistance.value = t.farDistance
            }(m, r)) : r.isMeshNormalMaterial ? (He(m, r),
            function(e, t) {
                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                e.bumpScale.value = t.bumpScale,
                t.side === d && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap,
                e.normalScale.value.copy(t.normalScale),
                t.side === d && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(m, r)) : r.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value = t.color,
                e.opacity.value = t.opacity
            }(m, r),
            r.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize,
                e.totalSize.value = t.dashSize + t.gapSize,
                e.scale.value = t.scale
            }(m, r)) : r.isPointsMaterial ? function(e, t) {
                e.diffuse.value = t.color,
                e.opacity.value = t.opacity,
                e.size.value = t.size * fe,
                e.scale.value = .5 * de,
                e.map.value = t.map,
                null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                e.uvTransform.value.copy(t.map.matrix))
            }(m, r) : r.isSpriteMaterial ? function(e, t) {
                e.diffuse.value = t.color,
                e.opacity.value = t.opacity,
                e.rotation.value = t.rotation,
                e.map.value = t.map,
                null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                e.uvTransform.value.copy(t.map.matrix))
            }(m, r) : r.isShadowMaterial && (m.color.value = r.color,
            m.opacity.value = r.opacity),
            void 0 !== m.ltc_1 && (m.ltc_1.value = Jt.LTC_1),
            void 0 !== m.ltc_2 && (m.ltc_2.value = Jt.LTC_2),
            Sn.upload(T, i.uniformsList, m, $)),
            r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (Sn.upload(T, i.uniformsList, m, $),
            r.uniformsNeedUpdate = !1),
            r.isSpriteMaterial && f.setValue(T, "center", n.center),
            f.setValue(T, "modelViewMatrix", n.modelViewMatrix),
            f.setValue(T, "normalMatrix", n.normalMatrix),
            f.setValue(T, "modelMatrix", n.matrixWorld),
            p
        }
        function He(e, t) {
            var r;
            e.opacity.value = t.opacity,
            t.color && (e.diffuse.value = t.color),
            t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
            t.map && (e.map.value = t.map),
            t.alphaMap && (e.alphaMap.value = t.alphaMap),
            t.specularMap && (e.specularMap.value = t.specularMap),
            t.envMap && (e.envMap.value = t.envMap,
            e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1,
            e.reflectivity.value = t.reflectivity,
            e.refractionRatio.value = t.refractionRatio,
            e.maxMipLevel.value = R.get(t.envMap).__maxMipLevel),
            t.lightMap && (e.lightMap.value = t.lightMap,
            e.lightMapIntensity.value = t.lightMapIntensity),
            t.aoMap && (e.aoMap.value = t.aoMap,
            e.aoMapIntensity.value = t.aoMapIntensity),
            t.map ? r = t.map : t.specularMap ? r = t.specularMap : t.displacementMap ? r = t.displacementMap : t.normalMap ? r = t.normalMap : t.bumpMap ? r = t.bumpMap : t.roughnessMap ? r = t.roughnessMap : t.metalnessMap ? r = t.metalnessMap : t.alphaMap ? r = t.alphaMap : t.emissiveMap && (r = t.emissiveMap),
            void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            e.uvTransform.value.copy(r.matrix))
        }
        function Ve(e, t) {
            e.specular.value = t.specular,
            e.shininess.value = Math.max(t.shininess, 1e-4),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            t.side === d && (e.bumpScale.value *= -1)),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            t.side === d && e.normalScale.value.negate()),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias)
        }
        function We(e, t) {
            e.roughness.value = t.roughness,
            e.metalness.value = t.metalness,
            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            t.side === d && (e.bumpScale.value *= -1)),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            t.side === d && e.normalScale.value.negate()),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias),
            t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        Ge.setAnimationLoop(function(e) {
            Ce.isPresenting() || ze && ze(e)
        }),
        "undefined" != typeof window && Ge.setContext(window),
        this.setAnimationLoop = function(e) {
            ze = e,
            Ce.setAnimationLoop(e),
            Ge.start()
        }
        ,
        this.render = function(e, t, r, n) {
            if (t && t.isCamera) {
                if (!ee) {
                    oe.geometry = null,
                    oe.program = null,
                    oe.wireframe = !1,
                    ie = -1,
                    ae = null,
                    !0 === e.autoUpdate && e.updateMatrixWorld(),
                    null === t.parent && t.updateMatrixWorld(),
                    Ce.enabled && (t = Ce.getCamera(t)),
                    (E = G.get(e, t)).init(),
                    e.onBeforeRender($, e, t, r),
                    Me.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    ye.setFromMatrix(Me),
                    _e = this.localClippingEnabled,
                    we = xe.init(this.clippingPlanes, _e, t),
                    (g = z.get(e, t)).init(),
                    function e(t, r, n, i) {
                        if (!1 === t.visible)
                            return;
                        var o = t.layers.test(r.layers);
                        if (o)
                            if (t.isGroup)
                                n = t.renderOrder;
                            else if (t.isLight)
                                E.pushLight(t),
                                t.castShadow && E.pushShadow(t);
                            else if (t.isSprite) {
                                if (!t.frustumCulled || ye.intersectsSprite(t)) {
                                    i && Se.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Me);
                                    var a = D.update(t)
                                      , s = t.material;
                                    g.push(t, a, s, n, Se.z, null)
                                }
                            } else if (t.isImmediateRenderObject)
                                i && Se.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Me),
                                g.push(t, null, t.material, n, Se.z, null);
                            else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(),
                            !t.frustumCulled || ye.intersectsObject(t))) {
                                i && Se.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Me);
                                var a = D.update(t)
                                  , s = t.material;
                                if (Array.isArray(s))
                                    for (var c = a.groups, l = 0, u = c.length; l < u; l++) {
                                        var h = c[l]
                                          , p = s[h.materialIndex];
                                        p && p.visible && g.push(t, a, p, n, Se.z, h)
                                    }
                                else
                                    s.visible && g.push(t, a, s, n, Se.z, null)
                            }
                        var d = t.children;
                        for (var l = 0, u = d.length; l < u; l++)
                            e(d[l], r, n, i)
                    }(e, t, 0, $.sortObjects),
                    !0 === $.sortObjects && g.sort(),
                    we && xe.beginShadows();
                    var i = E.state.shadowsArray;
                    Re.render(i, e, t),
                    E.setupLights(t),
                    we && xe.endShadows(),
                    this.info.autoReset && this.info.reset(),
                    void 0 === r && (r = null),
                    this.setRenderTarget(r),
                    U.render(g, e, t, n);
                    var o = g.opaque
                      , a = g.transparent;
                    if (e.overrideMaterial) {
                        var s = e.overrideMaterial;
                        o.length && Ue(o, e, t, s),
                        a.length && Ue(a, e, t, s)
                    } else
                        o.length && Ue(o, e, t),
                        a.length && Ue(a, e, t);
                    r && (O.updateRenderTargetMipmap(r),
                    O.updateMultisampleRenderTarget(r)),
                    P.buffers.depth.setTest(!0),
                    P.buffers.depth.setMask(!0),
                    P.buffers.color.setMask(!0),
                    P.setPolygonOffset(!1),
                    e.onAfterRender($, e, t),
                    Ce.enabled && Ce.submitFrame(),
                    g = null,
                    E = null
                }
            } else
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }
        ,
        this.allocTextureUnit = function() {
            var e = he;
            return e >= L.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + L.maxTextures),
            he += 1,
            e
        }
        ,
        this.setTexture2D = function() {
            var e = !1;
            return function(t, r) {
                t && t.isWebGLRenderTarget && (e || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
                e = !0),
                t = t.texture),
                O.setTexture2D(t, r)
            }
        }(),
        this.setTexture3D = function(e, t) {
            O.setTexture3D(e, t)
        }
        ,
        this.setTexture = function() {
            var e = !1;
            return function(t, r) {
                e || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
                e = !0),
                O.setTexture2D(t, r)
            }
        }(),
        this.setTextureCube = function() {
            var e = !1;
            return function(t, r) {
                t && t.isWebGLRenderTargetCube && (e || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                e = !0),
                t = t.texture),
                t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? O.setTextureCube(t, r) : O.setTextureCubeDynamic(t, r)
            }
        }(),
        this.setFramebuffer = function(e) {
            te = e
        }
        ,
        this.getRenderTarget = function() {
            return re
        }
        ,
        this.setRenderTarget = function(e) {
            re = e,
            e && void 0 === R.get(e).__webglFramebuffer && O.setupRenderTarget(e);
            var t = te
              , r = !1;
            if (e) {
                var n = R.get(e).__webglFramebuffer;
                e.isWebGLRenderTargetCube ? (t = n[e.activeCubeFace],
                r = !0) : t = e.isWebGLMultisampleRenderTarget ? R.get(e).__webglMultisampledFramebuffer : n,
                ce.copy(e.viewport),
                le.copy(e.scissor),
                ue = e.scissorTest
            } else
                ce.copy(me).multiplyScalar(fe),
                le.copy(ve).multiplyScalar(fe),
                ue = ge;
            if (ne !== t && (T.bindFramebuffer(36160, t),
            ne = t),
            P.viewport(ce),
            P.scissor(le),
            P.setScissorTest(ue),
            r) {
                var i = R.get(e.texture);
                T.framebufferTexture2D(36160, 36064, 34069 + e.activeCubeFace, i.__webglTexture, e.activeMipMapLevel)
            }
        }
        ,
        this.readRenderTargetPixels = function(e, t, r, n, i, o) {
            if (e && e.isWebGLRenderTarget) {
                var a = R.get(e).__webglFramebuffer;
                if (a) {
                    var s = !1;
                    a !== ne && (T.bindFramebuffer(36160, a),
                    s = !0);
                    try {
                        var c = e.texture
                          , l = c.format
                          , u = c.type;
                        if (l !== Ie && K.convert(l) !== T.getParameter(35739))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(u === be || K.convert(u) === T.getParameter(35738) || u === Ee && (L.isWebGL2 || A.get("OES_texture_float") || A.get("WEBGL_color_buffer_float")) || u === Te && (L.isWebGL2 ? A.get("EXT_color_buffer_float") : A.get("EXT_color_buffer_half_float"))))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        36053 === T.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - n && r >= 0 && r <= e.height - i && T.readPixels(t, r, n, i, K.convert(l), K.convert(u), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        s && T.bindFramebuffer(36160, ne)
                    }
                }
            } else
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
        ,
        this.copyFramebufferToTexture = function(e, t, r) {
            var n = t.image.width
              , i = t.image.height
              , o = K.convert(t.format);
            this.setTexture2D(t, 0),
            T.copyTexImage2D(3553, r || 0, o, e.x, e.y, n, i, 0)
        }
        ,
        this.copyTextureToTexture = function(e, t, r, n) {
            var i = t.image.width
              , o = t.image.height
              , a = K.convert(r.format)
              , s = K.convert(r.type);
            this.setTexture2D(r, 0),
            t.isDataTexture ? T.texSubImage2D(3553, n || 0, e.x, e.y, i, o, a, s, t.image.data) : T.texSubImage2D(3553, n || 0, e.x, e.y, a, s, t.image)
        }
    }
    function ni(e, t) {
        this.name = "",
        this.color = new Yt(e),
        this.density = void 0 !== t ? t : 25e-5
    }
    function ii(e, t, r) {
        this.name = "",
        this.color = new Yt(e),
        this.near = void 0 !== t ? t : 1,
        this.far = void 0 !== r ? r : 1e3
    }
    function oi() {
        nr.call(this),
        this.type = "Scene",
        this.background = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0
    }
    function ai(e, t) {
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function si(e, t, r, n) {
        this.data = e,
        this.itemSize = t,
        this.offset = r,
        this.normalized = !0 === n
    }
    function ci(e) {
        Er.call(this),
        this.type = "SpriteMaterial",
        this.color = new Yt(16777215),
        this.map = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.lights = !1,
        this.transparent = !0,
        this.setValues(e)
    }
    function li(e) {
        if (nr.call(this),
        this.type = "Sprite",
        void 0 === Kn) {
            Kn = new br;
            var t = new ai(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
            Kn.setIndex([0, 1, 2, 0, 2, 3]),
            Kn.addAttribute("position", new si(t,3,0,!1)),
            Kn.addAttribute("uv", new si(t,2,3,!1))
        }
        this.geometry = Kn,
        this.material = void 0 !== e ? e : new ci,
        this.center = new Tt(.5,.5)
    }
    function ui() {
        nr.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }
    function hi(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
        Cr.call(this, e, t),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new At,
        this.bindMatrixInverse = new At
    }
    function pi(e, t) {
        if (e = e || [],
        this.bones = e.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === t)
            this.calculateInverses();
        else if (this.bones.length === t.length)
            this.boneInverses = t.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [];
            for (var r = 0, n = this.bones.length; r < n; r++)
                this.boneInverses.push(new At)
        }
    }
    function di() {
        nr.call(this),
        this.type = "Bone"
    }
    function fi(e) {
        Er.call(this),
        this.type = "LineBasicMaterial",
        this.color = new Yt(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.lights = !1,
        this.setValues(e)
    }
    function mi(e, t, r) {
        1 === r && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),
        nr.call(this),
        this.type = "Line",
        this.geometry = void 0 !== e ? e : new br,
        this.material = void 0 !== t ? t : new fi({
            color: 16777215 * Math.random()
        })
    }
    function vi(e, t) {
        mi.call(this, e, t),
        this.type = "LineSegments"
    }
    function gi(e, t) {
        mi.call(this, e, t),
        this.type = "LineLoop"
    }
    function yi(e) {
        Er.call(this),
        this.type = "PointsMaterial",
        this.color = new Yt(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.morphTargets = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function bi(e, t) {
        nr.call(this),
        this.type = "Points",
        this.geometry = void 0 !== e ? e : new br,
        this.material = void 0 !== t ? t : new yi({
            color: 16777215 * Math.random()
        })
    }
    function xi(e, t, r, n, i, o, a, s, c) {
        It.call(this, e, t, r, n, i, o, a, s, c),
        this.format = void 0 !== a ? a : Oe,
        this.minFilter = void 0 !== o ? o : ve,
        this.magFilter = void 0 !== i ? i : ve,
        this.generateMipmaps = !1
    }
    function wi(e, t, r, n, i, o, a, s, c, l, u, h) {
        It.call(this, null, o, a, s, c, l, n, i, u, h),
        this.image = {
            width: t,
            height: r
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function _i(e, t, r, n, i, o, a, s, c) {
        It.call(this, e, t, r, n, i, o, a, s, c),
        this.needsUpdate = !0
    }
    function Mi(e, t, r, n, i, o, a, s, c, l) {
        if ((l = void 0 !== l ? l : ze) !== ze && l !== Ge)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === r && l === ze && (r = _e),
        void 0 === r && l === Ge && (r = Ce),
        It.call(this, null, n, i, o, a, s, l, r, c),
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = void 0 !== a ? a : de,
        this.minFilter = void 0 !== s ? s : de,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function Si(e) {
        br.call(this),
        this.type = "WireframeGeometry";
        var t, r, n, i, o, a, s, c, l, u, h = [], p = [0, 0], d = {}, f = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var m = e.faces;
            for (t = 0,
            n = m.length; t < n; t++) {
                var v = m[t];
                for (r = 0; r < 3; r++)
                    s = v[f[r]],
                    c = v[f[(r + 1) % 3]],
                    p[0] = Math.min(s, c),
                    p[1] = Math.max(s, c),
                    void 0 === d[l = p[0] + "," + p[1]] && (d[l] = {
                        index1: p[0],
                        index2: p[1]
                    })
            }
            for (l in d)
                a = d[l],
                u = e.vertices[a.index1],
                h.push(u.x, u.y, u.z),
                u = e.vertices[a.index2],
                h.push(u.x, u.y, u.z)
        } else if (e && e.isBufferGeometry) {
            var g, y, b, x, w, _, M;
            if (u = new Pt,
            null !== e.index) {
                for (g = e.attributes.position,
                y = e.index,
                0 === (b = e.groups).length && (b = [{
                    start: 0,
                    count: y.count,
                    materialIndex: 0
                }]),
                i = 0,
                o = b.length; i < o; ++i)
                    for (t = w = (x = b[i]).start,
                    n = w + x.count; t < n; t += 3)
                        for (r = 0; r < 3; r++)
                            s = y.getX(t + r),
                            c = y.getX(t + (r + 1) % 3),
                            p[0] = Math.min(s, c),
                            p[1] = Math.max(s, c),
                            void 0 === d[l = p[0] + "," + p[1]] && (d[l] = {
                                index1: p[0],
                                index2: p[1]
                            });
                for (l in d)
                    a = d[l],
                    u.fromBufferAttribute(g, a.index1),
                    h.push(u.x, u.y, u.z),
                    u.fromBufferAttribute(g, a.index2),
                    h.push(u.x, u.y, u.z)
            } else
                for (t = 0,
                n = (g = e.attributes.position).count / 3; t < n; t++)
                    for (r = 0; r < 3; r++)
                        _ = 3 * t + r,
                        u.fromBufferAttribute(g, _),
                        h.push(u.x, u.y, u.z),
                        M = 3 * t + (r + 1) % 3,
                        u.fromBufferAttribute(g, M),
                        h.push(u.x, u.y, u.z)
        }
        this.addAttribute("position", new fr(h,3))
    }
    function Ei(e, t, r) {
        or.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: r
        },
        this.fromBufferGeometry(new Ti(e,t,r)),
        this.mergeVertices()
    }
    function Ti(e, t, r) {
        br.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: r
        };
        var n, i, o = [], a = [], s = [], c = [], l = new Pt, u = new Pt, h = new Pt, p = new Pt, d = new Pt;
        e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var f = t + 1;
        for (n = 0; n <= r; n++) {
            var m = n / r;
            for (i = 0; i <= t; i++) {
                var v = i / t;
                e(v, m, u),
                a.push(u.x, u.y, u.z),
                v - 1e-5 >= 0 ? (e(v - 1e-5, m, h),
                p.subVectors(u, h)) : (e(v + 1e-5, m, h),
                p.subVectors(h, u)),
                m - 1e-5 >= 0 ? (e(v, m - 1e-5, h),
                d.subVectors(u, h)) : (e(v, m + 1e-5, h),
                d.subVectors(h, u)),
                l.crossVectors(p, d).normalize(),
                s.push(l.x, l.y, l.z),
                c.push(v, m)
            }
        }
        for (n = 0; n < r; n++)
            for (i = 0; i < t; i++) {
                var g = n * f + i
                  , y = n * f + i + 1
                  , b = (n + 1) * f + i + 1
                  , x = (n + 1) * f + i;
                o.push(g, y, x),
                o.push(y, b, x)
            }
        this.setIndex(o),
        this.addAttribute("position", new fr(a,3)),
        this.addAttribute("normal", new fr(s,3)),
        this.addAttribute("uv", new fr(c,2))
    }
    function Ai(e, t, r, n) {
        or.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: r,
            detail: n
        },
        this.fromBufferGeometry(new Li(e,t,r,n)),
        this.mergeVertices()
    }
    function Li(e, t, r, n) {
        br.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: r,
            detail: n
        },
        r = r || 1;
        var i = []
          , o = [];
        function a(e, t, r, n) {
            var i, o, a = Math.pow(2, n), c = [];
            for (i = 0; i <= a; i++) {
                c[i] = [];
                var l = e.clone().lerp(r, i / a)
                  , u = t.clone().lerp(r, i / a)
                  , h = a - i;
                for (o = 0; o <= h; o++)
                    c[i][o] = 0 === o && i === a ? l : l.clone().lerp(u, o / h)
            }
            for (i = 0; i < a; i++)
                for (o = 0; o < 2 * (a - i) - 1; o++) {
                    var p = Math.floor(o / 2);
                    o % 2 == 0 ? (s(c[i][p + 1]),
                    s(c[i + 1][p]),
                    s(c[i][p])) : (s(c[i][p + 1]),
                    s(c[i + 1][p + 1]),
                    s(c[i + 1][p]))
                }
        }
        function s(e) {
            i.push(e.x, e.y, e.z)
        }
        function c(t, r) {
            var n = 3 * t;
            r.x = e[n + 0],
            r.y = e[n + 1],
            r.z = e[n + 2]
        }
        function l(e, t, r, n) {
            n < 0 && 1 === e.x && (o[t] = e.x - 1),
            0 === r.x && 0 === r.z && (o[t] = n / 2 / Math.PI + .5)
        }
        function u(e) {
            return Math.atan2(e.z, -e.x)
        }
        function h(e) {
            return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
        }
        !function(e) {
            for (var r = new Pt, n = new Pt, i = new Pt, o = 0; o < t.length; o += 3)
                c(t[o + 0], r),
                c(t[o + 1], n),
                c(t[o + 2], i),
                a(r, n, i, e)
        }(n = n || 0),
        function(e) {
            for (var t = new Pt, r = 0; r < i.length; r += 3)
                t.x = i[r + 0],
                t.y = i[r + 1],
                t.z = i[r + 2],
                t.normalize().multiplyScalar(e),
                i[r + 0] = t.x,
                i[r + 1] = t.y,
                i[r + 2] = t.z
        }(r),
        function() {
            for (var e = new Pt, t = 0; t < i.length; t += 3) {
                e.x = i[t + 0],
                e.y = i[t + 1],
                e.z = i[t + 2];
                var r = u(e) / 2 / Math.PI + .5
                  , n = h(e) / Math.PI + .5;
                o.push(r, 1 - n)
            }
            (function() {
                for (var e = new Pt, t = new Pt, r = new Pt, n = new Pt, a = new Tt, s = new Tt, c = new Tt, h = 0, p = 0; h < i.length; h += 9,
                p += 6) {
                    e.set(i[h + 0], i[h + 1], i[h + 2]),
                    t.set(i[h + 3], i[h + 4], i[h + 5]),
                    r.set(i[h + 6], i[h + 7], i[h + 8]),
                    a.set(o[p + 0], o[p + 1]),
                    s.set(o[p + 2], o[p + 3]),
                    c.set(o[p + 4], o[p + 5]),
                    n.copy(e).add(t).add(r).divideScalar(3);
                    var d = u(n);
                    l(a, p + 0, e, d),
                    l(s, p + 2, t, d),
                    l(c, p + 4, r, d)
                }
            }
            )(),
            function() {
                for (var e = 0; e < o.length; e += 6) {
                    var t = o[e + 0]
                      , r = o[e + 2]
                      , n = o[e + 4]
                      , i = Math.max(t, r, n)
                      , a = Math.min(t, r, n);
                    i > .9 && a < .1 && (t < .2 && (o[e + 0] += 1),
                    r < .2 && (o[e + 2] += 1),
                    n < .2 && (o[e + 4] += 1))
                }
            }()
        }(),
        this.addAttribute("position", new fr(i,3)),
        this.addAttribute("normal", new fr(i.slice(),3)),
        this.addAttribute("uv", new fr(o,2)),
        0 === n ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function Pi(e, t) {
        or.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new Ci(e,t)),
        this.mergeVertices()
    }
    function Ci(e, t) {
        Li.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function Ri(e, t) {
        or.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new Oi(e,t)),
        this.mergeVertices()
    }
    function Oi(e, t) {
        Li.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function Ii(e, t) {
        or.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new Ni(e,t)),
        this.mergeVertices()
    }
    function Ni(e, t) {
        var r = (1 + Math.sqrt(5)) / 2
          , n = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1];
        Li.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function Di(e, t) {
        or.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new Bi(e,t)),
        this.mergeVertices()
    }
    function Bi(e, t) {
        var r = (1 + Math.sqrt(5)) / 2
          , n = 1 / r
          , i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, -n, -r, 0, -n, r, 0, n, -r, 0, n, r, 0, -r, 0, -n, r, 0, -n, -r, 0, n, r, 0, n];
        Li.call(this, i, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function zi(e, t, r, n, i, o) {
        or.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: n,
            closed: i
        },
        void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new Gi(e,t,r,n,i);
        this.tangents = a.tangents,
        this.normals = a.normals,
        this.binormals = a.binormals,
        this.fromBufferGeometry(a),
        this.mergeVertices()
    }
    function Gi(e, t, r, n, i) {
        br.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: r,
            radialSegments: n,
            closed: i
        },
        t = t || 64,
        r = r || 1,
        n = n || 8,
        i = i || !1;
        var o = e.computeFrenetFrames(t, i);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        var a, s, c = new Pt, l = new Pt, u = new Tt, h = new Pt, p = [], d = [], f = [], m = [];
        function v(i) {
            h = e.getPointAt(i / t, h);
            var a = o.normals[i]
              , u = o.binormals[i];
            for (s = 0; s <= n; s++) {
                var f = s / n * Math.PI * 2
                  , m = Math.sin(f)
                  , v = -Math.cos(f);
                l.x = v * a.x + m * u.x,
                l.y = v * a.y + m * u.y,
                l.z = v * a.z + m * u.z,
                l.normalize(),
                d.push(l.x, l.y, l.z),
                c.x = h.x + r * l.x,
                c.y = h.y + r * l.y,
                c.z = h.z + r * l.z,
                p.push(c.x, c.y, c.z)
            }
        }
        !function() {
            for (a = 0; a < t; a++)
                v(a);
            v(!1 === i ? t : 0),
            function() {
                for (a = 0; a <= t; a++)
                    for (s = 0; s <= n; s++)
                        u.x = a / t,
                        u.y = s / n,
                        f.push(u.x, u.y)
            }(),
            function() {
                for (s = 1; s <= t; s++)
                    for (a = 1; a <= n; a++) {
                        var e = (n + 1) * (s - 1) + (a - 1)
                          , r = (n + 1) * s + (a - 1)
                          , i = (n + 1) * s + a
                          , o = (n + 1) * (s - 1) + a;
                        m.push(e, r, o),
                        m.push(r, i, o)
                    }
            }()
        }(),
        this.setIndex(m),
        this.addAttribute("position", new fr(p,3)),
        this.addAttribute("normal", new fr(d,3)),
        this.addAttribute("uv", new fr(f,2))
    }
    function Ui(e, t, r, n, i, o, a) {
        or.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: n,
            p: i,
            q: o
        },
        void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new ji(e,t,r,n,i,o)),
        this.mergeVertices()
    }
    function ji(e, t, r, n, i, o) {
        br.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: r,
            radialSegments: n,
            p: i,
            q: o
        },
        e = e || 1,
        t = t || .4,
        r = Math.floor(r) || 64,
        n = Math.floor(n) || 8,
        i = i || 2,
        o = o || 3;
        var a, s, c = [], l = [], u = [], h = [], p = new Pt, d = new Pt, f = new Pt, m = new Pt, v = new Pt, g = new Pt, y = new Pt;
        for (a = 0; a <= r; ++a) {
            var b = a / r * i * Math.PI * 2;
            for (A(b, i, o, e, f),
            A(b + .01, i, o, e, m),
            g.subVectors(m, f),
            y.addVectors(m, f),
            v.crossVectors(g, y),
            y.crossVectors(v, g),
            v.normalize(),
            y.normalize(),
            s = 0; s <= n; ++s) {
                var x = s / n * Math.PI * 2
                  , w = -t * Math.cos(x)
                  , _ = t * Math.sin(x);
                p.x = f.x + (w * y.x + _ * v.x),
                p.y = f.y + (w * y.y + _ * v.y),
                p.z = f.z + (w * y.z + _ * v.z),
                l.push(p.x, p.y, p.z),
                d.subVectors(p, f).normalize(),
                u.push(d.x, d.y, d.z),
                h.push(a / r),
                h.push(s / n)
            }
        }
        for (s = 1; s <= r; s++)
            for (a = 1; a <= n; a++) {
                var M = (n + 1) * (s - 1) + (a - 1)
                  , S = (n + 1) * s + (a - 1)
                  , E = (n + 1) * s + a
                  , T = (n + 1) * (s - 1) + a;
                c.push(M, S, T),
                c.push(S, E, T)
            }
        function A(e, t, r, n, i) {
            var o = Math.cos(e)
              , a = Math.sin(e)
              , s = r / t * e
              , c = Math.cos(s);
            i.x = n * (2 + c) * .5 * o,
            i.y = n * (2 + c) * a * .5,
            i.z = n * Math.sin(s) * .5
        }
        this.setIndex(c),
        this.addAttribute("position", new fr(l,3)),
        this.addAttribute("normal", new fr(u,3)),
        this.addAttribute("uv", new fr(h,2))
    }
    function Fi(e, t, r, n, i) {
        or.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: r,
            tubularSegments: n,
            arc: i
        },
        this.fromBufferGeometry(new ki(e,t,r,n,i)),
        this.mergeVertices()
    }
    function ki(e, t, r, n, i) {
        br.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: r,
            tubularSegments: n,
            arc: i
        },
        e = e || 1,
        t = t || .4,
        r = Math.floor(r) || 8,
        n = Math.floor(n) || 6,
        i = i || 2 * Math.PI;
        var o, a, s = [], c = [], l = [], u = [], h = new Pt, p = new Pt, d = new Pt;
        for (o = 0; o <= r; o++)
            for (a = 0; a <= n; a++) {
                var f = a / n * i
                  , m = o / r * Math.PI * 2;
                p.x = (e + t * Math.cos(m)) * Math.cos(f),
                p.y = (e + t * Math.cos(m)) * Math.sin(f),
                p.z = t * Math.sin(m),
                c.push(p.x, p.y, p.z),
                h.x = e * Math.cos(f),
                h.y = e * Math.sin(f),
                d.subVectors(p, h).normalize(),
                l.push(d.x, d.y, d.z),
                u.push(a / n),
                u.push(o / r)
            }
        for (o = 1; o <= r; o++)
            for (a = 1; a <= n; a++) {
                var v = (n + 1) * o + a - 1
                  , g = (n + 1) * (o - 1) + a - 1
                  , y = (n + 1) * (o - 1) + a
                  , b = (n + 1) * o + a;
                s.push(v, g, b),
                s.push(g, y, b)
            }
        this.setIndex(s),
        this.addAttribute("position", new fr(c,3)),
        this.addAttribute("normal", new fr(l,3)),
        this.addAttribute("uv", new fr(u,2))
    }
    ni.prototype.isFogExp2 = !0,
    ni.prototype.clone = function() {
        return new ni(this.color,this.density)
    }
    ,
    ni.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
    ,
    ii.prototype.isFog = !0,
    ii.prototype.clone = function() {
        return new ii(this.color,this.near,this.far)
    }
    ,
    ii.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
    ,
    oi.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: oi,
        isScene: !0,
        copy: function(e, t) {
            return nr.prototype.copy.call(this, e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.autoUpdate = e.autoUpdate,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        },
        toJSON: function(e) {
            var t = nr.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)),
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(ai.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(ai.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array),
            this.count = e.count,
            this.stride = e.stride,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, r) {
            e *= this.stride,
            r *= t.stride;
            for (var n = 0, i = this.stride; n < i; n++)
                this.array[e + n] = t.array[r + n];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        }
    }),
    Object.defineProperties(si.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(si.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
            this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
            this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
            this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
            this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, r) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this
        },
        setXYZ: function(e, t, r, n) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this.data.array[e + 2] = n,
            this
        },
        setXYZW: function(e, t, r, n, i) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = r,
            this.data.array[e + 2] = n,
            this.data.array[e + 3] = i,
            this
        }
    }),
    ci.prototype = Object.create(Er.prototype),
    ci.prototype.constructor = ci,
    ci.prototype.isSpriteMaterial = !0,
    ci.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this
    }
    ,
    li.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: li,
        isSprite: !0,
        raycast: function() {
            var e = new Pt
              , t = new Pt
              , r = new Pt
              , n = new Tt
              , i = new Tt
              , o = new At
              , a = new Pt
              , s = new Pt
              , c = new Pt
              , l = new Tt
              , u = new Tt
              , h = new Tt;
            function p(e, t, r, a, s, c) {
                n.subVectors(e, r).addScalar(.5).multiply(a),
                void 0 !== s ? (i.x = c * n.x - s * n.y,
                i.y = s * n.x + c * n.y) : i.copy(n),
                e.copy(t),
                e.x += i.x,
                e.y += i.y,
                e.applyMatrix4(o)
            }
            return function(n, i) {
                t.setFromMatrixScale(this.matrixWorld),
                o.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
                r.setFromMatrixPosition(this.modelViewMatrix);
                var d, f, m = this.material.rotation;
                0 !== m && (f = Math.cos(m),
                d = Math.sin(m));
                var v = this.center;
                p(a.set(-.5, -.5, 0), r, v, t, d, f),
                p(s.set(.5, -.5, 0), r, v, t, d, f),
                p(c.set(.5, .5, 0), r, v, t, d, f),
                l.set(0, 0),
                u.set(1, 0),
                h.set(1, 1);
                var g = n.ray.intersectTriangle(a, s, c, !1, e);
                if (null !== g || (p(s.set(-.5, .5, 0), r, v, t, d, f),
                u.set(0, 1),
                null !== (g = n.ray.intersectTriangle(a, c, s, !1, e)))) {
                    var y = n.ray.origin.distanceTo(e);
                    y < n.near || y > n.far || i.push({
                        distance: y,
                        point: e.clone(),
                        uv: Lr.getUV(e, a, s, c, l, u, h, new Tt),
                        face: null,
                        object: this
                    })
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return nr.prototype.copy.call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            this
        }
    }),
    ui.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: ui,
        copy: function(e) {
            nr.prototype.copy.call(this, e, !1);
            for (var t = e.levels, r = 0, n = t.length; r < n; r++) {
                var i = t[r];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0),
            t = Math.abs(t);
            for (var r = this.levels, n = 0; n < r.length && !(t < r[n].distance); n++)
                ;
            r.splice(n, 0, {
                distance: t,
                object: e
            }),
            this.add(e)
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, r = 1, n = t.length; r < n && !(e < t[r].distance); r++)
                ;
            return t[r - 1].object
        },
        raycast: function() {
            var e = new Pt;
            return function(t, r) {
                e.setFromMatrixPosition(this.matrixWorld);
                var n = t.ray.origin.distanceTo(e);
                this.getObjectForDistance(n).raycast(t, r)
            }
        }(),
        update: function() {
            var e = new Pt
              , t = new Pt;
            return function(r) {
                var n = this.levels;
                if (n.length > 1) {
                    e.setFromMatrixPosition(r.matrixWorld),
                    t.setFromMatrixPosition(this.matrixWorld);
                    var i = e.distanceTo(t);
                    n[0].object.visible = !0;
                    for (var o = 1, a = n.length; o < a && i >= n[o].distance; o++)
                        n[o - 1].object.visible = !1,
                        n[o].object.visible = !0;
                    for (; o < a; o++)
                        n[o].object.visible = !1
                }
            }
        }(),
        toJSON: function(e) {
            var t = nr.prototype.toJSON.call(this, e);
            t.object.levels = [];
            for (var r = this.levels, n = 0, i = r.length; n < i; n++) {
                var o = r[n];
                t.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return t
        }
    }),
    hi.prototype = Object.assign(Object.create(Cr.prototype), {
        constructor: hi,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new Nt, t = this.geometry.attributes.skinWeight, r = 0, n = t.count; r < n; r++) {
                e.x = t.getX(r),
                e.y = t.getY(r),
                e.z = t.getZ(r),
                e.w = t.getW(r);
                var i = 1 / e.manhattanLength();
                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                t.setXYZW(r, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            Cr.prototype.updateMatrixWorld.call(this, e),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Object.assign(pi.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var r = new At;
                this.bones[e] && r.getInverse(this.bones[e].matrixWorld),
                this.boneInverses.push(r)
            }
        },
        pose: function() {
            var e, t, r;
            for (t = 0,
            r = this.bones.length; t < r; t++)
                (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0,
            r = this.bones.length; t < r; t++)
                (e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld),
                e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: function() {
            var e = new At
              , t = new At;
            return function() {
                for (var r = this.bones, n = this.boneInverses, i = this.boneMatrices, o = this.boneTexture, a = 0, s = r.length; a < s; a++) {
                    var c = r[a] ? r[a].matrixWorld : t;
                    e.multiplyMatrices(c, n[a]),
                    e.toArray(i, 16 * a)
                }
                void 0 !== o && (o.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new pi(this.bones,this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, r = this.bones.length; t < r; t++) {
                var n = this.bones[t];
                if (n.name === e)
                    return n
            }
        }
    }),
    di.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: di,
        isBone: !0
    }),
    fi.prototype = Object.create(Er.prototype),
    fi.prototype.constructor = fi,
    fi.prototype.isLineBasicMaterial = !0,
    fi.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this
    }
    ,
    mi.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: mi,
        isLine: !0,
        computeLineDistances: function() {
            var e = new Pt
              , t = new Pt;
            return function() {
                var r = this.geometry;
                if (r.isBufferGeometry)
                    if (null === r.index) {
                        for (var n = r.attributes.position, i = [0], o = 1, a = n.count; o < a; o++)
                            e.fromBufferAttribute(n, o - 1),
                            t.fromBufferAttribute(n, o),
                            i[o] = i[o - 1],
                            i[o] += e.distanceTo(t);
                        r.addAttribute("lineDistance", new fr(i,1))
                    } else
                        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (r.isGeometry) {
                    var s = r.vertices;
                    (i = r.lineDistances)[0] = 0;
                    for (o = 1,
                    a = s.length; o < a; o++)
                        i[o] = i[o - 1],
                        i[o] += s[o - 1].distanceTo(s[o])
                }
                return this
            }
        }(),
        raycast: function() {
            var e = new At
              , t = new Ar
              , r = new jt;
            return function(n, i) {
                var o = n.linePrecision
                  , a = this.geometry
                  , s = this.matrixWorld;
                if (null === a.boundingSphere && a.computeBoundingSphere(),
                r.copy(a.boundingSphere),
                r.applyMatrix4(s),
                r.radius += o,
                !1 !== n.ray.intersectsSphere(r)) {
                    e.getInverse(s),
                    t.copy(n.ray).applyMatrix4(e);
                    var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , l = c * c
                      , u = new Pt
                      , h = new Pt
                      , p = new Pt
                      , d = new Pt
                      , f = this && this.isLineSegments ? 2 : 1;
                    if (a.isBufferGeometry) {
                        var m = a.index
                          , v = a.attributes.position.array;
                        if (null !== m)
                            for (var g = m.array, y = 0, b = g.length - 1; y < b; y += f) {
                                var x = g[y]
                                  , w = g[y + 1];
                                if (u.fromArray(v, 3 * x),
                                h.fromArray(v, 3 * w),
                                !(t.distanceSqToSegment(u, h, d, p) > l))
                                    d.applyMatrix4(this.matrixWorld),
                                    (S = n.ray.origin.distanceTo(d)) < n.near || S > n.far || i.push({
                                        distance: S,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                            }
                        else
                            for (y = 0,
                            b = v.length / 3 - 1; y < b; y += f) {
                                if (u.fromArray(v, 3 * y),
                                h.fromArray(v, 3 * y + 3),
                                !(t.distanceSqToSegment(u, h, d, p) > l))
                                    d.applyMatrix4(this.matrixWorld),
                                    (S = n.ray.origin.distanceTo(d)) < n.near || S > n.far || i.push({
                                        distance: S,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                            }
                    } else if (a.isGeometry) {
                        var _ = a.vertices
                          , M = _.length;
                        for (y = 0; y < M - 1; y += f) {
                            var S;
                            if (!(t.distanceSqToSegment(_[y], _[y + 1], d, p) > l))
                                d.applyMatrix4(this.matrixWorld),
                                (S = n.ray.origin.distanceTo(d)) < n.near || S > n.far || i.push({
                                    distance: S,
                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                        }
                    }
                }
            }
        }(),
        copy: function(e) {
            return nr.prototype.copy.call(this, e),
            this.geometry.copy(e.geometry),
            this.material.copy(e.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    vi.prototype = Object.assign(Object.create(mi.prototype), {
        constructor: vi,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = new Pt
              , t = new Pt;
            return function() {
                var r = this.geometry;
                if (r.isBufferGeometry)
                    if (null === r.index) {
                        for (var n = r.attributes.position, i = [], o = 0, a = n.count; o < a; o += 2)
                            e.fromBufferAttribute(n, o),
                            t.fromBufferAttribute(n, o + 1),
                            i[o] = 0 === o ? 0 : i[o - 1],
                            i[o + 1] = i[o] + e.distanceTo(t);
                        r.addAttribute("lineDistance", new fr(i,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (r.isGeometry) {
                    var s = r.vertices;
                    for (i = r.lineDistances,
                    o = 0,
                    a = s.length; o < a; o += 2)
                        e.copy(s[o]),
                        t.copy(s[o + 1]),
                        i[o] = 0 === o ? 0 : i[o - 1],
                        i[o + 1] = i[o] + e.distanceTo(t)
                }
                return this
            }
        }()
    }),
    gi.prototype = Object.assign(Object.create(mi.prototype), {
        constructor: gi,
        isLineLoop: !0
    }),
    yi.prototype = Object.create(Er.prototype),
    yi.prototype.constructor = yi,
    yi.prototype.isPointsMaterial = !0,
    yi.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    bi.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: bi,
        isPoints: !0,
        raycast: function() {
            var e = new At
              , t = new Ar
              , r = new jt;
            return function(n, i) {
                var o = this
                  , a = this.geometry
                  , s = this.matrixWorld
                  , c = n.params.Points.threshold;
                if (null === a.boundingSphere && a.computeBoundingSphere(),
                r.copy(a.boundingSphere),
                r.applyMatrix4(s),
                r.radius += c,
                !1 !== n.ray.intersectsSphere(r)) {
                    e.getInverse(s),
                    t.copy(n.ray).applyMatrix4(e);
                    var l = c / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , u = l * l
                      , h = new Pt
                      , p = new Pt;
                    if (a.isBufferGeometry) {
                        var d = a.index
                          , f = a.attributes.position.array;
                        if (null !== d)
                            for (var m = d.array, v = 0, g = m.length; v < g; v++) {
                                var y = m[v];
                                h.fromArray(f, 3 * y),
                                w(h, y)
                            }
                        else {
                            v = 0;
                            for (var b = f.length / 3; v < b; v++)
                                h.fromArray(f, 3 * v),
                                w(h, v)
                        }
                    } else {
                        var x = a.vertices;
                        for (v = 0,
                        b = x.length; v < b; v++)
                            w(x[v], v)
                    }
                }
                function w(e, r) {
                    var a = t.distanceSqToPoint(e);
                    if (a < u) {
                        t.closestPointToPoint(e, p),
                        p.applyMatrix4(s);
                        var c = n.ray.origin.distanceTo(p);
                        if (c < n.near || c > n.far)
                            return;
                        i.push({
                            distance: c,
                            distanceToRay: Math.sqrt(a),
                            point: p.clone(),
                            index: r,
                            face: null,
                            object: o
                        })
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    xi.prototype = Object.assign(Object.create(It.prototype), {
        constructor: xi,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    wi.prototype = Object.create(It.prototype),
    wi.prototype.constructor = wi,
    wi.prototype.isCompressedTexture = !0,
    _i.prototype = Object.create(It.prototype),
    _i.prototype.constructor = _i,
    _i.prototype.isCanvasTexture = !0,
    Mi.prototype = Object.create(It.prototype),
    Mi.prototype.constructor = Mi,
    Mi.prototype.isDepthTexture = !0,
    Si.prototype = Object.create(br.prototype),
    Si.prototype.constructor = Si,
    Ei.prototype = Object.create(or.prototype),
    Ei.prototype.constructor = Ei,
    Ti.prototype = Object.create(br.prototype),
    Ti.prototype.constructor = Ti,
    Ai.prototype = Object.create(or.prototype),
    Ai.prototype.constructor = Ai,
    Li.prototype = Object.create(br.prototype),
    Li.prototype.constructor = Li,
    Pi.prototype = Object.create(or.prototype),
    Pi.prototype.constructor = Pi,
    Ci.prototype = Object.create(Li.prototype),
    Ci.prototype.constructor = Ci,
    Ri.prototype = Object.create(or.prototype),
    Ri.prototype.constructor = Ri,
    Oi.prototype = Object.create(Li.prototype),
    Oi.prototype.constructor = Oi,
    Ii.prototype = Object.create(or.prototype),
    Ii.prototype.constructor = Ii,
    Ni.prototype = Object.create(Li.prototype),
    Ni.prototype.constructor = Ni,
    Di.prototype = Object.create(or.prototype),
    Di.prototype.constructor = Di,
    Bi.prototype = Object.create(Li.prototype),
    Bi.prototype.constructor = Bi,
    zi.prototype = Object.create(or.prototype),
    zi.prototype.constructor = zi,
    Gi.prototype = Object.create(br.prototype),
    Gi.prototype.constructor = Gi,
    Ui.prototype = Object.create(or.prototype),
    Ui.prototype.constructor = Ui,
    ji.prototype = Object.create(br.prototype),
    ji.prototype.constructor = ji,
    Fi.prototype = Object.create(or.prototype),
    Fi.prototype.constructor = Fi,
    ki.prototype = Object.create(br.prototype),
    ki.prototype.constructor = ki;
    var Hi = function(e, t, r) {
        r = r || 2;
        var n, i, o, a, s, c, l, u = t && t.length, h = u ? t[0] * r : e.length, p = Vi(e, 0, h, r, !0), d = [];
        if (!p)
            return d;
        if (u && (p = function(e, t, r, n) {
            var i, o, a, s, c, l = [];
            for (i = 0,
            o = t.length; i < o; i++)
                a = t[i] * n,
                s = i < o - 1 ? t[i + 1] * n : e.length,
                (c = Vi(e, a, s, n, !1)) === c.next && (c.steiner = !0),
                l.push(eo(c));
            for (l.sort(Ki),
            i = 0; i < l.length; i++)
                Qi(l[i], r),
                r = Wi(r, r.next);
            return r
        }(e, t, p, r)),
        e.length > 80 * r) {
            n = o = e[0],
            i = a = e[1];
            for (var f = r; f < h; f += r)
                s = e[f],
                c = e[f + 1],
                s < n && (n = s),
                c < i && (i = c),
                s > o && (o = s),
                c > a && (a = c);
            l = 0 !== (l = Math.max(o - n, a - i)) ? 1 / l : 0
        }
        return qi(p, d, r, n, i, l),
        d
    };
    function Vi(e, t, r, n, i) {
        var o, a;
        if (i === function(e, t, r, n) {
            for (var i = 0, o = t, a = r - n; o < r; o += n)
                i += (e[a] - e[o]) * (e[o + 1] + e[a + 1]),
                a = o;
            return i
        }(e, t, r, n) > 0)
            for (o = t; o < r; o += n)
                a = co(o, e[o], e[o + 1], a);
        else
            for (o = r - n; o >= t; o -= n)
                a = co(o, e[o], e[o + 1], a);
        return a && io(a, a.next) && (lo(a),
        a = a.next),
        a
    }
    function Wi(e, t) {
        if (!e)
            return e;
        t || (t = e);
        var r, n = e;
        do {
            if (r = !1,
            n.steiner || !io(n, n.next) && 0 !== no(n.prev, n, n.next))
                n = n.next;
            else {
                if (lo(n),
                (n = t = n.prev) === n.next)
                    break;
                r = !0
            }
        } while (r || n !== t);
        return t
    }
    function qi(e, t, r, n, i, o, a) {
        if (e) {
            !a && o && function(e, t, r, n) {
                var i = e;
                do {
                    null === i.z && (i.z = $i(i.x, i.y, t, r, n)),
                    i.prevZ = i.prev,
                    i.nextZ = i.next,
                    i = i.next
                } while (i !== e);
                i.prevZ.nextZ = null,
                i.prevZ = null,
                function(e) {
                    var t, r, n, i, o, a, s, c, l = 1;
                    do {
                        for (r = e,
                        e = null,
                        o = null,
                        a = 0; r; ) {
                            for (a++,
                            n = r,
                            s = 0,
                            t = 0; t < l && (s++,
                            n = n.nextZ); t++)
                                ;
                            for (c = l; s > 0 || c > 0 && n; )
                                0 !== s && (0 === c || !n || r.z <= n.z) ? (i = r,
                                r = r.nextZ,
                                s--) : (i = n,
                                n = n.nextZ,
                                c--),
                                o ? o.nextZ = i : e = i,
                                i.prevZ = o,
                                o = i;
                            r = n
                        }
                        o.nextZ = null,
                        l *= 2
                    } while (a > 1)
                }(i)
            }(e, n, i, o);
            for (var s, c, l = e; e.prev !== e.next; )
                if (s = e.prev,
                c = e.next,
                o ? Yi(e, n, i, o) : Xi(e))
                    t.push(s.i / r),
                    t.push(e.i / r),
                    t.push(c.i / r),
                    lo(e),
                    e = c.next,
                    l = c.next;
                else if ((e = c) === l) {
                    a ? 1 === a ? qi(e = Ji(e, t, r), t, r, n, i, o, 2) : 2 === a && Zi(e, t, r, n, i, o) : qi(Wi(e), t, r, n, i, o, 1);
                    break
                }
        }
    }
    function Xi(e) {
        var t = e.prev
          , r = e
          , n = e.next;
        if (no(t, r, n) >= 0)
            return !1;
        for (var i = e.next.next; i !== e.prev; ) {
            if (to(t.x, t.y, r.x, r.y, n.x, n.y, i.x, i.y) && no(i.prev, i, i.next) >= 0)
                return !1;
            i = i.next
        }
        return !0
    }
    function Yi(e, t, r, n) {
        var i = e.prev
          , o = e
          , a = e.next;
        if (no(i, o, a) >= 0)
            return !1;
        for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, l = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, u = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, h = $i(s, c, t, r, n), p = $i(l, u, t, r, n), d = e.nextZ; d && d.z <= p; ) {
            if (d !== e.prev && d !== e.next && to(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && no(d.prev, d, d.next) >= 0)
                return !1;
            d = d.nextZ
        }
        for (d = e.prevZ; d && d.z >= h; ) {
            if (d !== e.prev && d !== e.next && to(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && no(d.prev, d, d.next) >= 0)
                return !1;
            d = d.prevZ
        }
        return !0
    }
    function Ji(e, t, r) {
        var n = e;
        do {
            var i = n.prev
              , o = n.next.next;
            !io(i, o) && oo(i, n, n.next, o) && ao(i, o) && ao(o, i) && (t.push(i.i / r),
            t.push(n.i / r),
            t.push(o.i / r),
            lo(n),
            lo(n.next),
            n = e = o),
            n = n.next
        } while (n !== e);
        return n
    }
    function Zi(e, t, r, n, i, o) {
        var a = e;
        do {
            for (var s = a.next.next; s !== a.prev; ) {
                if (a.i !== s.i && ro(a, s)) {
                    var c = so(a, s);
                    return a = Wi(a, a.next),
                    c = Wi(c, c.next),
                    qi(a, t, r, n, i, o),
                    void qi(c, t, r, n, i, o)
                }
                s = s.next
            }
            a = a.next
        } while (a !== e)
    }
    function Ki(e, t) {
        return e.x - t.x
    }
    function Qi(e, t) {
        if (t = function(e, t) {
            var r, n = t, i = e.x, o = e.y, a = -1 / 0;
            do {
                if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
                    var s = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    if (s <= i && s > a) {
                        if (a = s,
                        s === i) {
                            if (o === n.y)
                                return n;
                            if (o === n.next.y)
                                return n.next
                        }
                        r = n.x < n.next.x ? n : n.next
                    }
                }
                n = n.next
            } while (n !== t);
            if (!r)
                return null;
            if (i === a)
                return r.prev;
            var c, l = r, u = r.x, h = r.y, p = 1 / 0;
            n = r.next;
            for (; n !== l; )
                i >= n.x && n.x >= u && i !== n.x && to(o < h ? i : a, o, u, h, o < h ? a : i, o, n.x, n.y) && ((c = Math.abs(o - n.y) / (i - n.x)) < p || c === p && n.x > r.x) && ao(n, e) && (r = n,
                p = c),
                n = n.next;
            return r
        }(e, t)) {
            var r = so(t, e);
            Wi(r, r.next)
        }
    }
    function $i(e, t, r, n, i) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }
    function eo(e) {
        var t = e
          , r = e;
        do {
            t.x < r.x && (r = t),
            t = t.next
        } while (t !== e);
        return r
    }
    function to(e, t, r, n, i, o, a, s) {
        return (i - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (n - s) - (r - a) * (t - s) >= 0 && (r - a) * (o - s) - (i - a) * (n - s) >= 0
    }
    function ro(e, t) {
        return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
            var r = e;
            do {
                if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && oo(r, r.next, e, t))
                    return !0;
                r = r.next
            } while (r !== e);
            return !1
        }(e, t) && ao(e, t) && ao(t, e) && function(e, t) {
            var r = e
              , n = !1
              , i = (e.x + t.x) / 2
              , o = (e.y + t.y) / 2;
            do {
                r.y > o != r.next.y > o && r.next.y !== r.y && i < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (n = !n),
                r = r.next
            } while (r !== e);
            return n
        }(e, t)
    }
    function no(e, t, r) {
        return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y)
    }
    function io(e, t) {
        return e.x === t.x && e.y === t.y
    }
    function oo(e, t, r, n) {
        return !!(io(e, t) && io(r, n) || io(e, n) && io(r, t)) || no(e, t, r) > 0 != no(e, t, n) > 0 && no(r, n, e) > 0 != no(r, n, t) > 0
    }
    function ao(e, t) {
        return no(e.prev, e, e.next) < 0 ? no(e, t, e.next) >= 0 && no(e, e.prev, t) >= 0 : no(e, t, e.prev) < 0 || no(e, e.next, t) < 0
    }
    function so(e, t) {
        var r = new uo(e.i,e.x,e.y)
          , n = new uo(t.i,t.x,t.y)
          , i = e.next
          , o = t.prev;
        return e.next = t,
        t.prev = e,
        r.next = i,
        i.prev = r,
        n.next = r,
        r.prev = n,
        o.next = n,
        n.prev = o,
        n
    }
    function co(e, t, r, n) {
        var i = new uo(e,t,r);
        return n ? (i.next = n.next,
        i.prev = n,
        n.next.prev = i,
        n.next = i) : (i.prev = i,
        i.next = i),
        i
    }
    function lo(e) {
        e.next.prev = e.prev,
        e.prev.next = e.next,
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }
    function uo(e, t, r) {
        this.i = e,
        this.x = t,
        this.y = r,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    var ho = {
        area: function(e) {
            for (var t = e.length, r = 0, n = t - 1, i = 0; i < t; n = i++)
                r += e[n].x * e[i].y - e[i].x * e[n].y;
            return .5 * r
        },
        isClockWise: function(e) {
            return ho.area(e) < 0
        },
        triangulateShape: function(e, t) {
            var r = []
              , n = []
              , i = [];
            po(e),
            fo(r, e);
            var o = e.length;
            t.forEach(po);
            for (var a = 0; a < t.length; a++)
                n.push(o),
                o += t[a].length,
                fo(r, t[a]);
            var s = Hi(r, n);
            for (a = 0; a < s.length; a += 3)
                i.push(s.slice(a, a + 3));
            return i
        }
    };
    function po(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop()
    }
    function fo(e, t) {
        for (var r = 0; r < t.length; r++)
            e.push(t[r].x),
            e.push(t[r].y)
    }
    function mo(e, t) {
        or.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        this.fromBufferGeometry(new vo(e,t)),
        this.mergeVertices()
    }
    function vo(e, t) {
        br.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: e,
            options: t
        };
        for (var r = this, n = [], i = [], o = 0, a = (e = Array.isArray(e) ? e : [e]).length; o < a; o++) {
            s(e[o])
        }
        function s(e) {
            var o = []
              , a = void 0 !== t.curveSegments ? t.curveSegments : 12
              , s = void 0 !== t.steps ? t.steps : 1
              , c = void 0 !== t.depth ? t.depth : 100
              , l = void 0 === t.bevelEnabled || t.bevelEnabled
              , u = void 0 !== t.bevelThickness ? t.bevelThickness : 6
              , h = void 0 !== t.bevelSize ? t.bevelSize : u - 2
              , p = void 0 !== t.bevelSegments ? t.bevelSegments : 3
              , d = t.extrudePath
              , f = void 0 !== t.UVGenerator ? t.UVGenerator : go;
            void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
            c = t.amount);
            var m, v, g, y, b, x, w, _, M = !1;
            d && (m = d.getSpacedPoints(s),
            M = !0,
            l = !1,
            v = d.computeFrenetFrames(s, !1),
            g = new Pt,
            y = new Pt,
            b = new Pt),
            l || (p = 0,
            u = 0,
            h = 0);
            var S = e.extractPoints(a)
              , E = S.shape
              , T = S.holes;
            if (!ho.isClockWise(E))
                for (E = E.reverse(),
                w = 0,
                _ = T.length; w < _; w++)
                    x = T[w],
                    ho.isClockWise(x) && (T[w] = x.reverse());
            var A = ho.triangulateShape(E, T)
              , L = E;
            for (w = 0,
            _ = T.length; w < _; w++)
                x = T[w],
                E = E.concat(x);
            function P(e, t, r) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                t.clone().multiplyScalar(r).add(e)
            }
            var C, R, O, I, N, D, B = E.length, z = A.length;
            function G(e, t, r) {
                var n, i, o, a = e.x - t.x, s = e.y - t.y, c = r.x - e.x, l = r.y - e.y, u = a * a + s * s, h = a * l - s * c;
                if (Math.abs(h) > Number.EPSILON) {
                    var p = Math.sqrt(u)
                      , d = Math.sqrt(c * c + l * l)
                      , f = t.x - s / p
                      , m = t.y + a / p
                      , v = ((r.x - l / d - f) * l - (r.y + c / d - m) * c) / (a * l - s * c)
                      , g = (n = f + a * v - e.x) * n + (i = m + s * v - e.y) * i;
                    if (g <= 2)
                        return new Tt(n,i);
                    o = Math.sqrt(g / 2)
                } else {
                    var y = !1;
                    a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0),
                    y ? (n = -s,
                    i = a,
                    o = Math.sqrt(u)) : (n = a,
                    i = s,
                    o = Math.sqrt(u / 2))
                }
                return new Tt(n / o,i / o)
            }
            for (var U = [], j = 0, F = L.length, k = F - 1, H = j + 1; j < F; j++,
            k++,
            H++)
                k === F && (k = 0),
                H === F && (H = 0),
                U[j] = G(L[j], L[k], L[H]);
            var V, W, q = [], X = U.concat();
            for (w = 0,
            _ = T.length; w < _; w++) {
                for (x = T[w],
                V = [],
                j = 0,
                k = (F = x.length) - 1,
                H = j + 1; j < F; j++,
                k++,
                H++)
                    k === F && (k = 0),
                    H === F && (H = 0),
                    V[j] = G(x[j], x[k], x[H]);
                q.push(V),
                X = X.concat(V)
            }
            for (C = 0; C < p; C++) {
                for (O = C / p,
                I = u * Math.cos(O * Math.PI / 2),
                R = h * Math.sin(O * Math.PI / 2),
                j = 0,
                F = L.length; j < F; j++)
                    J((N = P(L[j], U[j], R)).x, N.y, -I);
                for (w = 0,
                _ = T.length; w < _; w++)
                    for (x = T[w],
                    V = q[w],
                    j = 0,
                    F = x.length; j < F; j++)
                        J((N = P(x[j], V[j], R)).x, N.y, -I)
            }
            for (R = h,
            j = 0; j < B; j++)
                N = l ? P(E[j], X[j], R) : E[j],
                M ? (y.copy(v.normals[0]).multiplyScalar(N.x),
                g.copy(v.binormals[0]).multiplyScalar(N.y),
                b.copy(m[0]).add(y).add(g),
                J(b.x, b.y, b.z)) : J(N.x, N.y, 0);
            for (W = 1; W <= s; W++)
                for (j = 0; j < B; j++)
                    N = l ? P(E[j], X[j], R) : E[j],
                    M ? (y.copy(v.normals[W]).multiplyScalar(N.x),
                    g.copy(v.binormals[W]).multiplyScalar(N.y),
                    b.copy(m[W]).add(y).add(g),
                    J(b.x, b.y, b.z)) : J(N.x, N.y, c / s * W);
            for (C = p - 1; C >= 0; C--) {
                for (O = C / p,
                I = u * Math.cos(O * Math.PI / 2),
                R = h * Math.sin(O * Math.PI / 2),
                j = 0,
                F = L.length; j < F; j++)
                    J((N = P(L[j], U[j], R)).x, N.y, c + I);
                for (w = 0,
                _ = T.length; w < _; w++)
                    for (x = T[w],
                    V = q[w],
                    j = 0,
                    F = x.length; j < F; j++)
                        N = P(x[j], V[j], R),
                        M ? J(N.x, N.y + m[s - 1].y, m[s - 1].x + I) : J(N.x, N.y, c + I)
            }
            function Y(e, t) {
                var r, n;
                for (j = e.length; --j >= 0; ) {
                    r = j,
                    (n = j - 1) < 0 && (n = e.length - 1);
                    var i = 0
                      , o = s + 2 * p;
                    for (i = 0; i < o; i++) {
                        var a = B * i
                          , c = B * (i + 1);
                        K(t + r + a, t + n + a, t + n + c, t + r + c)
                    }
                }
            }
            function J(e, t, r) {
                o.push(e),
                o.push(t),
                o.push(r)
            }
            function Z(e, t, i) {
                Q(e),
                Q(t),
                Q(i);
                var o = n.length / 3
                  , a = f.generateTopUV(r, n, o - 3, o - 2, o - 1);
                $(a[0]),
                $(a[1]),
                $(a[2])
            }
            function K(e, t, i, o) {
                Q(e),
                Q(t),
                Q(o),
                Q(t),
                Q(i),
                Q(o);
                var a = n.length / 3
                  , s = f.generateSideWallUV(r, n, a - 6, a - 3, a - 2, a - 1);
                $(s[0]),
                $(s[1]),
                $(s[3]),
                $(s[1]),
                $(s[2]),
                $(s[3])
            }
            function Q(e) {
                n.push(o[3 * e + 0]),
                n.push(o[3 * e + 1]),
                n.push(o[3 * e + 2])
            }
            function $(e) {
                i.push(e.x),
                i.push(e.y)
            }
            !function() {
                var e = n.length / 3;
                if (l) {
                    var t = 0
                      , i = B * t;
                    for (j = 0; j < z; j++)
                        Z((D = A[j])[2] + i, D[1] + i, D[0] + i);
                    for (i = B * (t = s + 2 * p),
                    j = 0; j < z; j++)
                        Z((D = A[j])[0] + i, D[1] + i, D[2] + i)
                } else {
                    for (j = 0; j < z; j++)
                        Z((D = A[j])[2], D[1], D[0]);
                    for (j = 0; j < z; j++)
                        Z((D = A[j])[0] + B * s, D[1] + B * s, D[2] + B * s)
                }
                r.addGroup(e, n.length / 3 - e, 0)
            }(),
            function() {
                var e = n.length / 3
                  , t = 0;
                for (Y(L, t),
                t += L.length,
                w = 0,
                _ = T.length; w < _; w++)
                    Y(x = T[w], t),
                    t += x.length;
                r.addGroup(e, n.length / 3 - e, 1)
            }()
        }
        this.addAttribute("position", new fr(n,3)),
        this.addAttribute("uv", new fr(i,2)),
        this.computeVertexNormals()
    }
    mo.prototype = Object.create(or.prototype),
    mo.prototype.constructor = mo,
    mo.prototype.toJSON = function() {
        var e = or.prototype.toJSON.call(this);
        return yo(this.parameters.shapes, this.parameters.options, e)
    }
    ,
    vo.prototype = Object.create(br.prototype),
    vo.prototype.constructor = vo,
    vo.prototype.toJSON = function() {
        var e = br.prototype.toJSON.call(this);
        return yo(this.parameters.shapes, this.parameters.options, e)
    }
    ;
    var go = {
        generateTopUV: function(e, t, r, n, i) {
            var o = t[3 * r]
              , a = t[3 * r + 1]
              , s = t[3 * n]
              , c = t[3 * n + 1]
              , l = t[3 * i]
              , u = t[3 * i + 1];
            return [new Tt(o,a), new Tt(s,c), new Tt(l,u)]
        },
        generateSideWallUV: function(e, t, r, n, i, o) {
            var a = t[3 * r]
              , s = t[3 * r + 1]
              , c = t[3 * r + 2]
              , l = t[3 * n]
              , u = t[3 * n + 1]
              , h = t[3 * n + 2]
              , p = t[3 * i]
              , d = t[3 * i + 1]
              , f = t[3 * i + 2]
              , m = t[3 * o]
              , v = t[3 * o + 1]
              , g = t[3 * o + 2];
            return Math.abs(s - u) < .01 ? [new Tt(a,1 - c), new Tt(l,1 - h), new Tt(p,1 - f), new Tt(m,1 - g)] : [new Tt(s,1 - c), new Tt(u,1 - h), new Tt(d,1 - f), new Tt(v,1 - g)]
        }
    };
    function yo(e, t, r) {
        if (r.shapes = [],
        Array.isArray(e))
            for (var n = 0, i = e.length; n < i; n++) {
                var o = e[n];
                r.shapes.push(o.uuid)
            }
        else
            r.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (r.options.extrudePath = t.extrudePath.toJSON()),
        r
    }
    function bo(e, t) {
        or.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: e,
            parameters: t
        },
        this.fromBufferGeometry(new xo(e,t)),
        this.mergeVertices()
    }
    function xo(e, t) {
        var r = (t = t || {}).font;
        if (!r || !r.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
            new or;
        var n = r.generateShapes(e, t.size);
        t.depth = void 0 !== t.height ? t.height : 50,
        void 0 === t.bevelThickness && (t.bevelThickness = 10),
        void 0 === t.bevelSize && (t.bevelSize = 8),
        void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
        vo.call(this, n, t),
        this.type = "TextBufferGeometry"
    }
    function wo(e, t, r, n, i, o, a) {
        or.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: n,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        },
        this.fromBufferGeometry(new _o(e,t,r,n,i,o,a)),
        this.mergeVertices()
    }
    function _o(e, t, r, n, i, o, a) {
        br.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: n,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        },
        e = e || 1,
        t = Math.max(3, Math.floor(t) || 8),
        r = Math.max(2, Math.floor(r) || 6),
        n = void 0 !== n ? n : 0,
        i = void 0 !== i ? i : 2 * Math.PI;
        var s, c, l = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI), u = 0, h = [], p = new Pt, d = new Pt, f = [], m = [], v = [], g = [];
        for (c = 0; c <= r; c++) {
            var y = []
              , b = c / r;
            for (s = 0; s <= t; s++) {
                var x = s / t;
                p.x = -e * Math.cos(n + x * i) * Math.sin(o + b * a),
                p.y = e * Math.cos(o + b * a),
                p.z = e * Math.sin(n + x * i) * Math.sin(o + b * a),
                m.push(p.x, p.y, p.z),
                d.set(p.x, p.y, p.z).normalize(),
                v.push(d.x, d.y, d.z),
                g.push(x, 1 - b),
                y.push(u++)
            }
            h.push(y)
        }
        for (c = 0; c < r; c++)
            for (s = 0; s < t; s++) {
                var w = h[c][s + 1]
                  , _ = h[c][s]
                  , M = h[c + 1][s]
                  , S = h[c + 1][s + 1];
                (0 !== c || o > 0) && f.push(w, _, S),
                (c !== r - 1 || l < Math.PI) && f.push(_, M, S)
            }
        this.setIndex(f),
        this.addAttribute("position", new fr(m,3)),
        this.addAttribute("normal", new fr(v,3)),
        this.addAttribute("uv", new fr(g,2))
    }
    function Mo(e, t, r, n, i, o) {
        or.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: n,
            thetaStart: i,
            thetaLength: o
        },
        this.fromBufferGeometry(new So(e,t,r,n,i,o)),
        this.mergeVertices()
    }
    function So(e, t, r, n, i, o) {
        br.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: r,
            phiSegments: n,
            thetaStart: i,
            thetaLength: o
        },
        e = e || .5,
        t = t || 1,
        i = void 0 !== i ? i : 0,
        o = void 0 !== o ? o : 2 * Math.PI,
        r = void 0 !== r ? Math.max(3, r) : 8;
        var a, s, c, l = [], u = [], h = [], p = [], d = e, f = (t - e) / (n = void 0 !== n ? Math.max(1, n) : 1), m = new Pt, v = new Tt;
        for (s = 0; s <= n; s++) {
            for (c = 0; c <= r; c++)
                a = i + c / r * o,
                m.x = d * Math.cos(a),
                m.y = d * Math.sin(a),
                u.push(m.x, m.y, m.z),
                h.push(0, 0, 1),
                v.x = (m.x / t + 1) / 2,
                v.y = (m.y / t + 1) / 2,
                p.push(v.x, v.y);
            d += f
        }
        for (s = 0; s < n; s++) {
            var g = s * (r + 1);
            for (c = 0; c < r; c++) {
                var y = a = c + g
                  , b = a + r + 1
                  , x = a + r + 2
                  , w = a + 1;
                l.push(y, b, w),
                l.push(b, x, w)
            }
        }
        this.setIndex(l),
        this.addAttribute("position", new fr(u,3)),
        this.addAttribute("normal", new fr(h,3)),
        this.addAttribute("uv", new fr(p,2))
    }
    function Eo(e, t, r, n) {
        or.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: r,
            phiLength: n
        },
        this.fromBufferGeometry(new To(e,t,r,n)),
        this.mergeVertices()
    }
    function To(e, t, r, n) {
        br.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: r,
            phiLength: n
        },
        t = Math.floor(t) || 12,
        r = r || 0,
        n = n || 2 * Math.PI,
        n = Et.clamp(n, 0, 2 * Math.PI);
        var i, o, a, s = [], c = [], l = [], u = 1 / t, h = new Pt, p = new Tt;
        for (o = 0; o <= t; o++) {
            var d = r + o * u * n
              , f = Math.sin(d)
              , m = Math.cos(d);
            for (a = 0; a <= e.length - 1; a++)
                h.x = e[a].x * f,
                h.y = e[a].y,
                h.z = e[a].x * m,
                c.push(h.x, h.y, h.z),
                p.x = o / t,
                p.y = a / (e.length - 1),
                l.push(p.x, p.y)
        }
        for (o = 0; o < t; o++)
            for (a = 0; a < e.length - 1; a++) {
                var v = i = a + o * e.length
                  , g = i + e.length
                  , y = i + e.length + 1
                  , b = i + 1;
                s.push(v, g, b),
                s.push(g, y, b)
            }
        if (this.setIndex(s),
        this.addAttribute("position", new fr(c,3)),
        this.addAttribute("uv", new fr(l,2)),
        this.computeVertexNormals(),
        n === 2 * Math.PI) {
            var x = this.attributes.normal.array
              , w = new Pt
              , _ = new Pt
              , M = new Pt;
            for (i = t * e.length * 3,
            o = 0,
            a = 0; o < e.length; o++,
            a += 3)
                w.x = x[a + 0],
                w.y = x[a + 1],
                w.z = x[a + 2],
                _.x = x[i + a + 0],
                _.y = x[i + a + 1],
                _.z = x[i + a + 2],
                M.addVectors(w, _).normalize(),
                x[a + 0] = x[i + a + 0] = M.x,
                x[a + 1] = x[i + a + 1] = M.y,
                x[a + 2] = x[i + a + 2] = M.z
        }
    }
    function Ao(e, t) {
        or.call(this),
        this.type = "ShapeGeometry",
        "object" === (void 0 === t ? "undefined" : n(t)) && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        t = t.curveSegments),
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        this.fromBufferGeometry(new Lo(e,t)),
        this.mergeVertices()
    }
    function Lo(e, t) {
        br.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        t = t || 12;
        var r = []
          , n = []
          , i = []
          , o = []
          , a = 0
          , s = 0;
        if (!1 === Array.isArray(e))
            l(e);
        else
            for (var c = 0; c < e.length; c++)
                l(e[c]),
                this.addGroup(a, s, c),
                a += s,
                s = 0;
        function l(e) {
            var a, c, l, u = n.length / 3, h = e.extractPoints(t), p = h.shape, d = h.holes;
            for (!1 === ho.isClockWise(p) && (p = p.reverse()),
            a = 0,
            c = d.length; a < c; a++)
                l = d[a],
                !0 === ho.isClockWise(l) && (d[a] = l.reverse());
            var f = ho.triangulateShape(p, d);
            for (a = 0,
            c = d.length; a < c; a++)
                l = d[a],
                p = p.concat(l);
            for (a = 0,
            c = p.length; a < c; a++) {
                var m = p[a];
                n.push(m.x, m.y, 0),
                i.push(0, 0, 1),
                o.push(m.x, m.y)
            }
            for (a = 0,
            c = f.length; a < c; a++) {
                var v = f[a]
                  , g = v[0] + u
                  , y = v[1] + u
                  , b = v[2] + u;
                r.push(g, y, b),
                s += 3
            }
        }
        this.setIndex(r),
        this.addAttribute("position", new fr(n,3)),
        this.addAttribute("normal", new fr(i,3)),
        this.addAttribute("uv", new fr(o,2))
    }
    function Po(e, t) {
        if (t.shapes = [],
        Array.isArray(e))
            for (var r = 0, n = e.length; r < n; r++) {
                var i = e[r];
                t.shapes.push(i.uuid)
            }
        else
            t.shapes.push(e.uuid);
        return t
    }
    function Co(e, t) {
        br.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: t
        },
        t = void 0 !== t ? t : 1;
        var r, n, i, o, a = [], s = Math.cos(Et.DEG2RAD * t), c = [0, 0], l = {}, u = ["a", "b", "c"];
        e.isBufferGeometry ? (o = new or).fromBufferGeometry(e) : o = e.clone(),
        o.mergeVertices(),
        o.computeFaceNormals();
        for (var h = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
            for (var m = p[d], v = 0; v < 3; v++)
                r = m[u[v]],
                n = m[u[(v + 1) % 3]],
                c[0] = Math.min(r, n),
                c[1] = Math.max(r, n),
                void 0 === l[i = c[0] + "," + c[1]] ? l[i] = {
                    index1: c[0],
                    index2: c[1],
                    face1: d,
                    face2: void 0
                } : l[i].face2 = d;
        for (i in l) {
            var g = l[i];
            if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) {
                var y = h[g.index1];
                a.push(y.x, y.y, y.z),
                y = h[g.index2],
                a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new fr(a,3))
    }
    function Ro(e, t, r, n, i, o, a, s) {
        or.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: n,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        },
        this.fromBufferGeometry(new Oo(e,t,r,n,i,o,a,s)),
        this.mergeVertices()
    }
    function Oo(e, t, r, n, i, o, a, s) {
        br.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: n,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        };
        var c = this;
        e = void 0 !== e ? e : 1,
        t = void 0 !== t ? t : 1,
        r = r || 1,
        n = Math.floor(n) || 8,
        i = Math.floor(i) || 1,
        o = void 0 !== o && o,
        a = void 0 !== a ? a : 0,
        s = void 0 !== s ? s : 2 * Math.PI;
        var l = []
          , u = []
          , h = []
          , p = []
          , d = 0
          , f = []
          , m = r / 2
          , v = 0;
        function g(r) {
            var i, o, f, g = new Tt, y = new Pt, b = 0, x = !0 === r ? e : t, w = !0 === r ? 1 : -1;
            for (o = d,
            i = 1; i <= n; i++)
                u.push(0, m * w, 0),
                h.push(0, w, 0),
                p.push(.5, .5),
                d++;
            for (f = d,
            i = 0; i <= n; i++) {
                var _ = i / n * s + a
                  , M = Math.cos(_)
                  , S = Math.sin(_);
                y.x = x * S,
                y.y = m * w,
                y.z = x * M,
                u.push(y.x, y.y, y.z),
                h.push(0, w, 0),
                g.x = .5 * M + .5,
                g.y = .5 * S * w + .5,
                p.push(g.x, g.y),
                d++
            }
            for (i = 0; i < n; i++) {
                var E = o + i
                  , T = f + i;
                !0 === r ? l.push(T, T + 1, E) : l.push(T + 1, T, E),
                b += 3
            }
            c.addGroup(v, b, !0 === r ? 1 : 2),
            v += b
        }
        !function() {
            var o, g, y = new Pt, b = new Pt, x = 0, w = (t - e) / r;
            for (g = 0; g <= i; g++) {
                var _ = []
                  , M = g / i
                  , S = M * (t - e) + e;
                for (o = 0; o <= n; o++) {
                    var E = o / n
                      , T = E * s + a
                      , A = Math.sin(T)
                      , L = Math.cos(T);
                    b.x = S * A,
                    b.y = -M * r + m,
                    b.z = S * L,
                    u.push(b.x, b.y, b.z),
                    y.set(A, w, L).normalize(),
                    h.push(y.x, y.y, y.z),
                    p.push(E, 1 - M),
                    _.push(d++)
                }
                f.push(_)
            }
            for (o = 0; o < n; o++)
                for (g = 0; g < i; g++) {
                    var P = f[g][o]
                      , C = f[g + 1][o]
                      , R = f[g + 1][o + 1]
                      , O = f[g][o + 1];
                    l.push(P, C, O),
                    l.push(C, R, O),
                    x += 6
                }
            c.addGroup(v, x, 0),
            v += x
        }(),
        !1 === o && (e > 0 && g(!0),
        t > 0 && g(!1)),
        this.setIndex(l),
        this.addAttribute("position", new fr(u,3)),
        this.addAttribute("normal", new fr(h,3)),
        this.addAttribute("uv", new fr(p,2))
    }
    function Io(e, t, r, n, i, o, a) {
        Ro.call(this, 0, e, t, r, n, i, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: n,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }
    function No(e, t, r, n, i, o, a) {
        Oo.call(this, 0, e, t, r, n, i, o, a),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: r,
            heightSegments: n,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }
    function Do(e, t, r, n) {
        or.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: r,
            thetaLength: n
        },
        this.fromBufferGeometry(new Bo(e,t,r,n)),
        this.mergeVertices()
    }
    function Bo(e, t, r, n) {
        br.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: r,
            thetaLength: n
        },
        e = e || 1,
        t = void 0 !== t ? Math.max(3, t) : 8,
        r = void 0 !== r ? r : 0,
        n = void 0 !== n ? n : 2 * Math.PI;
        var i, o, a = [], s = [], c = [], l = [], u = new Pt, h = new Tt;
        for (s.push(0, 0, 0),
        c.push(0, 0, 1),
        l.push(.5, .5),
        o = 0,
        i = 3; o <= t; o++,
        i += 3) {
            var p = r + o / t * n;
            u.x = e * Math.cos(p),
            u.y = e * Math.sin(p),
            s.push(u.x, u.y, u.z),
            c.push(0, 0, 1),
            h.x = (s[i] / e + 1) / 2,
            h.y = (s[i + 1] / e + 1) / 2,
            l.push(h.x, h.y)
        }
        for (i = 1; i <= t; i++)
            a.push(i, i + 1, 0);
        this.setIndex(a),
        this.addAttribute("position", new fr(s,3)),
        this.addAttribute("normal", new fr(c,3)),
        this.addAttribute("uv", new fr(l,2))
    }
    bo.prototype = Object.create(or.prototype),
    bo.prototype.constructor = bo,
    xo.prototype = Object.create(vo.prototype),
    xo.prototype.constructor = xo,
    wo.prototype = Object.create(or.prototype),
    wo.prototype.constructor = wo,
    _o.prototype = Object.create(br.prototype),
    _o.prototype.constructor = _o,
    Mo.prototype = Object.create(or.prototype),
    Mo.prototype.constructor = Mo,
    So.prototype = Object.create(br.prototype),
    So.prototype.constructor = So,
    Eo.prototype = Object.create(or.prototype),
    Eo.prototype.constructor = Eo,
    To.prototype = Object.create(br.prototype),
    To.prototype.constructor = To,
    Ao.prototype = Object.create(or.prototype),
    Ao.prototype.constructor = Ao,
    Ao.prototype.toJSON = function() {
        var e = or.prototype.toJSON.call(this);
        return Po(this.parameters.shapes, e)
    }
    ,
    Lo.prototype = Object.create(br.prototype),
    Lo.prototype.constructor = Lo,
    Lo.prototype.toJSON = function() {
        var e = br.prototype.toJSON.call(this);
        return Po(this.parameters.shapes, e)
    }
    ,
    Co.prototype = Object.create(br.prototype),
    Co.prototype.constructor = Co,
    Ro.prototype = Object.create(or.prototype),
    Ro.prototype.constructor = Ro,
    Oo.prototype = Object.create(br.prototype),
    Oo.prototype.constructor = Oo,
    Io.prototype = Object.create(Ro.prototype),
    Io.prototype.constructor = Io,
    No.prototype = Object.create(Oo.prototype),
    No.prototype.constructor = No,
    Do.prototype = Object.create(or.prototype),
    Do.prototype.constructor = Do,
    Bo.prototype = Object.create(br.prototype),
    Bo.prototype.constructor = Bo;
    var zo = Object.freeze({
        WireframeGeometry: Si,
        ParametricGeometry: Ei,
        ParametricBufferGeometry: Ti,
        TetrahedronGeometry: Pi,
        TetrahedronBufferGeometry: Ci,
        OctahedronGeometry: Ri,
        OctahedronBufferGeometry: Oi,
        IcosahedronGeometry: Ii,
        IcosahedronBufferGeometry: Ni,
        DodecahedronGeometry: Di,
        DodecahedronBufferGeometry: Bi,
        PolyhedronGeometry: Ai,
        PolyhedronBufferGeometry: Li,
        TubeGeometry: zi,
        TubeBufferGeometry: Gi,
        TorusKnotGeometry: Ui,
        TorusKnotBufferGeometry: ji,
        TorusGeometry: Fi,
        TorusBufferGeometry: ki,
        TextGeometry: bo,
        TextBufferGeometry: xo,
        SphereGeometry: wo,
        SphereBufferGeometry: _o,
        RingGeometry: Mo,
        RingBufferGeometry: So,
        PlaneGeometry: _r,
        PlaneBufferGeometry: Mr,
        LatheGeometry: Eo,
        LatheBufferGeometry: To,
        ShapeGeometry: Ao,
        ShapeBufferGeometry: Lo,
        ExtrudeGeometry: mo,
        ExtrudeBufferGeometry: vo,
        EdgesGeometry: Co,
        ConeGeometry: Io,
        ConeBufferGeometry: No,
        CylinderGeometry: Ro,
        CylinderBufferGeometry: Oo,
        CircleGeometry: Do,
        CircleBufferGeometry: Bo,
        BoxGeometry: xr,
        BoxBufferGeometry: wr
    });
    function Go(e) {
        Er.call(this),
        this.type = "ShadowMaterial",
        this.color = new Yt(0),
        this.transparent = !0,
        this.setValues(e)
    }
    function Uo(e) {
        Tr.call(this, e),
        this.type = "RawShaderMaterial"
    }
    function jo(e) {
        Er.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Yt(16777215),
        this.roughness = .5,
        this.metalness = .5,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Yt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Mt,
        this.normalScale = new Tt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Fo(e) {
        jo.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoat = 0,
        this.clearCoatRoughness = 0,
        this.setValues(e)
    }
    function ko(e) {
        Er.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new Yt(16777215),
        this.specular = new Yt(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Yt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Mt,
        this.normalScale = new Tt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Y,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Ho(e) {
        ko.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.gradientMap = null,
        this.setValues(e)
    }
    function Vo(e) {
        Er.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Mt,
        this.normalScale = new Tt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Wo(e) {
        Er.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new Yt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Yt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Y,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function qo(e) {
        Er.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Yt(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Mt,
        this.normalScale = new Tt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Xo(e) {
        fi.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    Go.prototype = Object.create(Er.prototype),
    Go.prototype.constructor = Go,
    Go.prototype.isShadowMaterial = !0,
    Go.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this
    }
    ,
    Uo.prototype = Object.create(Tr.prototype),
    Uo.prototype.constructor = Uo,
    Uo.prototype.isRawShaderMaterial = !0,
    jo.prototype = Object.create(Er.prototype),
    jo.prototype.constructor = jo,
    jo.prototype.isMeshStandardMaterial = !0,
    jo.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Fo.prototype = Object.create(jo.prototype),
    Fo.prototype.constructor = Fo,
    Fo.prototype.isMeshPhysicalMaterial = !0,
    Fo.prototype.copy = function(e) {
        return jo.prototype.copy.call(this, e),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = e.reflectivity,
        this.clearCoat = e.clearCoat,
        this.clearCoatRoughness = e.clearCoatRoughness,
        this
    }
    ,
    ko.prototype = Object.create(Er.prototype),
    ko.prototype.constructor = ko,
    ko.prototype.isMeshPhongMaterial = !0,
    ko.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Ho.prototype = Object.create(ko.prototype),
    Ho.prototype.constructor = Ho,
    Ho.prototype.isMeshToonMaterial = !0,
    Ho.prototype.copy = function(e) {
        return ko.prototype.copy.call(this, e),
        this.gradientMap = e.gradientMap,
        this
    }
    ,
    Vo.prototype = Object.create(Er.prototype),
    Vo.prototype.constructor = Vo,
    Vo.prototype.isMeshNormalMaterial = !0,
    Vo.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Wo.prototype = Object.create(Er.prototype),
    Wo.prototype.constructor = Wo,
    Wo.prototype.isMeshLambertMaterial = !0,
    Wo.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    qo.prototype = Object.create(Er.prototype),
    qo.prototype.constructor = qo,
    qo.prototype.isMeshMatcapMaterial = !0,
    qo.prototype.copy = function(e) {
        return Er.prototype.copy.call(this, e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Xo.prototype = Object.create(fi.prototype),
    Xo.prototype.constructor = Xo,
    Xo.prototype.isLineDashedMaterial = !0,
    Xo.prototype.copy = function(e) {
        return fi.prototype.copy.call(this, e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
    ;
    var Yo = Object.freeze({
        ShadowMaterial: Go,
        SpriteMaterial: ci,
        RawShaderMaterial: Uo,
        ShaderMaterial: Tr,
        PointsMaterial: yi,
        MeshPhysicalMaterial: Fo,
        MeshStandardMaterial: jo,
        MeshPhongMaterial: ko,
        MeshToonMaterial: Ho,
        MeshNormalMaterial: Vo,
        MeshLambertMaterial: Wo,
        MeshDepthMaterial: kn,
        MeshDistanceMaterial: Hn,
        MeshBasicMaterial: Pr,
        MeshMatcapMaterial: qo,
        LineDashedMaterial: Xo,
        LineBasicMaterial: fi,
        Material: Er
    })
      , Jo = {
        arraySlice: function(e, t, r) {
            return Jo.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== r ? r : e.length)) : e.slice(t, r)
        },
        convertArray: function(e, t, r) {
            return !e || !r && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        },
        isTypedArray: function(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        },
        getKeyframeOrder: function(e) {
            for (var t = e.length, r = new Array(t), n = 0; n !== t; ++n)
                r[n] = n;
            return r.sort(function(t, r) {
                return e[t] - e[r]
            }),
            r
        },
        sortedArray: function(e, t, r) {
            for (var n = e.length, i = new e.constructor(n), o = 0, a = 0; a !== n; ++o)
                for (var s = r[o] * t, c = 0; c !== t; ++c)
                    i[a++] = e[s + c];
            return i
        },
        flattenJSON: function(e, t, r, n) {
            for (var i = 1, o = e[0]; void 0 !== o && void 0 === o[n]; )
                o = e[i++];
            if (void 0 !== o) {
                var a = o[n];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            void 0 !== (a = o[n]) && (t.push(o.time),
                            r.push.apply(r, a)),
                            o = e[i++]
                        } while (void 0 !== o);
                    else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[n]) && (t.push(o.time),
                            a.toArray(r, r.length)),
                            o = e[i++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[n]) && (t.push(o.time),
                            r.push(a)),
                            o = e[i++]
                        } while (void 0 !== o)
            }
        }
    };
    function Zo(e, t, r, n) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== n ? n : new t.constructor(r),
        this.sampleValues = t,
        this.valueSize = r
    }
    function Ko(e, t, r, n) {
        Zo.call(this, e, t, r, n),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function Qo(e, t, r, n) {
        Zo.call(this, e, t, r, n)
    }
    function $o(e, t, r, n) {
        Zo.call(this, e, t, r, n)
    }
    function ea(e, t, r, n) {
        if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Jo.convertArray(t, this.TimeBufferType),
        this.values = Jo.convertArray(r, this.ValueBufferType),
        this.setInterpolation(n || this.DefaultInterpolation)
    }
    function ta(e, t, r) {
        ea.call(this, e, t, r)
    }
    function ra(e, t, r, n) {
        ea.call(this, e, t, r, n)
    }
    function na(e, t, r, n) {
        ea.call(this, e, t, r, n)
    }
    function ia(e, t, r, n) {
        Zo.call(this, e, t, r, n)
    }
    function oa(e, t, r, n) {
        ea.call(this, e, t, r, n)
    }
    function aa(e, t, r, n) {
        ea.call(this, e, t, r, n)
    }
    function sa(e, t, r, n) {
        ea.call(this, e, t, r, n)
    }
    function ca(e, t, r) {
        this.name = e,
        this.tracks = r,
        this.duration = void 0 !== t ? t : -1,
        this.uuid = Et.generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    function la(e) {
        if (void 0 === e.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function(e) {
            switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return na;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return sa;
            case "color":
                return ra;
            case "quaternion":
                return oa;
            case "bool":
            case "boolean":
                return ta;
            case "string":
                return aa
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var r = []
              , n = [];
            Jo.flattenJSON(e.keys, r, n, "value"),
            e.times = r,
            e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
    }
    Object.assign(Zo.prototype, {
        evaluate: function(e) {
            var t = this.parameterPositions
              , r = this._cachedIndex
              , n = t[r]
              , i = t[r - 1];
            e: {
                t: {
                    var o;
                    r: {
                        n: if (!(e < n)) {
                            for (var a = r + 2; ; ) {
                                if (void 0 === n) {
                                    if (e < i)
                                        break n;
                                    return r = t.length,
                                    this._cachedIndex = r,
                                    this.afterEnd_(r - 1, e, i)
                                }
                                if (r === a)
                                    break;
                                if (i = n,
                                e < (n = t[++r]))
                                    break t
                            }
                            o = t.length;
                            break r
                        }
                        if (e >= i)
                            break e;
                        var s = t[1];
                        e < s && (r = 2,
                        i = s);
                        for (a = r - 2; ; ) {
                            if (void 0 === i)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, e, n);
                            if (r === a)
                                break;
                            if (n = i,
                            e >= (i = t[--r - 1]))
                                break t
                        }
                        o = r,
                        r = 0
                    }
                    for (; r < o; ) {
                        var c = r + o >>> 1;
                        e < t[c] ? o = c : r = c + 1
                    }
                    if (n = t[r],
                    void 0 === (i = t[r - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, e, n);
                    if (void 0 === n)
                        return r = t.length,
                        this._cachedIndex = r,
                        this.afterEnd_(r - 1, i, e)
                }
                this._cachedIndex = r,
                this.intervalChanged_(r, i, n)
            }
            return this.interpolate_(r, i, e, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            for (var t = this.resultBuffer, r = this.sampleValues, n = this.valueSize, i = e * n, o = 0; o !== n; ++o)
                t[o] = r[i + o];
            return t
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(Zo.prototype, {
        beforeStart_: Zo.prototype.copySampleValue_,
        afterEnd_: Zo.prototype.copySampleValue_
    }),
    Ko.prototype = Object.assign(Object.create(Zo.prototype), {
        constructor: Ko,
        DefaultSettings_: {
            endingStart: ut,
            endingEnd: ut
        },
        intervalChanged_: function(e, t, r) {
            var n = this.parameterPositions
              , i = e - 2
              , o = e + 1
              , a = n[i]
              , s = n[o];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    i = e,
                    a = 2 * t - r;
                    break;
                case 2402:
                    a = t + n[i = n.length - 2] - n[i + 1];
                    break;
                default:
                    i = e,
                    a = r
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = e,
                    s = 2 * r - t;
                    break;
                case 2402:
                    o = 1,
                    s = r + n[1] - n[0];
                    break;
                default:
                    o = e - 1,
                    s = t
                }
            var c = .5 * (r - t)
              , l = this.valueSize;
            this._weightPrev = c / (t - a),
            this._weightNext = c / (s - r),
            this._offsetPrev = i * l,
            this._offsetNext = o * l
        },
        interpolate_: function(e, t, r, n) {
            for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, p = this._weightNext, d = (r - t) / (n - t), f = d * d, m = f * d, v = -h * m + 2 * h * f - h * d, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, b = p * m - p * f, x = 0; x !== a; ++x)
                i[x] = v * o[l + x] + g * o[c + x] + y * o[s + x] + b * o[u + x];
            return i
        }
    }),
    Qo.prototype = Object.assign(Object.create(Zo.prototype), {
        constructor: Qo,
        interpolate_: function(e, t, r, n) {
            for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = s - a, l = (r - t) / (n - t), u = 1 - l, h = 0; h !== a; ++h)
                i[h] = o[c + h] * u + o[s + h] * l;
            return i
        }
    }),
    $o.prototype = Object.assign(Object.create(Zo.prototype), {
        constructor: $o,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }),
    Object.assign(ea, {
        toJSON: function(e) {
            var t, r = e.constructor;
            if (void 0 !== r.toJSON)
                t = r.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: Jo.convertArray(e.times, Array),
                    values: Jo.convertArray(e.values, Array)
                };
                var n = e.getInterpolation();
                n !== e.DefaultInterpolation && (t.interpolation = n)
            }
            return t.type = e.ValueTypeName,
            t
        }
    }),
    Object.assign(ea.prototype, {
        constructor: ea,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new $o(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new Qo(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new Ko(this.times,this.values,this.getValueSize(),e)
        },
        setInterpolation: function(e) {
            var t;
            switch (e) {
            case 2300:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                var r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation)
                        throw new Error(r);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", r),
                this
            }
            return this.createInterpolant = t,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, r = 0, n = t.length; r !== n; ++r)
                    t[r] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, r = 0, n = t.length; r !== n; ++r)
                    t[r] *= e;
            return this
        },
        trim: function(e, t) {
            for (var r = this.times, n = r.length, i = 0, o = n - 1; i !== n && r[i] < e; )
                ++i;
            for (; -1 !== o && r[o] > t; )
                --o;
            if (++o,
            0 !== i || o !== n) {
                i >= o && (i = (o = Math.max(o, 1)) - 1);
                var a = this.getValueSize();
                this.times = Jo.arraySlice(r, i, o),
                this.values = Jo.arraySlice(this.values, i * a, o * a)
            }
            return this
        },
        validate: function() {
            var e = !0
              , t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            e = !1);
            var r = this.times
              , n = this.values
              , i = r.length;
            0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            e = !1);
            for (var o = null, a = 0; a !== i; a++) {
                var s = r[a];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s),
                    e = !1;
                    break
                }
                if (null !== o && o > s) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o),
                    e = !1;
                    break
                }
                o = s
            }
            if (void 0 !== n && Jo.isTypedArray(n)) {
                a = 0;
                for (var c = n.length; a !== c; ++a) {
                    var l = n[a];
                    if (isNaN(l)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l),
                        e = !1;
                        break
                    }
                }
            }
            return e
        },
        optimize: function() {
            for (var e = this.times, t = this.values, r = this.getValueSize(), n = 2302 === this.getInterpolation(), i = 1, o = e.length - 1, a = 1; a < o; ++a) {
                var s = !1
                  , c = e[a];
                if (c !== e[a + 1] && (1 !== a || c !== c[0]))
                    if (n)
                        s = !0;
                    else
                        for (var l = a * r, u = l - r, h = l + r, p = 0; p !== r; ++p) {
                            var d = t[l + p];
                            if (d !== t[u + p] || d !== t[h + p]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (a !== i) {
                        e[i] = e[a];
                        var f = a * r
                          , m = i * r;
                        for (p = 0; p !== r; ++p)
                            t[m + p] = t[f + p]
                    }
                    ++i
                }
            }
            if (o > 0) {
                e[i] = e[o];
                for (f = o * r,
                m = i * r,
                p = 0; p !== r; ++p)
                    t[m + p] = t[f + p];
                ++i
            }
            return i !== e.length && (this.times = Jo.arraySlice(e, 0, i),
            this.values = Jo.arraySlice(t, 0, i * r)),
            this
        },
        clone: function() {
            var e = Jo.arraySlice(this.times, 0)
              , t = Jo.arraySlice(this.values, 0)
              , r = new (0,
            this.constructor)(this.name,e,t);
            return r.createInterpolant = this.createInterpolant,
            r
        }
    }),
    ta.prototype = Object.assign(Object.create(ea.prototype), {
        constructor: ta,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    ra.prototype = Object.assign(Object.create(ea.prototype), {
        constructor: ra,
        ValueTypeName: "color"
    }),
    na.prototype = Object.assign(Object.create(ea.prototype), {
        constructor: na,
        ValueTypeName: "number"
    }),
    ia.prototype = Object.assign(Object.create(Zo.prototype), {
        constructor: ia,
        interpolate_: function(e, t, r, n) {
            for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, c = (r - t) / (n - t), l = s + a; s !== l; s += 4)
                Lt.slerpFlat(i, 0, o, s - a, o, s, c);
            return i
        }
    }),
    oa.prototype = Object.assign(Object.create(ea.prototype), {
        constructor: oa,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(e) {
            return new ia(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    aa.prototype = Object.assign(Object.create(ea.prototype), {
        constructor: aa,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    sa.prototype = Object.assign(Object.create(ea.prototype), {
        constructor: sa,
        ValueTypeName: "vector"
    }),
    Object.assign(ca, {
        parse: function(e) {
            for (var t = [], r = e.tracks, n = 1 / (e.fps || 1), i = 0, o = r.length; i !== o; ++i)
                t.push(la(r[i]).scale(n));
            return new ca(e.name,e.duration,t)
        },
        toJSON: function(e) {
            for (var t = [], r = e.tracks, n = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid
            }, i = 0, o = r.length; i !== o; ++i)
                t.push(ea.toJSON(r[i]));
            return n
        },
        CreateFromMorphTargetSequence: function(e, t, r, n) {
            for (var i = t.length, o = [], a = 0; a < i; a++) {
                var s = []
                  , c = [];
                s.push((a + i - 1) % i, a, (a + 1) % i),
                c.push(0, 1, 0);
                var l = Jo.getKeyframeOrder(s);
                s = Jo.sortedArray(s, 1, l),
                c = Jo.sortedArray(c, 1, l),
                n || 0 !== s[0] || (s.push(i),
                c.push(c[0])),
                o.push(new na(".morphTargetInfluences[" + t[a].name + "]",s,c).scale(1 / r))
            }
            return new ca(e,-1,o)
        },
        findByName: function(e, t) {
            var r = e;
            if (!Array.isArray(e)) {
                var n = e;
                r = n.geometry && n.geometry.animations || n.animations
            }
            for (var i = 0; i < r.length; i++)
                if (r[i].name === t)
                    return r[i];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, r) {
            for (var n = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; o < a; o++) {
                var s = e[o]
                  , c = s.name.match(i);
                if (c && c.length > 1) {
                    var l = n[h = c[1]];
                    l || (n[h] = l = []),
                    l.push(s)
                }
            }
            var u = [];
            for (var h in n)
                u.push(ca.CreateFromMorphTargetSequence(h, n[h], t, r));
            return u
        },
        parseAnimation: function(e, t) {
            if (!e)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            for (var r = function(e, t, r, n, i) {
                if (0 !== r.length) {
                    var o = []
                      , a = [];
                    Jo.flattenJSON(r, o, a, n),
                    0 !== o.length && i.push(new e(t,o,a))
                }
            }, n = [], i = e.name || "default", o = e.length || -1, a = e.fps || 30, s = e.hierarchy || [], c = 0; c < s.length; c++) {
                var l = s[c].keys;
                if (l && 0 !== l.length)
                    if (l[0].morphTargets) {
                        for (var u = {}, h = 0; h < l.length; h++)
                            if (l[h].morphTargets)
                                for (var p = 0; p < l[h].morphTargets.length; p++)
                                    u[l[h].morphTargets[p]] = -1;
                        for (var d in u) {
                            var f = []
                              , m = [];
                            for (p = 0; p !== l[h].morphTargets.length; ++p) {
                                var v = l[h];
                                f.push(v.time),
                                m.push(v.morphTarget === d ? 1 : 0)
                            }
                            n.push(new na(".morphTargetInfluence[" + d + "]",f,m))
                        }
                        o = u.length * (a || 1)
                    } else {
                        var g = ".bones[" + t[c].name + "]";
                        r(sa, g + ".position", l, "pos", n),
                        r(oa, g + ".quaternion", l, "rot", n),
                        r(sa, g + ".scale", l, "scl", n)
                    }
            }
            return 0 === n.length ? null : new ca(i,o,n)
        }
    }),
    Object.assign(ca.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, r = this.tracks.length; t !== r; ++t) {
                var n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e,
            this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++)
                e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++)
                e.push(this.tracks[t].clone());
            return new ca(this.name,this.duration,e)
        }
    });
    var ua = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled)
                return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };
    function ha(e, t, r) {
        var n = this
          , i = !1
          , o = 0
          , a = 0
          , s = void 0;
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = r,
        this.itemStart = function(e) {
            a++,
            !1 === i && void 0 !== n.onStart && n.onStart(e, o, a),
            i = !0
        }
        ,
        this.itemEnd = function(e) {
            o++,
            void 0 !== n.onProgress && n.onProgress(e, o, a),
            o === a && (i = !1,
            void 0 !== n.onLoad && n.onLoad())
        }
        ,
        this.itemError = function(e) {
            void 0 !== n.onError && n.onError(e)
        }
        ,
        this.resolveURL = function(e) {
            return s ? s(e) : e
        }
        ,
        this.setURLModifier = function(e) {
            return s = e,
            this
        }
    }
    var pa = new ha
      , da = {};
    function fa(e) {
        this.manager = void 0 !== e ? e : pa
    }
    function ma(e) {
        this.manager = void 0 !== e ? e : pa
    }
    function va(e) {
        this.manager = void 0 !== e ? e : pa,
        this._parser = null
    }
    function ga(e) {
        this.manager = void 0 !== e ? e : pa,
        this._parser = null
    }
    function ya(e) {
        this.manager = void 0 !== e ? e : pa
    }
    function ba(e) {
        this.manager = void 0 !== e ? e : pa
    }
    function xa(e) {
        this.manager = void 0 !== e ? e : pa
    }
    function wa() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function _a(e, t, r, n, i, o, a, s) {
        wa.call(this),
        this.type = "EllipseCurve",
        this.aX = e || 0,
        this.aY = t || 0,
        this.xRadius = r || 1,
        this.yRadius = n || 1,
        this.aStartAngle = i || 0,
        this.aEndAngle = o || 2 * Math.PI,
        this.aClockwise = a || !1,
        this.aRotation = s || 0
    }
    function Ma(e, t, r, n, i, o) {
        _a.call(this, e, t, r, r, n, i, o),
        this.type = "ArcCurve"
    }
    function Sa() {
        var e = 0
          , t = 0
          , r = 0
          , n = 0;
        function i(i, o, a, s) {
            e = i,
            t = a,
            r = -3 * i + 3 * o - 2 * a - s,
            n = 2 * i - 2 * o + a + s
        }
        return {
            initCatmullRom: function(e, t, r, n, o) {
                i(t, r, o * (r - e), o * (n - t))
            },
            initNonuniformCatmullRom: function(e, t, r, n, o, a, s) {
                var c = (t - e) / o - (r - e) / (o + a) + (r - t) / a
                  , l = (r - t) / a - (n - t) / (a + s) + (n - r) / s;
                i(t, r, c *= a, l *= a)
            },
            calc: function(i) {
                var o = i * i;
                return e + t * i + r * o + n * (o * i)
            }
        }
    }
    Object.assign(fa.prototype, {
        load: function(e, t, r, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var i = this
              , o = ua.get(e);
            if (void 0 !== o)
                return i.manager.itemStart(e),
                setTimeout(function() {
                    t && t(o),
                    i.manager.itemEnd(e)
                }, 0),
                o;
            if (void 0 === da[e]) {
                var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1]
                      , c = !!a[2]
                      , l = a[3];
                    l = decodeURIComponent(l),
                    c && (l = atob(l));
                    try {
                        var u, h = (this.responseType || "").toLowerCase();
                        switch (h) {
                        case "arraybuffer":
                        case "blob":
                            for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++)
                                p[d] = l.charCodeAt(d);
                            u = "blob" === h ? new Blob([p.buffer],{
                                type: s
                            }) : p.buffer;
                            break;
                        case "document":
                            var f = new DOMParser;
                            u = f.parseFromString(l, s);
                            break;
                        case "json":
                            u = JSON.parse(l);
                            break;
                        default:
                            u = l
                        }
                        setTimeout(function() {
                            t && t(u),
                            i.manager.itemEnd(e)
                        }, 0)
                    } catch (t) {
                        setTimeout(function() {
                            n && n(t),
                            i.manager.itemError(e),
                            i.manager.itemEnd(e)
                        }, 0)
                    }
                } else {
                    da[e] = [],
                    da[e].push({
                        onLoad: t,
                        onProgress: r,
                        onError: n
                    });
                    var m = new XMLHttpRequest;
                    for (var v in m.open("GET", e, !0),
                    m.addEventListener("load", function(t) {
                        var r = this.response;
                        ua.add(e, r);
                        var n = da[e];
                        if (delete da[e],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            for (var o = 0, a = n.length; o < a; o++) {
                                (s = n[o]).onLoad && s.onLoad(r)
                            }
                            i.manager.itemEnd(e)
                        } else {
                            for (o = 0,
                            a = n.length; o < a; o++) {
                                var s;
                                (s = n[o]).onError && s.onError(t)
                            }
                            i.manager.itemError(e),
                            i.manager.itemEnd(e)
                        }
                    }, !1),
                    m.addEventListener("progress", function(t) {
                        for (var r = da[e], n = 0, i = r.length; n < i; n++) {
                            var o = r[n];
                            o.onProgress && o.onProgress(t)
                        }
                    }, !1),
                    m.addEventListener("error", function(t) {
                        var r = da[e];
                        delete da[e];
                        for (var n = 0, o = r.length; n < o; n++) {
                            var a = r[n];
                            a.onError && a.onError(t)
                        }
                        i.manager.itemError(e),
                        i.manager.itemEnd(e)
                    }, !1),
                    m.addEventListener("abort", function(t) {
                        var r = da[e];
                        delete da[e];
                        for (var n = 0, o = r.length; n < o; n++) {
                            var a = r[n];
                            a.onError && a.onError(t)
                        }
                        i.manager.itemError(e),
                        i.manager.itemEnd(e)
                    }, !1),
                    void 0 !== this.responseType && (m.responseType = this.responseType),
                    void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                    m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        m.setRequestHeader(v, this.requestHeader[v]);
                    m.send(null)
                }
                return i.manager.itemStart(e),
                m
            }
            da[e].push({
                onLoad: t,
                onProgress: r,
                onError: n
            })
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResponseType: function(e) {
            return this.responseType = e,
            this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e,
            this
        },
        setMimeType: function(e) {
            return this.mimeType = e,
            this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e,
            this
        }
    }),
    Object.assign(ma.prototype, {
        load: function(e, t, r, n) {
            var i = this
              , o = new fa(i.manager);
            o.setPath(i.path),
            o.load(e, function(e) {
                t(i.parse(JSON.parse(e)))
            }, r, n)
        },
        parse: function(e, t) {
            for (var r = [], n = 0; n < e.length; n++) {
                var i = ca.parse(e[n]);
                r.push(i)
            }
            t(r)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(va.prototype, {
        load: function(e, t, r, n) {
            var i = this
              , o = []
              , a = new wi;
            a.image = o;
            var s = new fa(this.manager);
            function c(c) {
                s.load(e[c], function(e) {
                    var r = i._parser(e, !0);
                    o[c] = {
                        width: r.width,
                        height: r.height,
                        format: r.format,
                        mipmaps: r.mipmaps
                    },
                    6 === (l += 1) && (1 === r.mipmapCount && (a.minFilter = ve),
                    a.format = r.format,
                    a.needsUpdate = !0,
                    t && t(a))
                }, r, n)
            }
            if (s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            Array.isArray(e))
                for (var l = 0, u = 0, h = e.length; u < h; ++u)
                    c(u);
            else
                s.load(e, function(e) {
                    var r = i._parser(e, !0);
                    if (r.isCubemap)
                        for (var n = r.mipmaps.length / r.mipmapCount, s = 0; s < n; s++) {
                            o[s] = {
                                mipmaps: []
                            };
                            for (var c = 0; c < r.mipmapCount; c++)
                                o[s].mipmaps.push(r.mipmaps[s * r.mipmapCount + c]),
                                o[s].format = r.format,
                                o[s].width = r.width,
                                o[s].height = r.height
                        }
                    else
                        a.image.width = r.width,
                        a.image.height = r.height,
                        a.mipmaps = r.mipmaps;
                    1 === r.mipmapCount && (a.minFilter = ve),
                    a.format = r.format,
                    a.needsUpdate = !0,
                    t && t(a)
                }, r, n);
            return a
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(ga.prototype, {
        load: function(e, t, r, n) {
            var i = this
              , o = new Gt
              , a = new fa(this.manager);
            return a.setResponseType("arraybuffer"),
            a.setPath(this.path),
            a.load(e, function(e) {
                var r = i._parser(e);
                r && (void 0 !== r.image ? o.image = r.image : void 0 !== r.data && (o.image.width = r.width,
                o.image.height = r.height,
                o.image.data = r.data),
                o.wrapS = void 0 !== r.wrapS ? r.wrapS : he,
                o.wrapT = void 0 !== r.wrapT ? r.wrapT : he,
                o.magFilter = void 0 !== r.magFilter ? r.magFilter : ve,
                o.minFilter = void 0 !== r.minFilter ? r.minFilter : ye,
                o.anisotropy = void 0 !== r.anisotropy ? r.anisotropy : 1,
                void 0 !== r.format && (o.format = r.format),
                void 0 !== r.type && (o.type = r.type),
                void 0 !== r.mipmaps && (o.mipmaps = r.mipmaps),
                1 === r.mipmapCount && (o.minFilter = ve),
                o.needsUpdate = !0,
                t && t(o, r))
            }, r, n),
            o
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(ya.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var i = this
              , o = ua.get(e);
            if (void 0 !== o)
                return i.manager.itemStart(e),
                setTimeout(function() {
                    t && t(o),
                    i.manager.itemEnd(e)
                }, 0),
                o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            function s() {
                a.removeEventListener("load", s, !1),
                a.removeEventListener("error", c, !1),
                ua.add(e, this),
                t && t(this),
                i.manager.itemEnd(e)
            }
            function c(t) {
                a.removeEventListener("load", s, !1),
                a.removeEventListener("error", c, !1),
                n && n(t),
                i.manager.itemError(e),
                i.manager.itemEnd(e)
            }
            return a.addEventListener("load", s, !1),
            a.addEventListener("error", c, !1),
            "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            i.manager.itemStart(e),
            a.src = e,
            a
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(ba.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, n) {
            var i = new Or
              , o = new ya(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            var a = 0;
            function s(r) {
                o.load(e[r], function(e) {
                    i.images[r] = e,
                    6 === ++a && (i.needsUpdate = !0,
                    t && t(i))
                }, void 0, n)
            }
            for (var c = 0; c < e.length; ++c)
                s(c);
            return i
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(xa.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, n) {
            var i = new It
              , o = new ya(this.manager);
            return o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(e, function(r) {
                i.image = r;
                var n = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                i.format = n ? Oe : Ie,
                i.needsUpdate = !0,
                void 0 !== t && t(i)
            }, r, n),
            i
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(wa.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(e, t) {
            var r = this.getUtoTmapping(e);
            return this.getPoint(r, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], r = 0; r <= e; r++)
                t.push(this.getPoint(r / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], r = 0; r <= e; r++)
                t.push(this.getPointAt(r / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, r, n = [], i = this.getPoint(0), o = 0;
            for (n.push(0),
            r = 1; r <= e; r++)
                o += (t = this.getPoint(r / e)).distanceTo(i),
                n.push(o),
                i = t;
            return this.cacheArcLengths = n,
            n
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var r, n = this.getLengths(), i = 0, o = n.length;
            r = t || e * n[o - 1];
            for (var a, s = 0, c = o - 1; s <= c; )
                if ((a = n[i = Math.floor(s + (c - s) / 2)] - r) < 0)
                    s = i + 1;
                else {
                    if (!(a > 0)) {
                        c = i;
                        break
                    }
                    c = i - 1
                }
            if (n[i = c] === r)
                return i / (o - 1);
            var l = n[i];
            return (i + (r - l) / (n[i + 1] - l)) / (o - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4
              , r = e + 1e-4;
            t < 0 && (t = 0),
            r > 1 && (r = 1);
            var n = this.getPoint(t);
            return this.getPoint(r).clone().sub(n).normalize()
        },
        getTangentAt: function(e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t)
        },
        computeFrenetFrames: function(e, t) {
            var r, n, i, o = new Pt, a = [], s = [], c = [], l = new Pt, u = new At;
            for (r = 0; r <= e; r++)
                n = r / e,
                a[r] = this.getTangentAt(n),
                a[r].normalize();
            s[0] = new Pt,
            c[0] = new Pt;
            var h = Number.MAX_VALUE
              , p = Math.abs(a[0].x)
              , d = Math.abs(a[0].y)
              , f = Math.abs(a[0].z);
            for (p <= h && (h = p,
            o.set(1, 0, 0)),
            d <= h && (h = d,
            o.set(0, 1, 0)),
            f <= h && o.set(0, 0, 1),
            l.crossVectors(a[0], o).normalize(),
            s[0].crossVectors(a[0], l),
            c[0].crossVectors(a[0], s[0]),
            r = 1; r <= e; r++)
                s[r] = s[r - 1].clone(),
                c[r] = c[r - 1].clone(),
                l.crossVectors(a[r - 1], a[r]),
                l.length() > Number.EPSILON && (l.normalize(),
                i = Math.acos(Et.clamp(a[r - 1].dot(a[r]), -1, 1)),
                s[r].applyMatrix4(u.makeRotationAxis(l, i))),
                c[r].crossVectors(a[r], s[r]);
            if (!0 === t)
                for (i = Math.acos(Et.clamp(s[0].dot(s[e]), -1, 1)),
                i /= e,
                a[0].dot(l.crossVectors(s[0], s[e])) > 0 && (i = -i),
                r = 1; r <= e; r++)
                    s[r].applyMatrix4(u.makeRotationAxis(a[r], i * r)),
                    c[r].crossVectors(a[r], s[r]);
            return {
                tangents: a,
                normals: s,
                binormals: c
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }),
    _a.prototype = Object.create(wa.prototype),
    _a.prototype.constructor = _a,
    _a.prototype.isEllipseCurve = !0,
    _a.prototype.getPoint = function(e, t) {
        for (var r = t || new Tt, n = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0; )
            i += n;
        for (; i > n; )
            i -= n;
        i < Number.EPSILON && (i = o ? 0 : n),
        !0 !== this.aClockwise || o || (i === n ? i = -n : i -= n);
        var a = this.aStartAngle + e * i
          , s = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var l = Math.cos(this.aRotation)
              , u = Math.sin(this.aRotation)
              , h = s - this.aX
              , p = c - this.aY;
            s = h * l - p * u + this.aX,
            c = h * u + p * l + this.aY
        }
        return r.set(s, c)
    }
    ,
    _a.prototype.copy = function(e) {
        return wa.prototype.copy.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    _a.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    ,
    _a.prototype.fromJSON = function(e) {
        return wa.prototype.fromJSON.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    Ma.prototype = Object.create(_a.prototype),
    Ma.prototype.constructor = Ma,
    Ma.prototype.isArcCurve = !0;
    var Ea = new Pt
      , Ta = new Sa
      , Aa = new Sa
      , La = new Sa;
    function Pa(e, t, r, n) {
        wa.call(this),
        this.type = "CatmullRomCurve3",
        this.points = e || [],
        this.closed = t || !1,
        this.curveType = r || "centripetal",
        this.tension = n || .5
    }
    function Ca(e, t, r, n, i) {
        var o = .5 * (n - t)
          , a = .5 * (i - r)
          , s = e * e;
        return (2 * r - 2 * n + o + a) * (e * s) + (-3 * r + 3 * n - 2 * o - a) * s + o * e + r
    }
    function Ra(e, t, r, n) {
        return function(e, t) {
            var r = 1 - e;
            return r * r * t
        }(e, t) + function(e, t) {
            return 2 * (1 - e) * e * t
        }(e, r) + function(e, t) {
            return e * e * t
        }(e, n)
    }
    function Oa(e, t, r, n, i) {
        return function(e, t) {
            var r = 1 - e;
            return r * r * r * t
        }(e, t) + function(e, t) {
            var r = 1 - e;
            return 3 * r * r * e * t
        }(e, r) + function(e, t) {
            return 3 * (1 - e) * e * e * t
        }(e, n) + function(e, t) {
            return e * e * e * t
        }(e, i)
    }
    function Ia(e, t, r, n) {
        wa.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = e || new Tt,
        this.v1 = t || new Tt,
        this.v2 = r || new Tt,
        this.v3 = n || new Tt
    }
    function Na(e, t, r, n) {
        wa.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = e || new Pt,
        this.v1 = t || new Pt,
        this.v2 = r || new Pt,
        this.v3 = n || new Pt
    }
    function Da(e, t) {
        wa.call(this),
        this.type = "LineCurve",
        this.v1 = e || new Tt,
        this.v2 = t || new Tt
    }
    function Ba(e, t) {
        wa.call(this),
        this.type = "LineCurve3",
        this.v1 = e || new Pt,
        this.v2 = t || new Pt
    }
    function za(e, t, r) {
        wa.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = e || new Tt,
        this.v1 = t || new Tt,
        this.v2 = r || new Tt
    }
    function Ga(e, t, r) {
        wa.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = e || new Pt,
        this.v1 = t || new Pt,
        this.v2 = r || new Pt
    }
    function Ua(e) {
        wa.call(this),
        this.type = "SplineCurve",
        this.points = e || []
    }
    Pa.prototype = Object.create(wa.prototype),
    Pa.prototype.constructor = Pa,
    Pa.prototype.isCatmullRomCurve3 = !0,
    Pa.prototype.getPoint = function(e, t) {
        var r, n, i, o, a = t || new Pt, s = this.points, c = s.length, l = (c - (this.closed ? 0 : 1)) * e, u = Math.floor(l), h = l - u;
        if (this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / c) + 1) * c : 0 === h && u === c - 1 && (u = c - 2,
        h = 1),
        this.closed || u > 0 ? r = s[(u - 1) % c] : (Ea.subVectors(s[0], s[1]).add(s[0]),
        r = Ea),
        n = s[u % c],
        i = s[(u + 1) % c],
        this.closed || u + 2 < c ? o = s[(u + 2) % c] : (Ea.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]),
        o = Ea),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            var p = "chordal" === this.curveType ? .5 : .25
              , d = Math.pow(r.distanceToSquared(n), p)
              , f = Math.pow(n.distanceToSquared(i), p)
              , m = Math.pow(i.distanceToSquared(o), p);
            f < 1e-4 && (f = 1),
            d < 1e-4 && (d = f),
            m < 1e-4 && (m = f),
            Ta.initNonuniformCatmullRom(r.x, n.x, i.x, o.x, d, f, m),
            Aa.initNonuniformCatmullRom(r.y, n.y, i.y, o.y, d, f, m),
            La.initNonuniformCatmullRom(r.z, n.z, i.z, o.z, d, f, m)
        } else
            "catmullrom" === this.curveType && (Ta.initCatmullRom(r.x, n.x, i.x, o.x, this.tension),
            Aa.initCatmullRom(r.y, n.y, i.y, o.y, this.tension),
            La.initCatmullRom(r.z, n.z, i.z, o.z, this.tension));
        return a.set(Ta.calc(h), Aa.calc(h), La.calc(h)),
        a
    }
    ,
    Pa.prototype.copy = function(e) {
        wa.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push(n.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    Pa.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, r = this.points.length; t < r; t++) {
            var n = this.points[t];
            e.points.push(n.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    ,
    Pa.prototype.fromJSON = function(e) {
        wa.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push((new Pt).fromArray(n))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    Ia.prototype = Object.create(wa.prototype),
    Ia.prototype.constructor = Ia,
    Ia.prototype.isCubicBezierCurve = !0,
    Ia.prototype.getPoint = function(e, t) {
        var r = t || new Tt
          , n = this.v0
          , i = this.v1
          , o = this.v2
          , a = this.v3;
        return r.set(Oa(e, n.x, i.x, o.x, a.x), Oa(e, n.y, i.y, o.y, a.y)),
        r
    }
    ,
    Ia.prototype.copy = function(e) {
        return wa.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    Ia.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    Ia.prototype.fromJSON = function(e) {
        return wa.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    Na.prototype = Object.create(wa.prototype),
    Na.prototype.constructor = Na,
    Na.prototype.isCubicBezierCurve3 = !0,
    Na.prototype.getPoint = function(e, t) {
        var r = t || new Pt
          , n = this.v0
          , i = this.v1
          , o = this.v2
          , a = this.v3;
        return r.set(Oa(e, n.x, i.x, o.x, a.x), Oa(e, n.y, i.y, o.y, a.y), Oa(e, n.z, i.z, o.z, a.z)),
        r
    }
    ,
    Na.prototype.copy = function(e) {
        return wa.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    Na.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    Na.prototype.fromJSON = function(e) {
        return wa.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    Da.prototype = Object.create(wa.prototype),
    Da.prototype.constructor = Da,
    Da.prototype.isLineCurve = !0,
    Da.prototype.getPoint = function(e, t) {
        var r = t || new Tt;
        return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    ,
    Da.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    Da.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    Da.prototype.copy = function(e) {
        return wa.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Da.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Da.prototype.fromJSON = function(e) {
        return wa.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Ba.prototype = Object.create(wa.prototype),
    Ba.prototype.constructor = Ba,
    Ba.prototype.isLineCurve3 = !0,
    Ba.prototype.getPoint = function(e, t) {
        var r = t || new Pt;
        return 1 === e ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1),
        r.multiplyScalar(e).add(this.v1)),
        r
    }
    ,
    Ba.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    Ba.prototype.copy = function(e) {
        return wa.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Ba.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Ba.prototype.fromJSON = function(e) {
        return wa.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    za.prototype = Object.create(wa.prototype),
    za.prototype.constructor = za,
    za.prototype.isQuadraticBezierCurve = !0,
    za.prototype.getPoint = function(e, t) {
        var r = t || new Tt
          , n = this.v0
          , i = this.v1
          , o = this.v2;
        return r.set(Ra(e, n.x, i.x, o.x), Ra(e, n.y, i.y, o.y)),
        r
    }
    ,
    za.prototype.copy = function(e) {
        return wa.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    za.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    za.prototype.fromJSON = function(e) {
        return wa.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Ga.prototype = Object.create(wa.prototype),
    Ga.prototype.constructor = Ga,
    Ga.prototype.isQuadraticBezierCurve3 = !0,
    Ga.prototype.getPoint = function(e, t) {
        var r = t || new Pt
          , n = this.v0
          , i = this.v1
          , o = this.v2;
        return r.set(Ra(e, n.x, i.x, o.x), Ra(e, n.y, i.y, o.y), Ra(e, n.z, i.z, o.z)),
        r
    }
    ,
    Ga.prototype.copy = function(e) {
        return wa.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Ga.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Ga.prototype.fromJSON = function(e) {
        return wa.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Ua.prototype = Object.create(wa.prototype),
    Ua.prototype.constructor = Ua,
    Ua.prototype.isSplineCurve = !0,
    Ua.prototype.getPoint = function(e, t) {
        var r = t || new Tt
          , n = this.points
          , i = (n.length - 1) * e
          , o = Math.floor(i)
          , a = i - o
          , s = n[0 === o ? o : o - 1]
          , c = n[o]
          , l = n[o > n.length - 2 ? n.length - 1 : o + 1]
          , u = n[o > n.length - 3 ? n.length - 1 : o + 2];
        return r.set(Ca(a, s.x, c.x, l.x, u.x), Ca(a, s.y, c.y, l.y, u.y)),
        r
    }
    ,
    Ua.prototype.copy = function(e) {
        wa.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push(n.clone())
        }
        return this
    }
    ,
    Ua.prototype.toJSON = function() {
        var e = wa.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, r = this.points.length; t < r; t++) {
            var n = this.points[t];
            e.points.push(n.toArray())
        }
        return e
    }
    ,
    Ua.prototype.fromJSON = function(e) {
        wa.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, r = e.points.length; t < r; t++) {
            var n = e.points[t];
            this.points.push((new Tt).fromArray(n))
        }
        return this
    }
    ;
    var ja = Object.freeze({
        ArcCurve: Ma,
        CatmullRomCurve3: Pa,
        CubicBezierCurve: Ia,
        CubicBezierCurve3: Na,
        EllipseCurve: _a,
        LineCurve: Da,
        LineCurve3: Ba,
        QuadraticBezierCurve: za,
        QuadraticBezierCurve3: Ga,
        SplineCurve: Ua
    });
    function Fa() {
        wa.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function ka(e) {
        Fa.call(this),
        this.type = "Path",
        this.currentPoint = new Tt,
        e && this.setFromPoints(e)
    }
    function Ha(e) {
        ka.call(this, e),
        this.uuid = Et.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function Va(e, t) {
        nr.call(this),
        this.type = "Light",
        this.color = new Yt(e),
        this.intensity = void 0 !== t ? t : 1,
        this.receiveShadow = void 0
    }
    function Wa(e, t, r) {
        Va.call(this, e, r),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(nr.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new Yt(t)
    }
    function qa(e) {
        this.camera = e,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new Tt(512,512),
        this.map = null,
        this.matrix = new At
    }
    function Xa() {
        qa.call(this, new Jn(50,1,.5,500))
    }
    function Ya(e, t, r, n, i, o) {
        Va.call(this, e, t),
        this.type = "SpotLight",
        this.position.copy(nr.DefaultUp),
        this.updateMatrix(),
        this.target = new nr,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }),
        this.distance = void 0 !== r ? r : 0,
        this.angle = void 0 !== n ? n : Math.PI / 3,
        this.penumbra = void 0 !== i ? i : 0,
        this.decay = void 0 !== o ? o : 1,
        this.shadow = new Xa
    }
    function Ja(e, t, r, n) {
        Va.call(this, e, t),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== r ? r : 0,
        this.decay = void 0 !== n ? n : 1,
        this.shadow = new qa(new Jn(90,1,.5,500))
    }
    function Za(e, t, r, n, i, o) {
        Yn.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== e ? e : -1,
        this.right = void 0 !== t ? t : 1,
        this.top = void 0 !== r ? r : 1,
        this.bottom = void 0 !== n ? n : -1,
        this.near = void 0 !== i ? i : .1,
        this.far = void 0 !== o ? o : 2e3,
        this.updateProjectionMatrix()
    }
    function Ka() {
        qa.call(this, new Za(-5,5,5,-5,.5,500))
    }
    function Qa(e, t) {
        Va.call(this, e, t),
        this.type = "DirectionalLight",
        this.position.copy(nr.DefaultUp),
        this.updateMatrix(),
        this.target = new nr,
        this.shadow = new Ka
    }
    function $a(e, t) {
        Va.call(this, e, t),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function es(e, t, r, n) {
        Va.call(this, e, t),
        this.type = "RectAreaLight",
        this.width = void 0 !== r ? r : 10,
        this.height = void 0 !== n ? n : 10
    }
    function ts(e) {
        this.manager = void 0 !== e ? e : pa,
        this.textures = {}
    }
    Fa.prototype = Object.assign(Object.create(wa.prototype), {
        constructor: Fa,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0)
              , t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Da(t,e))
        },
        getPoint: function(e) {
            for (var t = e * this.getLength(), r = this.getCurveLengths(), n = 0; n < r.length; ) {
                if (r[n] >= t) {
                    var i = r[n] - t
                      , o = this.curves[n]
                      , a = o.getLength()
                      , s = 0 === a ? 0 : 1 - i / a;
                    return o.getPointAt(s)
                }
                n++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var e = [], t = 0, r = 0, n = this.curves.length; r < n; r++)
                t += this.curves[r].getLength(),
                e.push(t);
            return this.cacheLengths = e,
            e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], r = 0; r <= e; r++)
                t.push(this.getPoint(r / e));
            return this.autoClose && t.push(t[0]),
            t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, r = [], n = 0, i = this.curves; n < i.length; n++)
                for (var o = i[n], a = o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e, s = o.getPoints(a), c = 0; c < s.length; c++) {
                    var l = s[c];
                    t && t.equals(l) || (r.push(l),
                    t = l)
                }
            return this.autoClose && r.length > 1 && !r[r.length - 1].equals(r[0]) && r.push(r[0]),
            r
        },
        copy: function(e) {
            wa.prototype.copy.call(this, e),
            this.curves = [];
            for (var t = 0, r = e.curves.length; t < r; t++) {
                var n = e.curves[t];
                this.curves.push(n.clone())
            }
            return this.autoClose = e.autoClose,
            this
        },
        toJSON: function() {
            var e = wa.prototype.toJSON.call(this);
            e.autoClose = this.autoClose,
            e.curves = [];
            for (var t = 0, r = this.curves.length; t < r; t++) {
                var n = this.curves[t];
                e.curves.push(n.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            wa.prototype.fromJSON.call(this, e),
            this.autoClose = e.autoClose,
            this.curves = [];
            for (var t = 0, r = e.curves.length; t < r; t++) {
                var n = e.curves[t];
                this.curves.push((new ja[n.type]).fromJSON(n))
            }
            return this
        }
    }),
    ka.prototype = Object.assign(Object.create(Fa.prototype), {
        constructor: ka,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, r = e.length; t < r; t++)
                this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var r = new Da(this.currentPoint.clone(),new Tt(e,t));
            this.curves.push(r),
            this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, r, n) {
            var i = new za(this.currentPoint.clone(),new Tt(e,t),new Tt(r,n));
            this.curves.push(i),
            this.currentPoint.set(r, n)
        },
        bezierCurveTo: function(e, t, r, n, i, o) {
            var a = new Ia(this.currentPoint.clone(),new Tt(e,t),new Tt(r,n),new Tt(i,o));
            this.curves.push(a),
            this.currentPoint.set(i, o)
        },
        splineThru: function(e) {
            var t = new Ua([this.currentPoint.clone()].concat(e));
            this.curves.push(t),
            this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, r, n, i, o) {
            var a = this.currentPoint.x
              , s = this.currentPoint.y;
            this.absarc(e + a, t + s, r, n, i, o)
        },
        absarc: function(e, t, r, n, i, o) {
            this.absellipse(e, t, r, r, n, i, o)
        },
        ellipse: function(e, t, r, n, i, o, a, s) {
            var c = this.currentPoint.x
              , l = this.currentPoint.y;
            this.absellipse(e + c, t + l, r, n, i, o, a, s)
        },
        absellipse: function(e, t, r, n, i, o, a, s) {
            var c = new _a(e,t,r,n,i,o,a,s);
            if (this.curves.length > 0) {
                var l = c.getPoint(0);
                l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
            }
            this.curves.push(c);
            var u = c.getPoint(1);
            this.currentPoint.copy(u)
        },
        copy: function(e) {
            return Fa.prototype.copy.call(this, e),
            this.currentPoint.copy(e.currentPoint),
            this
        },
        toJSON: function() {
            var e = Fa.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(),
            e
        },
        fromJSON: function(e) {
            return Fa.prototype.fromJSON.call(this, e),
            this.currentPoint.fromArray(e.currentPoint),
            this
        }
    }),
    Ha.prototype = Object.assign(Object.create(ka.prototype), {
        constructor: Ha,
        getPointsHoles: function(e) {
            for (var t = [], r = 0, n = this.holes.length; r < n; r++)
                t[r] = this.holes[r].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            ka.prototype.copy.call(this, e),
            this.holes = [];
            for (var t = 0, r = e.holes.length; t < r; t++) {
                var n = e.holes[t];
                this.holes.push(n.clone())
            }
            return this
        },
        toJSON: function() {
            var e = ka.prototype.toJSON.call(this);
            e.uuid = this.uuid,
            e.holes = [];
            for (var t = 0, r = this.holes.length; t < r; t++) {
                var n = this.holes[t];
                e.holes.push(n.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            ka.prototype.fromJSON.call(this, e),
            this.uuid = e.uuid,
            this.holes = [];
            for (var t = 0, r = e.holes.length; t < r; t++) {
                var n = e.holes[t];
                this.holes.push((new ka).fromJSON(n))
            }
            return this
        }
    }),
    Va.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: Va,
        isLight: !0,
        copy: function(e) {
            return nr.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        },
        toJSON: function(e) {
            var t = nr.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }),
    Wa.prototype = Object.assign(Object.create(Va.prototype), {
        constructor: Wa,
        isHemisphereLight: !0,
        copy: function(e) {
            return Va.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
        }
    }),
    Object.assign(qa.prototype, {
        copy: function(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }),
    Xa.prototype = Object.assign(Object.create(qa.prototype), {
        constructor: Xa,
        isSpotLightShadow: !0,
        update: function(e) {
            var t = this.camera
              , r = 2 * Et.RAD2DEG * e.angle
              , n = this.mapSize.width / this.mapSize.height
              , i = e.distance || t.far;
            r === t.fov && n === t.aspect && i === t.far || (t.fov = r,
            t.aspect = n,
            t.far = i,
            t.updateProjectionMatrix())
        }
    }),
    Ya.prototype = Object.assign(Object.create(Va.prototype), {
        constructor: Ya,
        isSpotLight: !0,
        copy: function(e) {
            return Va.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.angle = e.angle,
            this.penumbra = e.penumbra,
            this.decay = e.decay,
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Ja.prototype = Object.assign(Object.create(Va.prototype), {
        constructor: Ja,
        isPointLight: !0,
        copy: function(e) {
            return Va.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.decay = e.decay,
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Za.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Za,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return Yn.prototype.copy.call(this, e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this
        },
        setViewOffset: function(e, t, r, n, i, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = r,
            this.view.offsetY = n,
            this.view.width = i,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , r = (this.right + this.left) / 2
              , n = (this.top + this.bottom) / 2
              , i = r - e
              , o = r + e
              , a = n + t
              , s = n - t;
            if (null !== this.view && this.view.enabled) {
                var c = this.zoom / (this.view.width / this.view.fullWidth)
                  , l = this.zoom / (this.view.height / this.view.fullHeight)
                  , u = (this.right - this.left) / this.view.width
                  , h = (this.top - this.bottom) / this.view.height;
                o = (i += u * (this.view.offsetX / c)) + u * (this.view.width / c),
                s = (a -= h * (this.view.offsetY / l)) - h * (this.view.height / l)
            }
            this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = nr.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }),
    Ka.prototype = Object.assign(Object.create(qa.prototype), {
        constructor: Ka
    }),
    Qa.prototype = Object.assign(Object.create(Va.prototype), {
        constructor: Qa,
        isDirectionalLight: !0,
        copy: function(e) {
            return Va.prototype.copy.call(this, e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    $a.prototype = Object.assign(Object.create(Va.prototype), {
        constructor: $a,
        isAmbientLight: !0
    }),
    es.prototype = Object.assign(Object.create(Va.prototype), {
        constructor: es,
        isRectAreaLight: !0,
        copy: function(e) {
            return Va.prototype.copy.call(this, e),
            this.width = e.width,
            this.height = e.height,
            this
        },
        toJSON: function(e) {
            var t = Va.prototype.toJSON.call(this, e);
            return t.object.width = this.width,
            t.object.height = this.height,
            t
        }
    }),
    Object.assign(ts.prototype, {
        load: function(e, t, r, n) {
            var i = this
              , o = new fa(i.manager);
            o.setPath(i.path),
            o.load(e, function(e) {
                t(i.parse(JSON.parse(e)))
            }, r, n)
        },
        parse: function(e) {
            var t = this.textures;
            function r(e) {
                return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
                t[e]
            }
            var n = new Yo[e.type];
            if (void 0 !== e.uuid && (n.uuid = e.uuid),
            void 0 !== e.name && (n.name = e.name),
            void 0 !== e.color && n.color.setHex(e.color),
            void 0 !== e.roughness && (n.roughness = e.roughness),
            void 0 !== e.metalness && (n.metalness = e.metalness),
            void 0 !== e.emissive && n.emissive.setHex(e.emissive),
            void 0 !== e.specular && n.specular.setHex(e.specular),
            void 0 !== e.shininess && (n.shininess = e.shininess),
            void 0 !== e.clearCoat && (n.clearCoat = e.clearCoat),
            void 0 !== e.clearCoatRoughness && (n.clearCoatRoughness = e.clearCoatRoughness),
            void 0 !== e.vertexColors && (n.vertexColors = e.vertexColors),
            void 0 !== e.fog && (n.fog = e.fog),
            void 0 !== e.flatShading && (n.flatShading = e.flatShading),
            void 0 !== e.blending && (n.blending = e.blending),
            void 0 !== e.combine && (n.combine = e.combine),
            void 0 !== e.side && (n.side = e.side),
            void 0 !== e.opacity && (n.opacity = e.opacity),
            void 0 !== e.transparent && (n.transparent = e.transparent),
            void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest),
            void 0 !== e.depthTest && (n.depthTest = e.depthTest),
            void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite),
            void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite),
            void 0 !== e.wireframe && (n.wireframe = e.wireframe),
            void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth),
            void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap),
            void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin),
            void 0 !== e.rotation && (n.rotation = e.rotation),
            1 !== e.linewidth && (n.linewidth = e.linewidth),
            void 0 !== e.dashSize && (n.dashSize = e.dashSize),
            void 0 !== e.gapSize && (n.gapSize = e.gapSize),
            void 0 !== e.scale && (n.scale = e.scale),
            void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset),
            void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor),
            void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits),
            void 0 !== e.skinning && (n.skinning = e.skinning),
            void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets),
            void 0 !== e.dithering && (n.dithering = e.dithering),
            void 0 !== e.visible && (n.visible = e.visible),
            void 0 !== e.userData && (n.userData = e.userData),
            void 0 !== e.uniforms)
                for (var i in e.uniforms) {
                    var o = e.uniforms[i];
                    switch (n.uniforms[i] = {},
                    o.type) {
                    case "t":
                        n.uniforms[i].value = r(o.value);
                        break;
                    case "c":
                        n.uniforms[i].value = (new Yt).setHex(o.value);
                        break;
                    case "v2":
                        n.uniforms[i].value = (new Tt).fromArray(o.value);
                        break;
                    case "v3":
                        n.uniforms[i].value = (new Pt).fromArray(o.value);
                        break;
                    case "v4":
                        n.uniforms[i].value = (new Nt).fromArray(o.value);
                        break;
                    case "m3":
                        n.uniforms[i].value = (new Ct).fromArray(o.value);
                    case "m4":
                        n.uniforms[i].value = (new At).fromArray(o.value);
                        break;
                    default:
                        n.uniforms[i].value = o.value
                    }
                }
            if (void 0 !== e.defines && (n.defines = e.defines),
            void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader),
            void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader),
            void 0 !== e.extensions)
                for (var a in e.extensions)
                    n.extensions[a] = e.extensions[a];
            if (void 0 !== e.shading && (n.flatShading = 1 === e.shading),
            void 0 !== e.size && (n.size = e.size),
            void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation),
            void 0 !== e.map && (n.map = r(e.map)),
            void 0 !== e.alphaMap && (n.alphaMap = r(e.alphaMap),
            n.transparent = !0),
            void 0 !== e.bumpMap && (n.bumpMap = r(e.bumpMap)),
            void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale),
            void 0 !== e.normalMap && (n.normalMap = r(e.normalMap)),
            void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType),
            void 0 !== e.normalScale) {
                var s = e.normalScale;
                !1 === Array.isArray(s) && (s = [s, s]),
                n.normalScale = (new Tt).fromArray(s)
            }
            return void 0 !== e.displacementMap && (n.displacementMap = r(e.displacementMap)),
            void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale),
            void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias),
            void 0 !== e.roughnessMap && (n.roughnessMap = r(e.roughnessMap)),
            void 0 !== e.metalnessMap && (n.metalnessMap = r(e.metalnessMap)),
            void 0 !== e.emissiveMap && (n.emissiveMap = r(e.emissiveMap)),
            void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity),
            void 0 !== e.specularMap && (n.specularMap = r(e.specularMap)),
            void 0 !== e.envMap && (n.envMap = r(e.envMap)),
            void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity),
            void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity),
            void 0 !== e.lightMap && (n.lightMap = r(e.lightMap)),
            void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity),
            void 0 !== e.aoMap && (n.aoMap = r(e.aoMap)),
            void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity),
            void 0 !== e.gradientMap && (n.gradientMap = r(e.gradientMap)),
            n
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setTextures: function(e) {
            return this.textures = e,
            this
        }
    });
    var rs = {
        decodeText: function(e) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(e);
            for (var t = "", r = 0, n = e.length; r < n; r++)
                t += String.fromCharCode(e[r]);
            return decodeURIComponent(escape(t))
        },
        extractUrlBase: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    };
    function ns(e) {
        this.manager = void 0 !== e ? e : pa
    }
    Object.assign(ns.prototype, {
        load: function(e, t, r, n) {
            var i = this
              , o = new fa(i.manager);
            o.setPath(i.path),
            o.load(e, function(e) {
                t(i.parse(JSON.parse(e)))
            }, r, n)
        },
        parse: function(e) {
            var t = new br
              , r = e.data.index;
            if (void 0 !== r) {
                var n = new is[r.type](r.array);
                t.setIndex(new ar(n,1))
            }
            var i = e.data.attributes;
            for (var o in i) {
                var a = i[o];
                n = new is[a.type](a.array);
                t.addAttribute(o, new ar(n,a.itemSize,a.normalized))
            }
            var s = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== s)
                for (var c = 0, l = s.length; c !== l; ++c) {
                    var u = s[c];
                    t.addGroup(u.start, u.count, u.materialIndex)
                }
            var h = e.data.boundingSphere;
            if (void 0 !== h) {
                var p = new Pt;
                void 0 !== h.center && p.fromArray(h.center),
                t.boundingSphere = new jt(p,h.radius)
            }
            return e.name && (t.name = e.name),
            e.userData && (t.userData = e.userData),
            t
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    });
    var is = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function os(e) {
        this.manager = void 0 !== e ? e : pa,
        this.resourcePath = ""
    }
    Object.assign(os.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, r, n) {
            var i = this
              , o = void 0 === this.path ? rs.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || o;
            var a = new fa(i.manager);
            a.setPath(this.path),
            a.load(e, function(r) {
                var o = null;
                try {
                    o = JSON.parse(r)
                } catch (t) {
                    return void 0 !== n && n(t),
                    void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                var a = o.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(o, t) : console.error("THREE.ObjectLoader: Can't load " + e)
            }, r, n)
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e,
            this
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        parse: function(e, t) {
            var r = this.parseShape(e.shapes)
              , n = this.parseGeometries(e.geometries, r)
              , i = this.parseImages(e.images, function() {
                void 0 !== t && t(s)
            })
              , o = this.parseTextures(e.textures, i)
              , a = this.parseMaterials(e.materials, o)
              , s = this.parseObject(e.object, n, a);
            return e.animations && (s.animations = this.parseAnimations(e.animations)),
            void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s),
            s
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var r = 0, n = e.length; r < n; r++) {
                    var i = (new Ha).fromJSON(e[r]);
                    t[i.uuid] = i
                }
            return t
        },
        parseGeometries: function(e, t) {
            var r = {};
            if (void 0 !== e)
                for (var n = new ns, i = 0, o = e.length; i < o; i++) {
                    var a, s = e[i];
                    switch (s.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        a = new zo[s.type](s.width,s.height,s.widthSegments,s.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        a = new zo[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        a = new zo[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        a = new zo[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        a = new zo[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        a = new zo[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        a = new zo[s.type](s.radius,s.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        a = new zo[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        a = new zo[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        a = new zo[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        a = new zo[s.type](s.points,s.segments,s.phiStart,s.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        a = new zo[s.type](s.vertices,s.indices,s.radius,s.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        for (var c = [], l = 0, u = s.shapes.length; l < u; l++) {
                            var h = t[s.shapes[l]];
                            c.push(h)
                        }
                        a = new zo[s.type](c,s.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        for (c = [],
                        l = 0,
                        u = s.shapes.length; l < u; l++) {
                            h = t[s.shapes[l]];
                            c.push(h)
                        }
                        var p = s.options.extrudePath;
                        void 0 !== p && (s.options.extrudePath = (new ja[p.type]).fromJSON(p)),
                        a = new zo[s.type](c,s.options);
                        break;
                    case "BufferGeometry":
                        a = n.parse(s);
                        break;
                    case "Geometry":
                        if ("THREE"in window && "LegacyJSONLoader"in THREE)
                            a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                        else
                            console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                        continue
                    }
                    a.uuid = s.uuid,
                    void 0 !== s.name && (a.name = s.name),
                    !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData),
                    r[s.uuid] = a
                }
            return r
        },
        parseMaterials: function(e, t) {
            var r = {}
              , n = {};
            if (void 0 !== e) {
                var i = new ts;
                i.setTextures(t);
                for (var o = 0, a = e.length; o < a; o++) {
                    var s = e[o];
                    if ("MultiMaterial" === s.type) {
                        for (var c = [], l = 0; l < s.materials.length; l++) {
                            var u = s.materials[l];
                            void 0 === r[u.uuid] && (r[u.uuid] = i.parse(u)),
                            c.push(r[u.uuid])
                        }
                        n[s.uuid] = c
                    } else
                        void 0 === r[s.uuid] && (r[s.uuid] = i.parse(s)),
                        n[s.uuid] = r[s.uuid]
                }
            }
            return n
        },
        parseAnimations: function(e) {
            for (var t = [], r = 0; r < e.length; r++) {
                var n = e[r]
                  , i = ca.parse(n);
                void 0 !== n.uuid && (i.uuid = n.uuid),
                t.push(i)
            }
            return t
        },
        parseImages: function(e, t) {
            var r = this
              , n = {};
            function i(e) {
                return r.manager.itemStart(e),
                o.load(e, function() {
                    r.manager.itemEnd(e)
                }, void 0, function() {
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                })
            }
            if (void 0 !== e && e.length > 0) {
                var o = new ya(new ha(t));
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = e.length; a < s; a++) {
                    var c = e[a]
                      , l = c.url;
                    if (Array.isArray(l)) {
                        n[c.uuid] = [];
                        for (var u = 0, h = l.length; u < h; u++) {
                            var p = l[u]
                              , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : r.resourcePath + p;
                            n[c.uuid].push(i(d))
                        }
                    } else {
                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : r.resourcePath + c.url;
                        n[c.uuid] = i(d)
                    }
                }
            }
            return n
        },
        parseTextures: function(e, t) {
            function r(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                t[e])
            }
            var n = {};
            if (void 0 !== e)
                for (var i = 0, o = e.length; i < o; i++) {
                    var a, s = e[i];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                    void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image),
                    (a = Array.isArray(t[s.image]) ? new Or(t[s.image]) : new It(t[s.image])).needsUpdate = !0,
                    a.uuid = s.uuid,
                    void 0 !== s.name && (a.name = s.name),
                    void 0 !== s.mapping && (a.mapping = r(s.mapping, ss)),
                    void 0 !== s.offset && a.offset.fromArray(s.offset),
                    void 0 !== s.repeat && a.repeat.fromArray(s.repeat),
                    void 0 !== s.center && a.center.fromArray(s.center),
                    void 0 !== s.rotation && (a.rotation = s.rotation),
                    void 0 !== s.wrap && (a.wrapS = r(s.wrap[0], cs),
                    a.wrapT = r(s.wrap[1], cs)),
                    void 0 !== s.format && (a.format = s.format),
                    void 0 !== s.type && (a.type = s.type),
                    void 0 !== s.encoding && (a.encoding = s.encoding),
                    void 0 !== s.minFilter && (a.minFilter = r(s.minFilter, ls)),
                    void 0 !== s.magFilter && (a.magFilter = r(s.magFilter, ls)),
                    void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (a.flipY = s.flipY),
                    void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment),
                    n[s.uuid] = a
                }
            return n
        },
        parseObject: function(e, t, r) {
            var n;
            function i(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                t[e]
            }
            function o(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], n = 0, i = e.length; n < i; n++) {
                            var o = e[n];
                            void 0 === r[o] && console.warn("THREE.ObjectLoader: Undefined material", o),
                            t.push(r[o])
                        }
                        return t
                    }
                    return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                    r[e]
                }
            }
            switch (e.type) {
            case "Scene":
                n = new oi,
                void 0 !== e.background && Number.isInteger(e.background) && (n.background = new Yt(e.background)),
                void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new ii(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new ni(e.fog.color,e.fog.density)));
                break;
            case "PerspectiveCamera":
                n = new Jn(e.fov,e.aspect,e.near,e.far),
                void 0 !== e.focus && (n.focus = e.focus),
                void 0 !== e.zoom && (n.zoom = e.zoom),
                void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset),
                void 0 !== e.view && (n.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                n = new Za(e.left,e.right,e.top,e.bottom,e.near,e.far),
                void 0 !== e.zoom && (n.zoom = e.zoom),
                void 0 !== e.view && (n.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                n = new $a(e.color,e.intensity);
                break;
            case "DirectionalLight":
                n = new Qa(e.color,e.intensity);
                break;
            case "PointLight":
                n = new Ja(e.color,e.intensity,e.distance,e.decay);
                break;
            case "RectAreaLight":
                n = new es(e.color,e.intensity,e.width,e.height);
                break;
            case "SpotLight":
                n = new Ya(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                break;
            case "HemisphereLight":
                n = new Wa(e.color,e.groundColor,e.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                var a = i(e.geometry)
                  , s = o(e.material);
                n = a.bones && a.bones.length > 0 ? new hi(a,s) : new Cr(a,s),
                void 0 !== e.drawMode && n.setDrawMode(e.drawMode);
                break;
            case "LOD":
                n = new ui;
                break;
            case "Line":
                n = new mi(i(e.geometry),o(e.material),e.mode);
                break;
            case "LineLoop":
                n = new gi(i(e.geometry),o(e.material));
                break;
            case "LineSegments":
                n = new vi(i(e.geometry),o(e.material));
                break;
            case "PointCloud":
            case "Points":
                n = new bi(i(e.geometry),o(e.material));
                break;
            case "Sprite":
                n = new li(o(e.material));
                break;
            case "Group":
                n = new Xn;
                break;
            default:
                n = new nr
            }
            if (n.uuid = e.uuid,
            void 0 !== e.name && (n.name = e.name),
            void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix),
            void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate),
            n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position),
            void 0 !== e.rotation && n.rotation.fromArray(e.rotation),
            void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion),
            void 0 !== e.scale && n.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (n.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow),
            e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias),
            void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius),
            void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize),
            void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (n.visible = e.visible),
            void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder),
            void 0 !== e.userData && (n.userData = e.userData),
            void 0 !== e.layers && (n.layers.mask = e.layers),
            void 0 !== e.children)
                for (var c = e.children, l = 0; l < c.length; l++)
                    n.add(this.parseObject(c[l], t, r));
            if ("LOD" === e.type)
                for (var u = e.levels, h = 0; h < u.length; h++) {
                    var p = u[h]
                      , d = n.getObjectByProperty("uuid", p.object);
                    void 0 !== d && n.addLevel(d, p.distance)
                }
            return n
        }
    });
    var as, ss = {
        UVMapping: 300,
        CubeReflectionMapping: ne,
        CubeRefractionMapping: ie,
        EquirectangularReflectionMapping: oe,
        EquirectangularRefractionMapping: ae,
        SphericalReflectionMapping: se,
        CubeUVReflectionMapping: ce,
        CubeUVRefractionMapping: le
    }, cs = {
        RepeatWrapping: ue,
        ClampToEdgeWrapping: he,
        MirroredRepeatWrapping: pe
    }, ls = {
        NearestFilter: de,
        NearestMipMapNearestFilter: fe,
        NearestMipMapLinearFilter: me,
        LinearFilter: ve,
        LinearMipMapNearestFilter: ge,
        LinearMipMapLinearFilter: ye
    };
    function us(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.manager = void 0 !== e ? e : pa,
        this.options = void 0
    }
    function hs() {
        this.type = "ShapePath",
        this.color = new Yt,
        this.subPaths = [],
        this.currentPath = null
    }
    function ps(e) {
        this.type = "Font",
        this.data = e
    }
    function ds(e, t, r, n, i) {
        var o = i.glyphs[e] || i.glyphs["?"];
        if (o) {
            var a, s, c, l, u, h, p, d, f = new hs;
            if (o.o)
                for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g; ) {
                    switch (m[v++]) {
                    case "m":
                        a = m[v++] * t + r,
                        s = m[v++] * t + n,
                        f.moveTo(a, s);
                        break;
                    case "l":
                        a = m[v++] * t + r,
                        s = m[v++] * t + n,
                        f.lineTo(a, s);
                        break;
                    case "q":
                        c = m[v++] * t + r,
                        l = m[v++] * t + n,
                        u = m[v++] * t + r,
                        h = m[v++] * t + n,
                        f.quadraticCurveTo(u, h, c, l);
                        break;
                    case "b":
                        c = m[v++] * t + r,
                        l = m[v++] * t + n,
                        u = m[v++] * t + r,
                        h = m[v++] * t + n,
                        p = m[v++] * t + r,
                        d = m[v++] * t + n,
                        f.bezierCurveTo(u, h, p, d, c, l)
                    }
                }
            return {
                offsetX: o.ha * t,
                path: f
            }
        }
    }
    function fs(e) {
        this.manager = void 0 !== e ? e : pa
    }
    function ms() {}
    us.prototype = {
        constructor: us,
        setOptions: function(e) {
            return this.options = e,
            this
        },
        load: function(e, t, r, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var i = this
              , o = ua.get(e);
            if (void 0 !== o)
                return i.manager.itemStart(e),
                setTimeout(function() {
                    t && t(o),
                    i.manager.itemEnd(e)
                }, 0),
                o;
            fetch(e).then(function(e) {
                return e.blob()
            }).then(function(e) {
                return createImageBitmap(e, i.options)
            }).then(function(r) {
                ua.add(e, r),
                t && t(r),
                i.manager.itemEnd(e)
            }).catch(function(t) {
                n && n(t),
                i.manager.itemError(e),
                i.manager.itemEnd(e)
            })
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    },
    Object.assign(hs.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new ka,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, r, n) {
            this.currentPath.quadraticCurveTo(e, t, r, n)
        },
        bezierCurveTo: function(e, t, r, n, i, o) {
            this.currentPath.bezierCurveTo(e, t, r, n, i, o)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function r(e) {
                for (var t = [], r = 0, n = e.length; r < n; r++) {
                    var i = e[r]
                      , o = new Ha;
                    o.curves = i.curves,
                    t.push(o)
                }
                return t
            }
            function n(e, t) {
                for (var r = t.length, n = !1, i = r - 1, o = 0; o < r; i = o++) {
                    var a = t[i]
                      , s = t[o]
                      , c = s.x - a.x
                      , l = s.y - a.y;
                    if (Math.abs(l) > Number.EPSILON) {
                        if (l < 0 && (a = t[o],
                        c = -c,
                        s = t[i],
                        l = -l),
                        e.y < a.y || e.y > s.y)
                            continue;
                        if (e.y === a.y) {
                            if (e.x === a.x)
                                return !0
                        } else {
                            var u = l * (e.x - a.x) - c * (e.y - a.y);
                            if (0 === u)
                                return !0;
                            if (u < 0)
                                continue;
                            n = !n
                        }
                    } else {
                        if (e.y !== a.y)
                            continue;
                        if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x)
                            return !0
                    }
                }
                return n
            }
            var i = ho.isClockWise
              , o = this.subPaths;
            if (0 === o.length)
                return [];
            if (!0 === t)
                return r(o);
            var a, s, c, l = [];
            if (1 === o.length)
                return s = o[0],
                (c = new Ha).curves = s.curves,
                l.push(c),
                l;
            var u = !i(o[0].getPoints());
            u = e ? !u : u;
            var h, p, d = [], f = [], m = [], v = 0;
            f[v] = void 0,
            m[v] = [];
            for (var g = 0, y = o.length; g < y; g++)
                a = i(h = (s = o[g]).getPoints()),
                (a = e ? !a : a) ? (!u && f[v] && v++,
                f[v] = {
                    s: new Ha,
                    p: h
                },
                f[v].s.curves = s.curves,
                u && v++,
                m[v] = []) : m[v].push({
                    h: s,
                    p: h[0]
                });
            if (!f[0])
                return r(o);
            if (f.length > 1) {
                for (var b = !1, x = [], w = 0, _ = f.length; w < _; w++)
                    d[w] = [];
                for (w = 0,
                _ = f.length; w < _; w++)
                    for (var M = m[w], S = 0; S < M.length; S++) {
                        for (var E = M[S], T = !0, A = 0; A < f.length; A++)
                            n(E.p, f[A].p) && (w !== A && x.push({
                                froms: w,
                                tos: A,
                                hole: S
                            }),
                            T ? (T = !1,
                            d[A].push(E)) : b = !0);
                        T && d[w].push(E)
                    }
                x.length > 0 && (b || (m = d))
            }
            g = 0;
            for (var L = f.length; g < L; g++) {
                c = f[g].s,
                l.push(c);
                for (var P = 0, C = (p = m[g]).length; P < C; P++)
                    c.holes.push(p[P].h)
            }
            return l
        }
    }),
    Object.assign(ps.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            void 0 === t && (t = 100);
            for (var r = [], n = function(e, t, r) {
                for (var n = Array.from ? Array.from(e) : String(e).split(""), i = t / r.resolution, o = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * i, a = [], s = 0, c = 0, l = 0; l < n.length; l++) {
                    var u = n[l];
                    if ("\n" === u)
                        s = 0,
                        c -= o;
                    else {
                        var h = ds(u, i, s, c, r);
                        s += h.offsetX,
                        a.push(h.path)
                    }
                }
                return a
            }(e, t, this.data), i = 0, o = n.length; i < o; i++)
                Array.prototype.push.apply(r, n[i].toShapes());
            return r
        }
    }),
    Object.assign(fs.prototype, {
        load: function(e, t, r, n) {
            var i = this
              , o = new fa(this.manager);
            o.setPath(this.path),
            o.load(e, function(e) {
                var r;
                try {
                    r = JSON.parse(e)
                } catch (t) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    r = JSON.parse(e.substring(65, e.length - 2))
                }
                var n = i.parse(r);
                t && t(n)
            }, r, n)
        },
        parse: function(e) {
            return new ps(e)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    ms.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = this.handlers, r = 0, n = t.length; r < n; r += 2) {
                var i = t[r]
                  , o = t[r + 1];
                if (i.test(e))
                    return o
            }
            return null
        }
    },
    Object.assign(ms.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(e, t, r) {
            for (var n = [], i = 0; i < e.length; ++i)
                n[i] = this.createMaterial(e[i], t, r);
            return n
        },
        createMaterial: function() {
            var e = {
                NoBlending: y,
                NormalBlending: b,
                AdditiveBlending: x,
                SubtractiveBlending: w,
                MultiplyBlending: _,
                CustomBlending: M
            }
              , t = new Yt
              , r = new xa
              , n = new ts;
            return function(i, o, a) {
                var s = {};
                function c(e, t, n, i, c) {
                    var l, u = o + e, h = ms.Handlers.get(u);
                    null !== h ? l = h.load(u) : (r.setCrossOrigin(a),
                    l = r.load(u)),
                    void 0 !== t && (l.repeat.fromArray(t),
                    1 !== t[0] && (l.wrapS = ue),
                    1 !== t[1] && (l.wrapT = ue)),
                    void 0 !== n && l.offset.fromArray(n),
                    void 0 !== i && ("repeat" === i[0] && (l.wrapS = ue),
                    "mirror" === i[0] && (l.wrapS = pe),
                    "repeat" === i[1] && (l.wrapT = ue),
                    "mirror" === i[1] && (l.wrapT = pe)),
                    void 0 !== c && (l.anisotropy = c);
                    var p = Et.generateUUID();
                    return s[p] = l,
                    p
                }
                var l = {
                    uuid: Et.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var u in i) {
                    var h = i[u];
                    switch (u) {
                    case "DbgColor":
                    case "DbgIndex":
                    case "opticalDensity":
                    case "illumination":
                        break;
                    case "DbgName":
                        l.name = h;
                        break;
                    case "blending":
                        l.blending = e[h];
                        break;
                    case "colorAmbient":
                    case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", u, "is no longer supported.");
                        break;
                    case "colorDiffuse":
                        l.color = t.fromArray(h).getHex();
                        break;
                    case "colorSpecular":
                        l.specular = t.fromArray(h).getHex();
                        break;
                    case "colorEmissive":
                        l.emissive = t.fromArray(h).getHex();
                        break;
                    case "specularCoef":
                        l.shininess = h;
                        break;
                    case "shading":
                        "basic" === h.toLowerCase() && (l.type = "MeshBasicMaterial"),
                        "phong" === h.toLowerCase() && (l.type = "MeshPhongMaterial"),
                        "standard" === h.toLowerCase() && (l.type = "MeshStandardMaterial");
                        break;
                    case "mapDiffuse":
                        l.map = c(h, i.mapDiffuseRepeat, i.mapDiffuseOffset, i.mapDiffuseWrap, i.mapDiffuseAnisotropy);
                        break;
                    case "mapDiffuseRepeat":
                    case "mapDiffuseOffset":
                    case "mapDiffuseWrap":
                    case "mapDiffuseAnisotropy":
                        break;
                    case "mapEmissive":
                        l.emissiveMap = c(h, i.mapEmissiveRepeat, i.mapEmissiveOffset, i.mapEmissiveWrap, i.mapEmissiveAnisotropy);
                        break;
                    case "mapEmissiveRepeat":
                    case "mapEmissiveOffset":
                    case "mapEmissiveWrap":
                    case "mapEmissiveAnisotropy":
                        break;
                    case "mapLight":
                        l.lightMap = c(h, i.mapLightRepeat, i.mapLightOffset, i.mapLightWrap, i.mapLightAnisotropy);
                        break;
                    case "mapLightRepeat":
                    case "mapLightOffset":
                    case "mapLightWrap":
                    case "mapLightAnisotropy":
                        break;
                    case "mapAO":
                        l.aoMap = c(h, i.mapAORepeat, i.mapAOOffset, i.mapAOWrap, i.mapAOAnisotropy);
                        break;
                    case "mapAORepeat":
                    case "mapAOOffset":
                    case "mapAOWrap":
                    case "mapAOAnisotropy":
                        break;
                    case "mapBump":
                        l.bumpMap = c(h, i.mapBumpRepeat, i.mapBumpOffset, i.mapBumpWrap, i.mapBumpAnisotropy);
                        break;
                    case "mapBumpScale":
                        l.bumpScale = h;
                        break;
                    case "mapBumpRepeat":
                    case "mapBumpOffset":
                    case "mapBumpWrap":
                    case "mapBumpAnisotropy":
                        break;
                    case "mapNormal":
                        l.normalMap = c(h, i.mapNormalRepeat, i.mapNormalOffset, i.mapNormalWrap, i.mapNormalAnisotropy);
                        break;
                    case "mapNormalFactor":
                        l.normalScale = h;
                        break;
                    case "mapNormalRepeat":
                    case "mapNormalOffset":
                    case "mapNormalWrap":
                    case "mapNormalAnisotropy":
                        break;
                    case "mapSpecular":
                        l.specularMap = c(h, i.mapSpecularRepeat, i.mapSpecularOffset, i.mapSpecularWrap, i.mapSpecularAnisotropy);
                        break;
                    case "mapSpecularRepeat":
                    case "mapSpecularOffset":
                    case "mapSpecularWrap":
                    case "mapSpecularAnisotropy":
                        break;
                    case "mapMetalness":
                        l.metalnessMap = c(h, i.mapMetalnessRepeat, i.mapMetalnessOffset, i.mapMetalnessWrap, i.mapMetalnessAnisotropy);
                        break;
                    case "mapMetalnessRepeat":
                    case "mapMetalnessOffset":
                    case "mapMetalnessWrap":
                    case "mapMetalnessAnisotropy":
                        break;
                    case "mapRoughness":
                        l.roughnessMap = c(h, i.mapRoughnessRepeat, i.mapRoughnessOffset, i.mapRoughnessWrap, i.mapRoughnessAnisotropy);
                        break;
                    case "mapRoughnessRepeat":
                    case "mapRoughnessOffset":
                    case "mapRoughnessWrap":
                    case "mapRoughnessAnisotropy":
                        break;
                    case "mapAlpha":
                        l.alphaMap = c(h, i.mapAlphaRepeat, i.mapAlphaOffset, i.mapAlphaWrap, i.mapAlphaAnisotropy);
                        break;
                    case "mapAlphaRepeat":
                    case "mapAlphaOffset":
                    case "mapAlphaWrap":
                    case "mapAlphaAnisotropy":
                        break;
                    case "flipSided":
                        l.side = d;
                        break;
                    case "doubleSided":
                        l.side = f;
                        break;
                    case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                        l.opacity = h;
                        break;
                    case "depthTest":
                    case "depthWrite":
                    case "colorWrite":
                    case "opacity":
                    case "reflectivity":
                    case "transparent":
                    case "visible":
                    case "wireframe":
                        l[u] = h;
                        break;
                    case "vertexColors":
                        !0 === h && (l.vertexColors = g),
                        "face" === h && (l.vertexColors = v);
                        break;
                    default:
                        console.error("THREE.Loader.createMaterial: Unsupported", u, h)
                    }
                }
                return "MeshBasicMaterial" === l.type && delete l.emissive,
                "MeshPhongMaterial" !== l.type && delete l.specular,
                l.opacity < 1 && (l.transparent = !0),
                n.setTextures(s),
                n.parse(l)
            }
        }()
    });
    var vs = {
        getContext: function() {
            return void 0 === as && (as = new (window.AudioContext || window.webkitAudioContext)),
            as
        },
        setContext: function(e) {
            as = e
        }
    };
    function gs(e) {
        this.manager = void 0 !== e ? e : pa
    }
    function ys() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Jn,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Jn,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1
    }
    function bs(e, t, r, n) {
        nr.call(this),
        this.type = "CubeCamera";
        var i = new Jn(90,1,e,t);
        i.up.set(0, -1, 0),
        i.lookAt(new Pt(1,0,0)),
        this.add(i);
        var o = new Jn(90,1,e,t);
        o.up.set(0, -1, 0),
        o.lookAt(new Pt(-1,0,0)),
        this.add(o);
        var a = new Jn(90,1,e,t);
        a.up.set(0, 0, 1),
        a.lookAt(new Pt(0,1,0)),
        this.add(a);
        var s = new Jn(90,1,e,t);
        s.up.set(0, 0, -1),
        s.lookAt(new Pt(0,-1,0)),
        this.add(s);
        var c = new Jn(90,1,e,t);
        c.up.set(0, -1, 0),
        c.lookAt(new Pt(0,0,1)),
        this.add(c);
        var l = new Jn(90,1,e,t);
        l.up.set(0, -1, 0),
        l.lookAt(new Pt(0,0,-1)),
        this.add(l),
        n = n || {
            format: Oe,
            magFilter: ve,
            minFilter: ve
        },
        this.renderTarget = new zt(r,r,n),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var r = e.getRenderTarget()
              , n = this.renderTarget
              , u = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            n.activeCubeFace = 0,
            e.render(t, i, n),
            n.activeCubeFace = 1,
            e.render(t, o, n),
            n.activeCubeFace = 2,
            e.render(t, a, n),
            n.activeCubeFace = 3,
            e.render(t, s, n),
            n.activeCubeFace = 4,
            e.render(t, c, n),
            n.texture.generateMipmaps = u,
            n.activeCubeFace = 5,
            e.render(t, l, n),
            e.setRenderTarget(r)
        }
        ,
        this.clear = function(e, t, r, n) {
            for (var i = e.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++)
                o.activeCubeFace = a,
                e.setRenderTarget(o),
                e.clear(t, r, n);
            e.setRenderTarget(i)
        }
    }
    function xs(e) {
        this.autoStart = void 0 === e || e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    function ws() {
        nr.call(this),
        this.type = "AudioListener",
        this.context = vs.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0
    }
    function _s(e) {
        nr.call(this),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.startTime = 0,
        this.offset = 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this.filters = []
    }
    function Ms(e) {
        _s.call(this, e),
        this.panner = this.context.createPanner(),
        this.panner.connect(this.gain)
    }
    function Ss(e, t) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== t ? t : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    function Es(e, t, r) {
        this.binding = e,
        this.valueSize = r;
        var n, i = Float64Array;
        switch (t) {
        case "quaternion":
            n = this._slerp;
            break;
        case "string":
        case "bool":
            i = Array,
            n = this._select;
            break;
        default:
            n = this._lerp
        }
        this.buffer = new i(4 * r),
        this._mixBufferRegion = n,
        this.cumulativeWeight = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    Object.assign(gs.prototype, {
        load: function(e, t, r, n) {
            var i = new fa(this.manager);
            i.setResponseType("arraybuffer"),
            i.setPath(this.path),
            i.load(e, function(e) {
                var r = e.slice(0);
                vs.getContext().decodeAudioData(r, function(e) {
                    t(e)
                })
            }, r, n)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(ys.prototype, {
        update: function() {
            var e, t, r, n, i, o, a, s, c = new At, l = new At;
            return function(u) {
                if (e !== this || t !== u.focus || r !== u.fov || n !== u.aspect * this.aspect || i !== u.near || o !== u.far || a !== u.zoom || s !== this.eyeSep) {
                    e = this,
                    t = u.focus,
                    r = u.fov,
                    n = u.aspect * this.aspect,
                    i = u.near,
                    o = u.far,
                    a = u.zoom;
                    var h, p, d = u.projectionMatrix.clone(), f = (s = this.eyeSep / 2) * i / t, m = i * Math.tan(Et.DEG2RAD * r * .5) / a;
                    l.elements[12] = -s,
                    c.elements[12] = s,
                    h = -m * n + f,
                    p = m * n + f,
                    d.elements[0] = 2 * i / (p - h),
                    d.elements[8] = (p + h) / (p - h),
                    this.cameraL.projectionMatrix.copy(d),
                    h = -m * n - f,
                    p = m * n - f,
                    d.elements[0] = 2 * i / (p - h),
                    d.elements[8] = (p + h) / (p - h),
                    this.cameraR.projectionMatrix.copy(d)
                }
                this.cameraL.matrixWorld.copy(u.matrixWorld).multiply(l),
                this.cameraR.matrixWorld.copy(u.matrixWorld).multiply(c)
            }
        }()
    }),
    bs.prototype = Object.create(nr.prototype),
    bs.prototype.constructor = bs,
    Object.assign(xs.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3,
                this.oldTime = t,
                this.elapsedTime += e
            }
            return e
        }
    }),
    ws.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: ws,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = e,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: function() {
            var e = new Pt
              , t = new Lt
              , r = new Pt
              , n = new Pt
              , i = new xs;
            return function(o) {
                nr.prototype.updateMatrixWorld.call(this, o);
                var a = this.context.listener
                  , s = this.up;
                if (this.timeDelta = i.getDelta(),
                this.matrixWorld.decompose(e, t, r),
                n.set(0, 0, -1).applyQuaternion(t),
                a.positionX) {
                    var c = this.context.currentTime + this.timeDelta;
                    a.positionX.linearRampToValueAtTime(e.x, c),
                    a.positionY.linearRampToValueAtTime(e.y, c),
                    a.positionZ.linearRampToValueAtTime(e.z, c),
                    a.forwardX.linearRampToValueAtTime(n.x, c),
                    a.forwardY.linearRampToValueAtTime(n.y, c),
                    a.forwardZ.linearRampToValueAtTime(n.z, c),
                    a.upX.linearRampToValueAtTime(s.x, c),
                    a.upY.linearRampToValueAtTime(s.y, c),
                    a.upZ.linearRampToValueAtTime(s.z, c)
                } else
                    a.setPosition(e.x, e.y, e.z),
                    a.setOrientation(n.x, n.y, n.z, s.x, s.y, s.z)
            }
        }()
    }),
    _s.prototype = Object.assign(Object.create(nr.prototype), {
        constructor: _s,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = e,
            this.connect(),
            this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(e),
            this.connect(),
            this
        },
        setBuffer: function(e) {
            return this.buffer = e,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function() {
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer,
                    e.loop = this.loop,
                    e.onended = this.onEnded.bind(this),
                    this.startTime = this.context.currentTime,
                    e.start(this.startTime, this.offset),
                    this.isPlaying = !0,
                    this.source = e,
                    this.setDetune(this.detune),
                    this.setPlaybackRate(this.playbackRate),
                    this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else
                console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this.source.stop(),
                this.source.onended = null,
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this.source.stop(),
                this.source.onended = null,
                this.offset = 0,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e || (e = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = e,
            this.connect()) : this.filters = e,
            this
        },
        setDetune: function(e) {
            if (this.detune = e,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = e,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = e,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        }
    }),
    Ms.prototype = Object.assign(Object.create(_s.prototype), {
        constructor: Ms,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e,
            this
        },
        setDirectionalCone: function(e, t, r) {
            return this.panner.coneInnerAngle = e,
            this.panner.coneOuterAngle = t,
            this.panner.coneOuterGain = r,
            this
        },
        updateMatrixWorld: function() {
            var e = new Pt
              , t = new Lt
              , r = new Pt
              , n = new Pt;
            return function(i) {
                if (nr.prototype.updateMatrixWorld.call(this, i),
                !1 !== this.isPlaying) {
                    this.matrixWorld.decompose(e, t, r),
                    n.set(0, 0, 1).applyQuaternion(t);
                    var o = this.panner;
                    if (o.positionX) {
                        var a = this.context.currentTime + this.listener.timeDelta;
                        o.positionX.linearRampToValueAtTime(e.x, a),
                        o.positionY.linearRampToValueAtTime(e.y, a),
                        o.positionZ.linearRampToValueAtTime(e.z, a),
                        o.orientationX.linearRampToValueAtTime(n.x, a),
                        o.orientationY.linearRampToValueAtTime(n.y, a),
                        o.orientationZ.linearRampToValueAtTime(n.z, a)
                    } else
                        o.setPosition(e.x, e.y, e.z),
                        o.setOrientation(n.x, n.y, n.z)
                }
            }
        }()
    }),
    Object.assign(Ss.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), r = 0; r < t.length; r++)
                e += t[r];
            return e / t.length
        }
    }),
    Object.assign(Es.prototype, {
        accumulate: function(e, t) {
            var r = this.buffer
              , n = this.valueSize
              , i = e * n + n
              , o = this.cumulativeWeight;
            if (0 === o) {
                for (var a = 0; a !== n; ++a)
                    r[i + a] = r[a];
                o = t
            } else {
                var s = t / (o += t);
                this._mixBufferRegion(r, i, 0, s, n)
            }
            this.cumulativeWeight = o
        },
        apply: function(e) {
            var t = this.valueSize
              , r = this.buffer
              , n = e * t + t
              , i = this.cumulativeWeight
              , o = this.binding;
            if (this.cumulativeWeight = 0,
            i < 1) {
                var a = 3 * t;
                this._mixBufferRegion(r, n, a, 1 - i, t)
            }
            for (var s = t, c = t + t; s !== c; ++s)
                if (r[s] !== r[s + t]) {
                    o.setValue(r, n);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.binding
              , t = this.buffer
              , r = this.valueSize
              , n = 3 * r;
            e.getValue(t, n);
            for (var i = r, o = n; i !== o; ++i)
                t[i] = t[n + i % r];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        },
        _select: function(e, t, r, n, i) {
            if (n >= .5)
                for (var o = 0; o !== i; ++o)
                    e[t + o] = e[r + o]
        },
        _slerp: function(e, t, r, n) {
            Lt.slerpFlat(e, t, e, t, e, r, n)
        },
        _lerp: function(e, t, r, n, i) {
            for (var o = 1 - n, a = 0; a !== i; ++a) {
                var s = t + a;
                e[s] = e[s] * o + e[r + a] * n
            }
        }
    });
    var Ts, As;
    function Ls(e, t, r) {
        var n = r || Ps.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, n)
    }
    function Ps(e, t, r) {
        this.path = t,
        this.parsedPath = r || Ps.parseTrackName(t),
        this.node = Ps.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e
    }
    function Cs() {
        this.uuid = Et.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, r = arguments.length; t !== r; ++t)
            e[arguments[t].uuid] = t;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }
    function Rs(e, t, r) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = r || null;
        for (var n = t.tracks, i = n.length, o = new Array(i), a = {
            endingStart: ut,
            endingEnd: ut
        }, s = 0; s !== i; ++s) {
            var c = n[s].createInterpolant(null);
            o[s] = c,
            c.settings = a
        }
        this._interpolantSettings = a,
        this._interpolants = o,
        this._propertyBindings = new Array(i),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = lt,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    function Os(e) {
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    function Is(e) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        e = arguments[1]),
        this.value = e
    }
    function Ns() {
        br.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function Ds(e, t, r) {
        ai.call(this, e, t),
        this.meshPerAttribute = r || 1
    }
    function Bs(e, t, r, n) {
        "number" == typeof r && (n = r,
        r = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        ar.call(this, e, t, r),
        this.meshPerAttribute = n || 1
    }
    function zs(e, t, r, n) {
        this.ray = new Ar(e,t),
        this.near = r || 0,
        this.far = n || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function Gs(e, t) {
        return e.distance - t.distance
    }
    function Us(e, t, r, n) {
        if (!1 !== e.visible && (e.raycast(t, r),
        !0 === n))
            for (var i = e.children, o = 0, a = i.length; o < a; o++)
                Us(i[o], t, r, !0)
    }
    function js(e, t, r) {
        return this.radius = void 0 !== e ? e : 1,
        this.phi = void 0 !== t ? t : 0,
        this.theta = void 0 !== r ? r : 0,
        this
    }
    function Fs(e, t, r) {
        return this.radius = void 0 !== e ? e : 1,
        this.theta = void 0 !== t ? t : 0,
        this.y = void 0 !== r ? r : 0,
        this
    }
    function ks(e, t) {
        this.min = void 0 !== e ? e : new Tt(1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new Tt(-1 / 0,-1 / 0)
    }
    function Hs(e, t) {
        this.start = void 0 !== e ? e : new Pt,
        this.end = void 0 !== t ? t : new Pt
    }
    function Vs(e) {
        nr.call(this),
        this.material = e,
        this.render = function() {}
    }
    function Ws(e, t, r, n) {
        this.object = e,
        this.size = void 0 !== t ? t : 1;
        var i = void 0 !== r ? r : 16711680
          , o = void 0 !== n ? n : 1
          , a = 0
          , s = this.object.geometry;
        s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
        var c = new br
          , l = new fr(2 * a * 3,3);
        c.addAttribute("position", l),
        vi.call(this, c, new fi({
            color: i,
            linewidth: o
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function qs(e, t) {
        nr.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t;
        for (var r = new br, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++,
        o++) {
            var a = i / 32 * Math.PI * 2
              , s = o / 32 * Math.PI * 2;
            n.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
        }
        r.addAttribute("position", new fr(n,3));
        var c = new fi({
            fog: !1
        });
        this.cone = new vi(r,c),
        this.add(this.cone),
        this.update()
    }
    function Xs(e) {
        for (var t = function e(t) {
            var r = [];
            t && t.isBone && r.push(t);
            for (var n = 0; n < t.children.length; n++)
                r.push.apply(r, e(t.children[n]));
            return r
        }(e), r = new br, n = [], i = [], o = new Yt(0,0,1), a = new Yt(0,1,0), s = 0; s < t.length; s++) {
            var c = t[s];
            c.parent && c.parent.isBone && (n.push(0, 0, 0),
            n.push(0, 0, 0),
            i.push(o.r, o.g, o.b),
            i.push(a.r, a.g, a.b))
        }
        r.addAttribute("position", new fr(n,3)),
        r.addAttribute("color", new fr(i,3));
        var l = new fi({
            vertexColors: g,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        vi.call(this, r, l),
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function Ys(e, t, r) {
        this.light = e,
        this.light.updateMatrixWorld(),
        this.color = r;
        var n = new _o(t,4,2)
          , i = new Pr({
            wireframe: !0,
            fog: !1
        });
        Cr.call(this, n, i),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Js(e, t) {
        this.type = "RectAreaLightHelper",
        this.light = e,
        this.color = t;
        var r = new br;
        r.addAttribute("position", new fr([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
        r.computeBoundingSphere();
        var n = new fi({
            fog: !1
        });
        mi.call(this, r, n);
        var i = new br;
        i.addAttribute("position", new fr([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
        i.computeBoundingSphere(),
        this.add(new Cr(i,new Pr({
            side: d,
            fog: !1
        }))),
        this.update()
    }
    function Zs(e, t, r) {
        nr.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r;
        var n = new Oi(t);
        n.rotateY(.5 * Math.PI),
        this.material = new Pr({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = g);
        var i = n.getAttribute("position")
          , o = new Float32Array(3 * i.count);
        n.addAttribute("color", new ar(o,3)),
        this.add(new Cr(n,this.material)),
        this.update()
    }
    function Ks(e, t, r, n) {
        e = e || 10,
        t = t || 10,
        r = new Yt(void 0 !== r ? r : 4473924),
        n = new Yt(void 0 !== n ? n : 8947848);
        for (var i = t / 2, o = e / t, a = e / 2, s = [], c = [], l = 0, u = 0, h = -a; l <= t; l++,
        h += o) {
            s.push(-a, 0, h, a, 0, h),
            s.push(h, 0, -a, h, 0, a);
            var p = l === i ? r : n;
            p.toArray(c, u),
            u += 3,
            p.toArray(c, u),
            u += 3,
            p.toArray(c, u),
            u += 3,
            p.toArray(c, u),
            u += 3
        }
        var d = new br;
        d.addAttribute("position", new fr(s,3)),
        d.addAttribute("color", new fr(c,3));
        var f = new fi({
            vertexColors: g
        });
        vi.call(this, d, f)
    }
    function Qs(e, t, r, n, i, o) {
        e = e || 10,
        t = t || 16,
        r = r || 8,
        n = n || 64,
        i = new Yt(void 0 !== i ? i : 4473924),
        o = new Yt(void 0 !== o ? o : 8947848);
        var a, s, c, l, u, h, p, d = [], f = [];
        for (l = 0; l <= t; l++)
            c = l / t * (2 * Math.PI),
            a = Math.sin(c) * e,
            s = Math.cos(c) * e,
            d.push(0, 0, 0),
            d.push(a, 0, s),
            p = 1 & l ? i : o,
            f.push(p.r, p.g, p.b),
            f.push(p.r, p.g, p.b);
        for (l = 0; l <= r; l++)
            for (p = 1 & l ? i : o,
            h = e - e / r * l,
            u = 0; u < n; u++)
                c = u / n * (2 * Math.PI),
                a = Math.sin(c) * h,
                s = Math.cos(c) * h,
                d.push(a, 0, s),
                f.push(p.r, p.g, p.b),
                c = (u + 1) / n * (2 * Math.PI),
                a = Math.sin(c) * h,
                s = Math.cos(c) * h,
                d.push(a, 0, s),
                f.push(p.r, p.g, p.b);
        var m = new br;
        m.addAttribute("position", new fr(d,3)),
        m.addAttribute("color", new fr(f,3));
        var v = new fi({
            vertexColors: g
        });
        vi.call(this, m, v)
    }
    function $s(e, t, r, n) {
        this.object = e,
        this.size = void 0 !== t ? t : 1;
        var i = void 0 !== r ? r : 16776960
          , o = void 0 !== n ? n : 1
          , a = 0
          , s = this.object.geometry;
        s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var c = new br
          , l = new fr(2 * a * 3,3);
        c.addAttribute("position", l),
        vi.call(this, c, new fi({
            color: i,
            linewidth: o
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function ec(e, t, r) {
        nr.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = r,
        void 0 === t && (t = 1);
        var n = new br;
        n.addAttribute("position", new fr([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        var i = new fi({
            fog: !1
        });
        this.lightPlane = new mi(n,i),
        this.add(this.lightPlane),
        (n = new br).addAttribute("position", new fr([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new mi(n,i),
        this.add(this.targetLine),
        this.update()
    }
    function tc(e) {
        var t = new br
          , r = new fi({
            color: 16777215,
            vertexColors: v
        })
          , n = []
          , i = []
          , o = {}
          , a = new Yt(16755200)
          , s = new Yt(16711680)
          , c = new Yt(43775)
          , l = new Yt(16777215)
          , u = new Yt(3355443);
        function h(e, t, r) {
            p(e, r),
            p(t, r)
        }
        function p(e, t) {
            n.push(0, 0, 0),
            i.push(t.r, t.g, t.b),
            void 0 === o[e] && (o[e] = []),
            o[e].push(n.length / 3 - 1)
        }
        h("n1", "n2", a),
        h("n2", "n4", a),
        h("n4", "n3", a),
        h("n3", "n1", a),
        h("f1", "f2", a),
        h("f2", "f4", a),
        h("f4", "f3", a),
        h("f3", "f1", a),
        h("n1", "f1", a),
        h("n2", "f2", a),
        h("n3", "f3", a),
        h("n4", "f4", a),
        h("p", "n1", s),
        h("p", "n2", s),
        h("p", "n3", s),
        h("p", "n4", s),
        h("u1", "u2", c),
        h("u2", "u3", c),
        h("u3", "u1", c),
        h("c", "t", l),
        h("p", "c", u),
        h("cn1", "cn2", u),
        h("cn3", "cn4", u),
        h("cf1", "cf2", u),
        h("cf3", "cf4", u),
        t.addAttribute("position", new fr(n,3)),
        t.addAttribute("color", new fr(i,3)),
        vi.call(this, t, r),
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update()
    }
    function rc(e, t) {
        this.object = e,
        void 0 === t && (t = 16776960);
        var r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , n = new Float32Array(24)
          , i = new br;
        i.setIndex(new ar(r,1)),
        i.addAttribute("position", new ar(n,3)),
        vi.call(this, i, new fi({
            color: t
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function nc(e, t) {
        this.type = "Box3Helper",
        this.box = e;
        var r = void 0 !== t ? t : 16776960
          , n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new br;
        i.setIndex(new ar(n,1)),
        i.addAttribute("position", new fr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        vi.call(this, i, new fi({
            color: r
        })),
        this.geometry.computeBoundingSphere()
    }
    function ic(e, t, r) {
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = void 0 === t ? 1 : t;
        var n = void 0 !== r ? r : 16776960
          , i = new br;
        i.addAttribute("position", new fr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        i.computeBoundingSphere(),
        mi.call(this, i, new fi({
            color: n
        }));
        var o = new br;
        o.addAttribute("position", new fr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        o.computeBoundingSphere(),
        this.add(new Cr(o,new Pr({
            color: n,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function oc(e, t, r, n, i, o) {
        nr.call(this),
        void 0 === e && (e = new Pt(0,0,1)),
        void 0 === t && (t = new Pt(0,0,0)),
        void 0 === r && (r = 1),
        void 0 === n && (n = 16776960),
        void 0 === i && (i = .2 * r),
        void 0 === o && (o = .2 * i),
        void 0 === Ts && ((Ts = new br).addAttribute("position", new fr([0, 0, 0, 0, 1, 0],3)),
        (As = new Oo(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new mi(Ts,new fi({
            color: n
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Cr(As,new Pr({
            color: n
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(r, i, o)
    }
    function ac(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , r = new br;
        r.addAttribute("position", new fr(t,3)),
        r.addAttribute("color", new fr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
        var n = new fi({
            vertexColors: g
        });
        vi.call(this, r, n)
    }
    Object.assign(Ls.prototype, {
        getValue: function(e, t) {
            this.bind();
            var r = this._targetGroup.nCachedObjects_
              , n = this._bindings[r];
            void 0 !== n && n.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var r = this._bindings, n = this._targetGroup.nCachedObjects_, i = r.length; n !== i; ++n)
                r[n].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
                e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
                e[t].unbind()
        }
    }),
    Object.assign(Ps, {
        Composite: Ls,
        create: function(e, t, r) {
            return e && e.isAnimationObjectGroup ? new Ps.Composite(e,t,r) : new Ps(e,t,r)
        },
        sanitizeNodeName: function() {
            var e = new RegExp("[\\[\\]\\.:\\/]","g");
            return function(t) {
                return t.replace(/\s/g, "_").replace(e, "")
            }
        }(),
        parseTrackName: function() {
            var e = "[^\\[\\]\\.:\\/]"
              , t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
              , r = /((?:WC+[\/:])*)/.source.replace("WC", e)
              , n = /(WCOD+)?/.source.replace("WCOD", t)
              , i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", e)
              , o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", e)
              , a = new RegExp("^" + r + n + i + o + "$")
              , s = ["material", "materials", "bones"];
            return function(e) {
                var t = a.exec(e);
                if (!t)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                var r = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }
                  , n = r.nodeName && r.nodeName.lastIndexOf(".");
                if (void 0 !== n && -1 !== n) {
                    var i = r.nodeName.substring(n + 1);
                    -1 !== s.indexOf(i) && (r.nodeName = r.nodeName.substring(0, n),
                    r.objectName = i)
                }
                if (null === r.propertyName || 0 === r.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return r
            }
        }(),
        findNode: function(e, t) {
            if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                return e;
            if (e.skeleton) {
                var r = e.skeleton.getBoneByName(t);
                if (void 0 !== r)
                    return r
            }
            if (e.children) {
                var n = function e(r) {
                    for (var n = 0; n < r.length; n++) {
                        var i = r[n];
                        if (i.name === t || i.uuid === t)
                            return i;
                        var o = e(i.children);
                        if (o)
                            return o
                    }
                    return null
                }(e.children);
                if (n)
                    return n
            }
            return null
        }
    }),
    Object.assign(Ps.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }
        , function(e, t) {
            for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)
                e[t++] = r[n]
        }
        , function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        , function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)
                r[n] = e[t++]
        }
        , function(e, t) {
            for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)
                r[n] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            for (var r = this.resolvedProperty, n = 0, i = r.length; n !== i; ++n)
                r[n] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(e, t) {
            this.bind(),
            this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(),
            this.setValue(e, t)
        },
        bind: function() {
            var e = this.node
              , t = this.parsedPath
              , r = t.objectName
              , n = t.propertyName
              , i = t.propertyIndex;
            if (e || (e = Ps.findNode(this.rootNode, t.nodeName) || this.rootNode,
            this.node = e),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            e) {
                if (r) {
                    var o = t.objectIndex;
                    switch (r) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (var a = 0; a < e.length; a++)
                            if (e[a].name === o) {
                                o = a;
                                break
                            }
                        break;
                    default:
                        if (void 0 === e[r])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[r]
                    }
                    if (void 0 !== o) {
                        if (void 0 === e[o])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[o]
                    }
                }
                var s = e[n];
                if (void 0 !== s) {
                    var c = this.Versioning.None;
                    this.targetObject = e,
                    void 0 !== e.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                    var l = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                    if (e.geometry.morphAttributes.position[a].name === i) {
                                        i = a;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                    if (e.geometry.morphTargets[a].name === i) {
                                        i = a;
                                        break
                                    }
                            }
                        }
                        l = this.BindingType.ArrayElement,
                        this.resolvedProperty = s,
                        this.propertyIndex = i
                    } else
                        void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray,
                        this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray,
                        this.resolvedProperty = s) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[l],
                    this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                } else {
                    var u = t.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + n + " but it wasn't found.", e)
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(Ps.prototype, {
        _getValue_unbound: Ps.prototype.getValue,
        _setValue_unbound: Ps.prototype.setValue
    }),
    Object.assign(Cs.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = e.length, r = this.nCachedObjects_, n = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, u = arguments.length; l !== u; ++l) {
                var h = arguments[l]
                  , p = h.uuid
                  , d = n[p];
                if (void 0 === d) {
                    d = t++,
                    n[p] = d,
                    e.push(h);
                    for (var f = 0, m = s; f !== m; ++f)
                        a[f].push(new Ps(h,i[f],o[f]))
                } else if (d < r) {
                    c = e[d];
                    var v = --r
                      , g = e[v];
                    n[g.uuid] = d,
                    e[d] = g,
                    n[p] = v,
                    e[v] = h;
                    for (f = 0,
                    m = s; f !== m; ++f) {
                        var y = a[f]
                          , b = y[v]
                          , x = y[d];
                        y[d] = b,
                        void 0 === x && (x = new Ps(h,i[f],o[f])),
                        y[v] = x
                    }
                } else
                    e[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = r
        },
        remove: function() {
            for (var e = this._objects, t = this.nCachedObjects_, r = this._indicesByUUID, n = this._bindings, i = n.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o]
                  , c = s.uuid
                  , l = r[c];
                if (void 0 !== l && l >= t) {
                    var u = t++
                      , h = e[u];
                    r[h.uuid] = l,
                    e[l] = h,
                    r[c] = u,
                    e[u] = s;
                    for (var p = 0, d = i; p !== d; ++p) {
                        var f = n[p]
                          , m = f[u]
                          , v = f[l];
                        f[l] = m,
                        f[u] = v
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function() {
            for (var e = this._objects, t = e.length, r = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                var c = arguments[a].uuid
                  , l = n[c];
                if (void 0 !== l)
                    if (delete n[c],
                    l < r) {
                        var u = --r
                          , h = e[u]
                          , p = e[g = --t];
                        n[h.uuid] = l,
                        e[l] = h,
                        n[p.uuid] = u,
                        e[u] = p,
                        e.pop();
                        for (var d = 0, f = o; d !== f; ++d) {
                            var m = (y = i[d])[u]
                              , v = y[g];
                            y[l] = m,
                            y[u] = v,
                            y.pop()
                        }
                    } else {
                        var g;
                        n[(p = e[g = --t]).uuid] = l,
                        e[l] = p,
                        e.pop();
                        for (d = 0,
                        f = o; d !== f; ++d) {
                            var y;
                            (y = i[d])[l] = y[g],
                            y.pop()
                        }
                    }
            }
            this.nCachedObjects_ = r
        },
        subscribe_: function(e, t) {
            var r = this._bindingsIndicesByPath
              , n = r[e]
              , i = this._bindings;
            if (void 0 !== n)
                return i[n];
            var o = this._paths
              , a = this._parsedPaths
              , s = this._objects
              , c = s.length
              , l = this.nCachedObjects_
              , u = new Array(c);
            n = i.length,
            r[e] = n,
            o.push(e),
            a.push(t),
            i.push(u);
            for (var h = l, p = s.length; h !== p; ++h) {
                var d = s[h];
                u[h] = new Ps(d,e,t)
            }
            return u
        },
        unsubscribe_: function(e) {
            var t = this._bindingsIndicesByPath
              , r = t[e];
            if (void 0 !== r) {
                var n = this._paths
                  , i = this._parsedPaths
                  , o = this._bindings
                  , a = o.length - 1
                  , s = o[a];
                t[e[a]] = r,
                o[r] = s,
                o.pop(),
                i[r] = i[a],
                i.pop(),
                n[r] = n[a],
                n.pop()
            }
        }
    }),
    Object.assign(Rs.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(e) {
            return this._startTime = e,
            this
        },
        setLoop: function(e, t) {
            return this.loop = e,
            this.repetitions = t,
            this
        },
        setEffectiveWeight: function(e) {
            return this.weight = e,
            this._effectiveWeight = this.enabled ? e : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function(e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function(e, t, r) {
            if (e.fadeOut(t),
            this.fadeIn(t),
            r) {
                var n = this._clip.duration
                  , i = e._clip.duration
                  , o = i / n
                  , a = n / i;
                e.warp(1, o, t),
                this.warp(a, 1, t)
            }
            return this
        },
        crossFadeTo: function(e, t, r) {
            return e.crossFadeFrom(this, t, r)
        },
        stopFading: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        setEffectiveTimeScale: function(e) {
            return this.timeScale = e,
            this._effectiveTimeScale = this.paused ? 0 : e,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(e) {
            return this.timeScale = this._clip.duration / e,
            this.stopWarping()
        },
        syncWith: function(e) {
            return this.time = e.time,
            this.timeScale = e.timeScale,
            this.stopWarping()
        },
        halt: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function(e, t, r) {
            var n = this._mixer
              , i = n.time
              , o = this._timeScaleInterpolant
              , a = this.timeScale;
            null === o && (o = n._lendControlInterpolant(),
            this._timeScaleInterpolant = o);
            var s = o.parameterPositions
              , c = o.sampleValues;
            return s[0] = i,
            s[1] = i + r,
            c[0] = e / a,
            c[1] = t / a,
            this
        },
        stopWarping: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(e, t, r, n) {
            if (this.enabled) {
                var i = this._startTime;
                if (null !== i) {
                    var o = (e - i) * r;
                    if (o < 0 || 0 === r)
                        return;
                    this._startTime = null,
                    t = r * o
                }
                t *= this._updateTimeScale(e);
                var a = this._updateTime(t)
                  , s = this._updateWeight(e);
                if (s > 0)
                    for (var c = this._interpolants, l = this._propertyBindings, u = 0, h = c.length; u !== h; ++u)
                        c[u].evaluate(a),
                        l[u].accumulate(n, s)
            } else
                this._updateWeight(e)
        },
        _updateWeight: function(e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var r = this._weightInterpolant;
                if (null !== r) {
                    var n = r.evaluate(e)[0];
                    t *= n,
                    e > r.parameterPositions[1] && (this.stopFading(),
                    0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t,
            t
        },
        _updateTimeScale: function(e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var r = this._timeScaleInterpolant;
                if (null !== r)
                    t *= r.evaluate(e)[0],
                    e > r.parameterPositions[1] && (this.stopWarping(),
                    0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t,
            t
        },
        _updateTime: function(e) {
            var t = this.time + e
              , r = this._clip.duration
              , n = this.loop
              , i = this._loopCount
              , o = 2202 === n;
            if (0 === e)
                return -1 === i ? t : o && 1 == (1 & i) ? r - t : t;
            if (2200 === n) {
                -1 === i && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                e: {
                    if (t >= r)
                        t = r;
                    else {
                        if (!(t < 0))
                            break e;
                        t = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === i && (e >= 0 ? (i = 0,
                this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
                t >= r || t < 0) {
                    var a = Math.floor(t / r);
                    t -= r * a,
                    i += Math.abs(a);
                    var s = this.repetitions - i;
                    if (s <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        t = e > 0 ? r : 0,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                    else {
                        if (1 === s) {
                            var c = e < 0;
                            this._setEndings(c, !c, o)
                        } else
                            this._setEndings(!1, !1, o);
                        this._loopCount = i,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: a
                        })
                    }
                }
                if (o && 1 == (1 & i))
                    return this.time = t,
                    r - t
            }
            return this.time = t,
            t
        },
        _setEndings: function(e, t, r) {
            var n = this._interpolantSettings;
            r ? (n.endingStart = 2401,
            n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : ut : 2402,
            n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : ut : 2402)
        },
        _scheduleFading: function(e, t, r) {
            var n = this._mixer
              , i = n.time
              , o = this._weightInterpolant;
            null === o && (o = n._lendControlInterpolant(),
            this._weightInterpolant = o);
            var a = o.parameterPositions
              , s = o.sampleValues;
            return a[0] = i,
            s[0] = t,
            a[1] = i + e,
            s[1] = r,
            this
        }
    }),
    Os.prototype = Object.assign(Object.create(i.prototype), {
        constructor: Os,
        _bindAction: function(e, t) {
            var r = e._localRoot || this._root
              , n = e._clip.tracks
              , i = n.length
              , o = e._propertyBindings
              , a = e._interpolants
              , s = r.uuid
              , c = this._bindingsByRootAndName
              , l = c[s];
            void 0 === l && (l = {},
            c[s] = l);
            for (var u = 0; u !== i; ++u) {
                var h = n[u]
                  , p = h.name
                  , d = l[p];
                if (void 0 !== d)
                    o[u] = d;
                else {
                    if (void 0 !== (d = o[u])) {
                        null === d._cacheIndex && (++d.referenceCount,
                        this._addInactiveBinding(d, s, p));
                        continue
                    }
                    var f = t && t._propertyBindings[u].binding.parsedPath;
                    ++(d = new Es(Ps.create(r, p, f),h.ValueTypeName,h.getValueSize())).referenceCount,
                    this._addInactiveBinding(d, s, p),
                    o[u] = d
                }
                a[u].resultBuffer = d.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid
                      , r = e._clip.uuid
                      , n = this._actionsByClip[r];
                    this._bindAction(e, n && n.knownActions[0]),
                    this._addInactiveAction(e, r, t)
                }
                for (var i = e._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                    var s = i[o];
                    0 == s.useCount++ && (this._lendBinding(s),
                    s.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
                    var i = t[r];
                    0 == --i.useCount && (i.restoreOriginalState(),
                    this._takeBackBinding(i))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        },
        _addInactiveAction: function(e, t, r) {
            var n = this._actions
              , i = this._actionsByClip
              , o = i[t];
            if (void 0 === o)
                o = {
                    knownActions: [e],
                    actionByRoot: {}
                },
                e._byClipCacheIndex = 0,
                i[t] = o;
            else {
                var a = o.knownActions;
                e._byClipCacheIndex = a.length,
                a.push(e)
            }
            e._cacheIndex = n.length,
            n.push(e),
            o.actionByRoot[r] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions
              , r = t[t.length - 1]
              , n = e._cacheIndex;
            r._cacheIndex = n,
            t[n] = r,
            t.pop(),
            e._cacheIndex = null;
            var i = e._clip.uuid
              , o = this._actionsByClip
              , a = o[i]
              , s = a.knownActions
              , c = s[s.length - 1]
              , l = e._byClipCacheIndex;
            c._byClipCacheIndex = l,
            s[l] = c,
            s.pop(),
            e._byClipCacheIndex = null,
            delete a.actionByRoot[(e._localRoot || this._root).uuid],
            0 === s.length && delete o[i],
            this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = e._propertyBindings, r = 0, n = t.length; r !== n; ++r) {
                var i = t[r];
                0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
        },
        _lendAction: function(e) {
            var t = this._actions
              , r = e._cacheIndex
              , n = this._nActiveActions++
              , i = t[n];
            e._cacheIndex = n,
            t[n] = e,
            i._cacheIndex = r,
            t[r] = i
        },
        _takeBackAction: function(e) {
            var t = this._actions
              , r = e._cacheIndex
              , n = --this._nActiveActions
              , i = t[n];
            e._cacheIndex = n,
            t[n] = e,
            i._cacheIndex = r,
            t[r] = i
        },
        _addInactiveBinding: function(e, t, r) {
            var n = this._bindingsByRootAndName
              , i = n[t]
              , o = this._bindings;
            void 0 === i && (i = {},
            n[t] = i),
            i[r] = e,
            e._cacheIndex = o.length,
            o.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings
              , r = e.binding
              , n = r.rootNode.uuid
              , i = r.path
              , o = this._bindingsByRootAndName
              , a = o[n]
              , s = t[t.length - 1]
              , c = e._cacheIndex;
            s._cacheIndex = c,
            t[c] = s,
            t.pop(),
            delete a[i];
            e: {
                for (var l in a)
                    break e;
                delete o[n]
            }
        },
        _lendBinding: function(e) {
            var t = this._bindings
              , r = e._cacheIndex
              , n = this._nActiveBindings++
              , i = t[n];
            e._cacheIndex = n,
            t[n] = e,
            i._cacheIndex = r,
            t[r] = i
        },
        _takeBackBinding: function(e) {
            var t = this._bindings
              , r = e._cacheIndex
              , n = --this._nActiveBindings
              , i = t[n];
            e._cacheIndex = n,
            t[n] = e,
            i._cacheIndex = r,
            t[r] = i
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants
              , t = this._nActiveControlInterpolants++
              , r = e[t];
            return void 0 === r && ((r = new Qo(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = t,
            e[t] = r),
            r
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants
              , r = e.__cacheIndex
              , n = --this._nActiveControlInterpolants
              , i = t[n];
            e.__cacheIndex = n,
            t[n] = e,
            i.__cacheIndex = r,
            t[r] = i
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t) {
            var r = t || this._root
              , n = r.uuid
              , i = "string" == typeof e ? ca.findByName(r, e) : e
              , o = null !== i ? i.uuid : e
              , a = this._actionsByClip[o]
              , s = null;
            if (void 0 !== a) {
                var c = a.actionByRoot[n];
                if (void 0 !== c)
                    return c;
                s = a.knownActions[0],
                null === i && (i = s._clip)
            }
            if (null === i)
                return null;
            var l = new Rs(this,i,t);
            return this._bindAction(l, s),
            this._addInactiveAction(l, o, n),
            l
        },
        existingAction: function(e, t) {
            var r = t || this._root
              , n = r.uuid
              , i = "string" == typeof e ? ca.findByName(r, e) : e
              , o = i ? i.uuid : e
              , a = this._actionsByClip[o];
            return void 0 !== a && a.actionByRoot[n] || null
        },
        stopAllAction: function() {
            var e = this._actions
              , t = this._nActiveActions
              , r = this._bindings
              , n = this._nActiveBindings;
            this._nActiveActions = 0,
            this._nActiveBindings = 0;
            for (var i = 0; i !== t; ++i)
                e[i].reset();
            for (i = 0; i !== n; ++i)
                r[i].useCount = 0;
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, r = this._nActiveActions, n = this.time += e, i = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== r; ++a) {
                t[a]._update(n, e, i, o)
            }
            var s = this._bindings
              , c = this._nActiveBindings;
            for (a = 0; a !== c; ++a)
                s[a].apply(o);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions
              , r = e.uuid
              , n = this._actionsByClip
              , i = n[r];
            if (void 0 !== i) {
                for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                    var c = o[a];
                    this._deactivateAction(c);
                    var l = c._cacheIndex
                      , u = t[t.length - 1];
                    c._cacheIndex = null,
                    c._byClipCacheIndex = null,
                    u._cacheIndex = l,
                    t[l] = u,
                    t.pop(),
                    this._removeInactiveBindingsForAction(c)
                }
                delete n[r]
            }
        },
        uncacheRoot: function(e) {
            var t = e.uuid
              , r = this._actionsByClip;
            for (var n in r) {
                var i = r[n].actionByRoot[t];
                void 0 !== i && (this._deactivateAction(i),
                this._removeInactiveAction(i))
            }
            var o = this._bindingsByRootAndName[t];
            if (void 0 !== o)
                for (var a in o) {
                    var s = o[a];
                    s.restoreOriginalState(),
                    this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function(e, t) {
            var r = this.existingAction(e, t);
            null !== r && (this._deactivateAction(r),
            this._removeInactiveAction(r))
        }
    }),
    Is.prototype.clone = function() {
        return new Is(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    Ns.prototype = Object.assign(Object.create(br.prototype), {
        constructor: Ns,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return br.prototype.copy.call(this, e),
            this.maxInstancedCount = e.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Ds.prototype = Object.assign(Object.create(ai.prototype), {
        constructor: Ds,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return ai.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    Bs.prototype = Object.assign(Object.create(ar.prototype), {
        constructor: Bs,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return ar.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    Object.assign(zs.prototype, {
        linePrecision: 1,
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(e, t, r) {
            var n = r || [];
            return Us(e, this, n, t),
            n.sort(Gs),
            n
        },
        intersectObjects: function(e, t, r) {
            var n = r || [];
            if (!1 === Array.isArray(e))
                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                n;
            for (var i = 0, o = e.length; i < o; i++)
                Us(e[i], this, n, t);
            return n.sort(Gs),
            n
        }
    }),
    Object.assign(js.prototype, {
        set: function(e, t, r) {
            return this.radius = e,
            this.phi = t,
            this.theta = r,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.phi = e.phi,
            this.theta = e.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, r) {
            return this.radius = Math.sqrt(e * e + t * t + r * r),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(e, r),
            this.phi = Math.acos(Et.clamp(t / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(Fs.prototype, {
        set: function(e, t, r) {
            return this.radius = e,
            this.theta = t,
            this.y = r,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.theta = e.theta,
            this.y = e.y,
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, r) {
            return this.radius = Math.sqrt(e * e + r * r),
            this.theta = Math.atan2(e, r),
            this.y = t,
            this
        }
    }),
    Object.assign(ks.prototype, {
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, r = e.length; t < r; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new Tt;
            return function(t, r) {
                var n = e.copy(r).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"),
            e = new Tt),
            this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"),
            e = new Tt),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"),
            t = new Tt),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"),
            t = new Tt),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new Tt;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(Hs.prototype, {
        set: function(e, t) {
            return this.start.copy(e),
            this.end.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start),
            this.end.copy(e.end),
            this
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"),
            e = new Pt),
            e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"),
            e = new Pt),
            e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"),
            t = new Pt),
            this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: function() {
            var e = new Pt
              , t = new Pt;
            return function(r, n) {
                e.subVectors(r, this.start),
                t.subVectors(this.end, this.start);
                var i = t.dot(t)
                  , o = t.dot(e) / i;
                return n && (o = Et.clamp(o, 0, 1)),
                o
            }
        }(),
        closestPointToPoint: function(e, t, r) {
            var n = this.closestPointToPointParameter(e, t);
            return void 0 === r && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            r = new Pt),
            this.delta(r).multiplyScalar(n).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e),
            this.end.applyMatrix4(e),
            this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }),
    Vs.prototype = Object.create(nr.prototype),
    Vs.prototype.constructor = Vs,
    Vs.prototype.isImmediateRenderObject = !0,
    Ws.prototype = Object.create(vi.prototype),
    Ws.prototype.constructor = Ws,
    Ws.prototype.update = function() {
        var e = new Pt
          , t = new Pt
          , r = new Ct;
        return function() {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0),
            r.getNormalMatrix(this.object.matrixWorld);
            var i = this.object.matrixWorld
              , o = this.geometry.attributes.position
              , a = this.object.geometry;
            if (a && a.isGeometry)
                for (var s = a.vertices, c = a.faces, l = 0, u = 0, h = c.length; u < h; u++)
                    for (var p = c[u], d = 0, f = p.vertexNormals.length; d < f; d++) {
                        var m = s[p[n[d]]]
                          , v = p.vertexNormals[d];
                        e.copy(m).applyMatrix4(i),
                        t.copy(v).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                        o.setXYZ(l, e.x, e.y, e.z),
                        l += 1,
                        o.setXYZ(l, t.x, t.y, t.z),
                        l += 1
                    }
            else if (a && a.isBufferGeometry) {
                var g = a.attributes.position
                  , y = a.attributes.normal;
                for (l = 0,
                d = 0,
                f = g.count; d < f; d++)
                    e.set(g.getX(d), g.getY(d), g.getZ(d)).applyMatrix4(i),
                    t.set(y.getX(d), y.getY(d), y.getZ(d)),
                    t.applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                    o.setXYZ(l, e.x, e.y, e.z),
                    l += 1,
                    o.setXYZ(l, t.x, t.y, t.z),
                    l += 1
            }
            o.needsUpdate = !0
        }
    }(),
    qs.prototype = Object.create(nr.prototype),
    qs.prototype.constructor = qs,
    qs.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    qs.prototype.update = function() {
        var e = new Pt;
        return function() {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3
              , r = t * Math.tan(this.light.angle);
            this.cone.scale.set(r, r, t),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(e),
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(),
    Xs.prototype = Object.create(vi.prototype),
    Xs.prototype.constructor = Xs,
    Xs.prototype.updateMatrixWorld = function() {
        var e = new Pt
          , t = new At
          , r = new At;
        return function(n) {
            var i = this.bones
              , o = this.geometry
              , a = o.getAttribute("position");
            r.getInverse(this.root.matrixWorld);
            for (var s = 0, c = 0; s < i.length; s++) {
                var l = i[s];
                l.parent && l.parent.isBone && (t.multiplyMatrices(r, l.matrixWorld),
                e.setFromMatrixPosition(t),
                a.setXYZ(c, e.x, e.y, e.z),
                t.multiplyMatrices(r, l.parent.matrixWorld),
                e.setFromMatrixPosition(t),
                a.setXYZ(c + 1, e.x, e.y, e.z),
                c += 2)
            }
            o.getAttribute("position").needsUpdate = !0,
            nr.prototype.updateMatrixWorld.call(this, n)
        }
    }(),
    Ys.prototype = Object.create(Cr.prototype),
    Ys.prototype.constructor = Ys,
    Ys.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    Ys.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    Js.prototype = Object.create(mi.prototype),
    Js.prototype.constructor = Js,
    Js.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1),
        void 0 !== this.color)
            this.material.color.set(this.color),
            this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color
              , t = Math.max(e.r, e.g, e.b);
            t > 1 && e.multiplyScalar(1 / t),
            this.children[0].material.color.copy(this.material.color)
        }
    }
    ,
    Js.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Zs.prototype = Object.create(nr.prototype),
    Zs.prototype.constructor = Zs,
    Zs.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Zs.prototype.update = function() {
        var e = new Pt
          , t = new Yt
          , r = new Yt;
        return function() {
            var n = this.children[0];
            if (void 0 !== this.color)
                this.material.color.set(this.color);
            else {
                var i = n.geometry.getAttribute("color");
                t.copy(this.light.color),
                r.copy(this.light.groundColor);
                for (var o = 0, a = i.count; o < a; o++) {
                    var s = o < a / 2 ? t : r;
                    i.setXYZ(o, s.r, s.g, s.b)
                }
                i.needsUpdate = !0
            }
            n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(),
    Ks.prototype = Object.create(vi.prototype),
    Ks.prototype.constructor = Ks,
    Qs.prototype = Object.create(vi.prototype),
    Qs.prototype.constructor = Qs,
    $s.prototype = Object.create(vi.prototype),
    $s.prototype.constructor = $s,
    $s.prototype.update = function() {
        var e = new Pt
          , t = new Pt
          , r = new Ct;
        return function() {
            this.object.updateMatrixWorld(!0),
            r.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, i = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, l = 0, u = s.length; l < u; l++) {
                var h = s[l]
                  , p = h.normal;
                e.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(n),
                t.copy(p).applyMatrix3(r).normalize().multiplyScalar(this.size).add(e),
                i.setXYZ(c, e.x, e.y, e.z),
                c += 1,
                i.setXYZ(c, t.x, t.y, t.z),
                c += 1
            }
            i.needsUpdate = !0
        }
    }(),
    ec.prototype = Object.create(nr.prototype),
    ec.prototype.constructor = ec,
    ec.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    ec.prototype.update = function() {
        var e = new Pt
          , t = new Pt
          , r = new Pt;
        return function() {
            e.setFromMatrixPosition(this.light.matrixWorld),
            t.setFromMatrixPosition(this.light.target.matrixWorld),
            r.subVectors(t, e),
            this.lightPlane.lookAt(t),
            void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(t),
            this.targetLine.scale.z = r.length()
        }
    }(),
    tc.prototype = Object.create(vi.prototype),
    tc.prototype.constructor = tc,
    tc.prototype.update = function() {
        var e, t, r = new Pt, n = new Yn;
        function i(i, o, a, s) {
            r.set(o, a, s).unproject(n);
            var c = t[i];
            if (void 0 !== c)
                for (var l = e.getAttribute("position"), u = 0, h = c.length; u < h; u++)
                    l.setXYZ(c[u], r.x, r.y, r.z)
        }
        return function() {
            e = this.geometry,
            t = this.pointMap;
            n.projectionMatrix.copy(this.camera.projectionMatrix),
            i("c", 0, 0, -1),
            i("t", 0, 0, 1),
            i("n1", -1, -1, -1),
            i("n2", 1, -1, -1),
            i("n3", -1, 1, -1),
            i("n4", 1, 1, -1),
            i("f1", -1, -1, 1),
            i("f2", 1, -1, 1),
            i("f3", -1, 1, 1),
            i("f4", 1, 1, 1),
            i("u1", .7, 1.1, -1),
            i("u2", -.7, 1.1, -1),
            i("u3", 0, 2, -1),
            i("cf1", -1, 0, 1),
            i("cf2", 1, 0, 1),
            i("cf3", 0, -1, 1),
            i("cf4", 0, 1, 1),
            i("cn1", -1, 0, -1),
            i("cn2", 1, 0, -1),
            i("cn3", 0, -1, -1),
            i("cn4", 0, 1, -1),
            e.getAttribute("position").needsUpdate = !0
        }
    }(),
    rc.prototype = Object.create(vi.prototype),
    rc.prototype.constructor = rc,
    rc.prototype.update = function() {
        var e = new Ut;
        return function(t) {
            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
            void 0 !== this.object && e.setFromObject(this.object),
            !e.isEmpty()) {
                var r = e.min
                  , n = e.max
                  , i = this.geometry.attributes.position
                  , o = i.array;
                o[0] = n.x,
                o[1] = n.y,
                o[2] = n.z,
                o[3] = r.x,
                o[4] = n.y,
                o[5] = n.z,
                o[6] = r.x,
                o[7] = r.y,
                o[8] = n.z,
                o[9] = n.x,
                o[10] = r.y,
                o[11] = n.z,
                o[12] = n.x,
                o[13] = n.y,
                o[14] = r.z,
                o[15] = r.x,
                o[16] = n.y,
                o[17] = r.z,
                o[18] = r.x,
                o[19] = r.y,
                o[20] = r.z,
                o[21] = n.x,
                o[22] = r.y,
                o[23] = r.z,
                i.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
        }
    }(),
    rc.prototype.setFromObject = function(e) {
        return this.object = e,
        this.update(),
        this
    }
    ,
    rc.prototype.copy = function(e) {
        return vi.prototype.copy.call(this, e),
        this.object = e.object,
        this
    }
    ,
    rc.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    nc.prototype = Object.create(vi.prototype),
    nc.prototype.constructor = nc,
    nc.prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        nr.prototype.updateMatrixWorld.call(this, e))
    }
    ,
    ic.prototype = Object.create(mi.prototype),
    ic.prototype.constructor = ic,
    ic.prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, t),
        this.children[0].material.side = t < 0 ? d : p,
        this.lookAt(this.plane.normal),
        nr.prototype.updateMatrixWorld.call(this, e)
    }
    ,
    oc.prototype = Object.create(nr.prototype),
    oc.prototype.constructor = oc,
    oc.prototype.setDirection = function() {
        var e, t = new Pt;
        return function(r) {
            r.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : r.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (t.set(r.z, 0, -r.x).normalize(),
            e = Math.acos(r.y),
            this.quaternion.setFromAxisAngle(t, e))
        }
    }(),
    oc.prototype.setLength = function(e, t, r) {
        void 0 === t && (t = .2 * e),
        void 0 === r && (r = .2 * t),
        this.line.scale.set(1, Math.max(0, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(r, t, r),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    ,
    oc.prototype.setColor = function(e) {
        this.line.material.color.copy(e),
        this.cone.material.color.copy(e)
    }
    ,
    oc.prototype.copy = function(e) {
        return nr.prototype.copy.call(this, e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    ,
    oc.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    ac.prototype = Object.create(vi.prototype),
    ac.prototype.constructor = ac;
    function sc(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        Pa.call(this, e),
        this.type = "catmullrom",
        this.closed = !0
    }
    function cc(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        Pa.call(this, e),
        this.type = "catmullrom"
    }
    function lc(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        Pa.call(this, e),
        this.type = "catmullrom"
    }
    wa.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"),
        e.prototype = Object.create(wa.prototype),
        e.prototype.constructor = e,
        e.prototype.getPoint = t,
        e
    }
    ,
    Object.assign(Fa.prototype, {
        createPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getPoints(e);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(e) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        },
        createGeometry: function(e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new or, r = 0, n = e.length; r < n; r++) {
                var i = e[r];
                t.vertices.push(new Pt(i.x,i.y,i.z || 0))
            }
            return t
        }
    }),
    Object.assign(ka.prototype, {
        fromPoints: function(e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(e)
        }
    }),
    sc.prototype = Object.create(Pa.prototype),
    cc.prototype = Object.create(Pa.prototype),
    lc.prototype = Object.create(Pa.prototype),
    Object.assign(lc.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    Ks.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    Xs.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(ms.prototype, {
        extractUrlBase: function(e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            rs.extractUrlBase(e)
        }
    }),
    Object.assign(os.prototype, {
        setTexturePath: function(e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
            this.setResourcePath(e)
        }
    }),
    Object.assign(ks.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Object.assign(Ut.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Hs.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(e)
    }
    ,
    Object.assign(Et, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            Et.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            Et.ceilPowerOfTwo(e)
        }
    }),
    Object.assign(Ct.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }),
    Object.assign(At.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        getPosition: function() {
            var e;
            return function() {
                return void 0 === e && (e = new Pt),
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, r, n, i, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(e, t, n, r, i, o)
        }
    }),
    Ft.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(e)
    }
    ,
    Lt.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        e.applyQuaternion(this)
    }
    ,
    Object.assign(Ar.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        }
    }),
    Object.assign(Lr.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(e)
        }
    }),
    Object.assign(Lr, {
        barycoordFromPoint: function(e, t, r, n, i) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            Lr.getBarycoord(e, t, r, n, i)
        },
        normal: function(e, t, r, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            Lr.getNormal(e, t, r, n)
        }
    }),
    Object.assign(Ha.prototype, {
        extractAllPoints: function(e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new mo(this,e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new Ao(this,e)
        }
    }),
    Object.assign(Tt.prototype, {
        fromAttribute: function(e, t, r) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, r)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Pt.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, r) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, r)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Nt.prototype, {
        fromAttribute: function(e, t, r) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, r)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(or.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }),
    Object.assign(nr.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }),
    Object.defineProperties(nr.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.defineProperties(ui.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(pi.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    hi.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Object.defineProperty(wa.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = e
        }
    }),
    Jn.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(e)
    }
    ,
    Object.defineProperties(Va.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = e
            }
        }
    }),
    Object.defineProperties(ar.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }),
    Object.assign(br.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(e)
        },
        addDrawCall: function(e, t, r) {
            void 0 !== r && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }),
    Object.defineProperties(br.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.assign(vo.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }),
    Object.defineProperties(Is.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(Er.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new Yt
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === e
            }
        }
    }),
    Object.defineProperties(ko.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(Tr.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = e
            }
        }
    }),
    Object.assign(ri.prototype, {
        clearTarget: function(e, t, r, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(e),
            this.clear(t, r, n)
        },
        animate: function(e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }),
    Object.defineProperties(ri.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(Vn.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(Dt.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = e
            }
        }
    }),
    Object.defineProperties(ti.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }),
    _s.prototype.load = function(e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new gs).load(e, function(e) {
            t.setBuffer(e)
        }),
        this
    }
    ,
    Ss.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    bs.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(e, t)
    }
    ;
    var uc = {
        merge: function(e, t, r) {
            var n;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
            t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(),
            n = t.matrix,
            t = t.geometry),
            e.merge(t, n, r)
        },
        center: function(e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
            e.center()
        }
    };
    Rt.crossOrigin = void 0,
    Rt.loadTexture = function(e, t, r, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var i = new xa;
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(e, r, void 0, n);
        return t && (o.mapping = t),
        o
    }
    ,
    Rt.loadTextureCube = function(e, t, r, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var i = new ba;
        i.setCrossOrigin(this.crossOrigin);
        var o = i.load(e, r, void 0, n);
        return t && (o.mapping = t),
        o
    }
    ,
    Rt.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    Rt.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ;
    var hc = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    };
    t.WebGLMultisampleRenderTarget = Bt,
    t.WebGLRenderTargetCube = zt,
    t.WebGLRenderTarget = Dt,
    t.WebGLRenderer = ri,
    t.ShaderLib = Zt,
    t.UniformsLib = Jt,
    t.UniformsUtils = qt,
    t.ShaderChunk = Ht,
    t.FogExp2 = ni,
    t.Fog = ii,
    t.Scene = oi,
    t.Sprite = li,
    t.LOD = ui,
    t.SkinnedMesh = hi,
    t.Skeleton = pi,
    t.Bone = di,
    t.Mesh = Cr,
    t.LineSegments = vi,
    t.LineLoop = gi,
    t.Line = mi,
    t.Points = bi,
    t.Group = Xn,
    t.VideoTexture = xi,
    t.DataTexture = Gt,
    t.DataTexture3D = Ir,
    t.CompressedTexture = wi,
    t.CubeTexture = Or,
    t.CanvasTexture = _i,
    t.DepthTexture = Mi,
    t.Texture = It,
    t.AnimationLoader = ma,
    t.CompressedTextureLoader = va,
    t.DataTextureLoader = ga,
    t.CubeTextureLoader = ba,
    t.TextureLoader = xa,
    t.ObjectLoader = os,
    t.MaterialLoader = ts,
    t.BufferGeometryLoader = ns,
    t.DefaultLoadingManager = pa,
    t.LoadingManager = ha,
    t.ImageLoader = ya,
    t.ImageBitmapLoader = us,
    t.FontLoader = fs,
    t.FileLoader = fa,
    t.Loader = ms,
    t.LoaderUtils = rs,
    t.Cache = ua,
    t.AudioLoader = gs,
    t.SpotLightShadow = Xa,
    t.SpotLight = Ya,
    t.PointLight = Ja,
    t.RectAreaLight = es,
    t.HemisphereLight = Wa,
    t.DirectionalLightShadow = Ka,
    t.DirectionalLight = Qa,
    t.AmbientLight = $a,
    t.LightShadow = qa,
    t.Light = Va,
    t.StereoCamera = ys,
    t.PerspectiveCamera = Jn,
    t.OrthographicCamera = Za,
    t.CubeCamera = bs,
    t.ArrayCamera = Zn,
    t.Camera = Yn,
    t.AudioListener = ws,
    t.PositionalAudio = Ms,
    t.AudioContext = vs,
    t.AudioAnalyser = Ss,
    t.Audio = _s,
    t.VectorKeyframeTrack = sa,
    t.StringKeyframeTrack = aa,
    t.QuaternionKeyframeTrack = oa,
    t.NumberKeyframeTrack = na,
    t.ColorKeyframeTrack = ra,
    t.BooleanKeyframeTrack = ta,
    t.PropertyMixer = Es,
    t.PropertyBinding = Ps,
    t.KeyframeTrack = ea,
    t.AnimationUtils = Jo,
    t.AnimationObjectGroup = Cs,
    t.AnimationMixer = Os,
    t.AnimationClip = ca,
    t.Uniform = Is,
    t.InstancedBufferGeometry = Ns,
    t.BufferGeometry = br,
    t.Geometry = or,
    t.InterleavedBufferAttribute = si,
    t.InstancedInterleavedBuffer = Ds,
    t.InterleavedBuffer = ai,
    t.InstancedBufferAttribute = Bs,
    t.Face3 = $t,
    t.Object3D = nr,
    t.Raycaster = zs,
    t.Layers = tr,
    t.EventDispatcher = i,
    t.Clock = xs,
    t.QuaternionLinearInterpolant = ia,
    t.LinearInterpolant = Qo,
    t.DiscreteInterpolant = $o,
    t.CubicInterpolant = Ko,
    t.Interpolant = Zo,
    t.Triangle = Lr,
    t.Math = Et,
    t.Spherical = js,
    t.Cylindrical = Fs,
    t.Plane = Ft,
    t.Frustum = kt,
    t.Sphere = jt,
    t.Ray = Ar,
    t.Matrix4 = At,
    t.Matrix3 = Ct,
    t.Box3 = Ut,
    t.Box2 = ks,
    t.Line3 = Hs,
    t.Euler = er,
    t.Vector4 = Nt,
    t.Vector3 = Pt,
    t.Vector2 = Tt,
    t.Quaternion = Lt,
    t.Color = Yt,
    t.ImmediateRenderObject = Vs,
    t.VertexNormalsHelper = Ws,
    t.SpotLightHelper = qs,
    t.SkeletonHelper = Xs,
    t.PointLightHelper = Ys,
    t.RectAreaLightHelper = Js,
    t.HemisphereLightHelper = Zs,
    t.GridHelper = Ks,
    t.PolarGridHelper = Qs,
    t.FaceNormalsHelper = $s,
    t.DirectionalLightHelper = ec,
    t.CameraHelper = tc,
    t.BoxHelper = rc,
    t.Box3Helper = nc,
    t.PlaneHelper = ic,
    t.ArrowHelper = oc,
    t.AxesHelper = ac,
    t.Shape = Ha,
    t.Path = ka,
    t.ShapePath = hs,
    t.Font = ps,
    t.CurvePath = Fa,
    t.Curve = wa,
    t.ImageUtils = Rt,
    t.ShapeUtils = ho,
    t.WebGLUtils = qn,
    t.WireframeGeometry = Si,
    t.ParametricGeometry = Ei,
    t.ParametricBufferGeometry = Ti,
    t.TetrahedronGeometry = Pi,
    t.TetrahedronBufferGeometry = Ci,
    t.OctahedronGeometry = Ri,
    t.OctahedronBufferGeometry = Oi,
    t.IcosahedronGeometry = Ii,
    t.IcosahedronBufferGeometry = Ni,
    t.DodecahedronGeometry = Di,
    t.DodecahedronBufferGeometry = Bi,
    t.PolyhedronGeometry = Ai,
    t.PolyhedronBufferGeometry = Li,
    t.TubeGeometry = zi,
    t.TubeBufferGeometry = Gi,
    t.TorusKnotGeometry = Ui,
    t.TorusKnotBufferGeometry = ji,
    t.TorusGeometry = Fi,
    t.TorusBufferGeometry = ki,
    t.TextGeometry = bo,
    t.TextBufferGeometry = xo,
    t.SphereGeometry = wo,
    t.SphereBufferGeometry = _o,
    t.RingGeometry = Mo,
    t.RingBufferGeometry = So,
    t.PlaneGeometry = _r,
    t.PlaneBufferGeometry = Mr,
    t.LatheGeometry = Eo,
    t.LatheBufferGeometry = To,
    t.ShapeGeometry = Ao,
    t.ShapeBufferGeometry = Lo,
    t.ExtrudeGeometry = mo,
    t.ExtrudeBufferGeometry = vo,
    t.EdgesGeometry = Co,
    t.ConeGeometry = Io,
    t.ConeBufferGeometry = No,
    t.CylinderGeometry = Ro,
    t.CylinderBufferGeometry = Oo,
    t.CircleGeometry = Do,
    t.CircleBufferGeometry = Bo,
    t.BoxGeometry = xr,
    t.CubeGeometry = xr,
    t.BoxBufferGeometry = wr,
    t.ShadowMaterial = Go,
    t.SpriteMaterial = ci,
    t.RawShaderMaterial = Uo,
    t.ShaderMaterial = Tr,
    t.PointsMaterial = yi,
    t.MeshPhysicalMaterial = Fo,
    t.MeshStandardMaterial = jo,
    t.MeshPhongMaterial = ko,
    t.MeshToonMaterial = Ho,
    t.MeshNormalMaterial = Vo,
    t.MeshLambertMaterial = Wo,
    t.MeshDepthMaterial = kn,
    t.MeshDistanceMaterial = Hn,
    t.MeshBasicMaterial = Pr,
    t.MeshMatcapMaterial = qo,
    t.LineDashedMaterial = Xo,
    t.LineBasicMaterial = fi,
    t.Material = Er,
    t.Float64BufferAttribute = mr,
    t.Float32BufferAttribute = fr,
    t.Uint32BufferAttribute = dr,
    t.Int32BufferAttribute = pr,
    t.Uint16BufferAttribute = hr,
    t.Int16BufferAttribute = ur,
    t.Uint8ClampedBufferAttribute = lr,
    t.Uint8BufferAttribute = cr,
    t.Int8BufferAttribute = sr,
    t.BufferAttribute = ar,
    t.ArcCurve = Ma,
    t.CatmullRomCurve3 = Pa,
    t.CubicBezierCurve = Ia,
    t.CubicBezierCurve3 = Na,
    t.EllipseCurve = _a,
    t.LineCurve = Da,
    t.LineCurve3 = Ba,
    t.QuadraticBezierCurve = za,
    t.QuadraticBezierCurve3 = Ga,
    t.SplineCurve = Ua,
    t.REVISION = a,
    t.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    },
    t.CullFaceNone = s,
    t.CullFaceBack = c,
    t.CullFaceFront = l,
    t.CullFaceFrontBack = 3,
    t.FrontFaceDirectionCW = 0,
    t.FrontFaceDirectionCCW = 1,
    t.BasicShadowMap = 0,
    t.PCFShadowMap = u,
    t.PCFSoftShadowMap = h,
    t.FrontSide = p,
    t.BackSide = d,
    t.DoubleSide = f,
    t.FlatShading = 1,
    t.SmoothShading = 2,
    t.NoColors = m,
    t.FaceColors = v,
    t.VertexColors = g,
    t.NoBlending = y,
    t.NormalBlending = b,
    t.AdditiveBlending = x,
    t.SubtractiveBlending = w,
    t.MultiplyBlending = _,
    t.CustomBlending = M,
    t.AddEquation = S,
    t.SubtractEquation = E,
    t.ReverseSubtractEquation = T,
    t.MinEquation = A,
    t.MaxEquation = L,
    t.ZeroFactor = P,
    t.OneFactor = C,
    t.SrcColorFactor = R,
    t.OneMinusSrcColorFactor = O,
    t.SrcAlphaFactor = I,
    t.OneMinusSrcAlphaFactor = N,
    t.DstAlphaFactor = D,
    t.OneMinusDstAlphaFactor = B,
    t.DstColorFactor = z,
    t.OneMinusDstColorFactor = G,
    t.SrcAlphaSaturateFactor = U,
    t.NeverDepth = j,
    t.AlwaysDepth = F,
    t.LessDepth = k,
    t.LessEqualDepth = H,
    t.EqualDepth = V,
    t.GreaterEqualDepth = W,
    t.GreaterDepth = q,
    t.NotEqualDepth = X,
    t.MultiplyOperation = Y,
    t.MixOperation = J,
    t.AddOperation = Z,
    t.NoToneMapping = K,
    t.LinearToneMapping = Q,
    t.ReinhardToneMapping = $,
    t.Uncharted2ToneMapping = ee,
    t.CineonToneMapping = te,
    t.ACESFilmicToneMapping = re,
    t.UVMapping = 300,
    t.CubeReflectionMapping = ne,
    t.CubeRefractionMapping = ie,
    t.EquirectangularReflectionMapping = oe,
    t.EquirectangularRefractionMapping = ae,
    t.SphericalReflectionMapping = se,
    t.CubeUVReflectionMapping = ce,
    t.CubeUVRefractionMapping = le,
    t.RepeatWrapping = ue,
    t.ClampToEdgeWrapping = he,
    t.MirroredRepeatWrapping = pe,
    t.NearestFilter = de,
    t.NearestMipMapNearestFilter = fe,
    t.NearestMipMapLinearFilter = me,
    t.LinearFilter = ve,
    t.LinearMipMapNearestFilter = ge,
    t.LinearMipMapLinearFilter = ye,
    t.UnsignedByteType = be,
    t.ByteType = xe,
    t.ShortType = we,
    t.UnsignedShortType = _e,
    t.IntType = Me,
    t.UnsignedIntType = Se,
    t.FloatType = Ee,
    t.HalfFloatType = Te,
    t.UnsignedShort4444Type = Ae,
    t.UnsignedShort5551Type = Le,
    t.UnsignedShort565Type = Pe,
    t.UnsignedInt248Type = Ce,
    t.AlphaFormat = Re,
    t.RGBFormat = Oe,
    t.RGBAFormat = Ie,
    t.LuminanceFormat = Ne,
    t.LuminanceAlphaFormat = De,
    t.RGBEFormat = Be,
    t.DepthFormat = ze,
    t.DepthStencilFormat = Ge,
    t.RedFormat = Ue,
    t.RGB_S3TC_DXT1_Format = je,
    t.RGBA_S3TC_DXT1_Format = Fe,
    t.RGBA_S3TC_DXT3_Format = ke,
    t.RGBA_S3TC_DXT5_Format = He,
    t.RGB_PVRTC_4BPPV1_Format = Ve,
    t.RGB_PVRTC_2BPPV1_Format = We,
    t.RGBA_PVRTC_4BPPV1_Format = qe,
    t.RGBA_PVRTC_2BPPV1_Format = Xe,
    t.RGB_ETC1_Format = Ye,
    t.RGBA_ASTC_4x4_Format = Je,
    t.RGBA_ASTC_5x4_Format = Ze,
    t.RGBA_ASTC_5x5_Format = Ke,
    t.RGBA_ASTC_6x5_Format = Qe,
    t.RGBA_ASTC_6x6_Format = $e,
    t.RGBA_ASTC_8x5_Format = et,
    t.RGBA_ASTC_8x6_Format = tt,
    t.RGBA_ASTC_8x8_Format = rt,
    t.RGBA_ASTC_10x5_Format = nt,
    t.RGBA_ASTC_10x6_Format = it,
    t.RGBA_ASTC_10x8_Format = ot,
    t.RGBA_ASTC_10x10_Format = at,
    t.RGBA_ASTC_12x10_Format = st,
    t.RGBA_ASTC_12x12_Format = ct,
    t.LoopOnce = 2200,
    t.LoopRepeat = lt,
    t.LoopPingPong = 2202,
    t.InterpolateDiscrete = 2300,
    t.InterpolateLinear = 2301,
    t.InterpolateSmooth = 2302,
    t.ZeroCurvatureEnding = ut,
    t.ZeroSlopeEnding = 2401,
    t.WrapAroundEnding = 2402,
    t.TrianglesDrawMode = ht,
    t.TriangleStripDrawMode = pt,
    t.TriangleFanDrawMode = dt,
    t.LinearEncoding = ft,
    t.sRGBEncoding = mt,
    t.GammaEncoding = vt,
    t.RGBEEncoding = gt,
    t.LogLuvEncoding = 3003,
    t.RGBM7Encoding = yt,
    t.RGBM16Encoding = bt,
    t.RGBDEncoding = xt,
    t.BasicDepthPacking = wt,
    t.RGBADepthPacking = _t,
    t.TangentSpaceNormalMap = Mt,
    t.ObjectSpaceNormalMap = St,
    t.Face4 = function(e, t, r, n, i, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
        new $t(e,t,r,i,o,a)
    }
    ,
    t.LineStrip = 0,
    t.LinePieces = 1,
    t.MeshFaceMaterial = function(e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
        e
    }
    ,
    t.MultiMaterial = function(e) {
        return void 0 === e && (e = []),
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
        e.isMultiMaterial = !0,
        e.materials = e,
        e.clone = function() {
            return e.slice()
        }
        ,
        e
    }
    ,
    t.PointCloud = function(e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new bi(e,t)
    }
    ,
    t.Particle = function(e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new li(e)
    }
    ,
    t.ParticleSystem = function(e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new bi(e,t)
    }
    ,
    t.PointCloudMaterial = function(e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
        new yi(e)
    }
    ,
    t.ParticleBasicMaterial = function(e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
        new yi(e)
    }
    ,
    t.ParticleSystemMaterial = function(e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
        new yi(e)
    }
    ,
    t.Vertex = function(e, t, r) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
        new Pt(e,t,r)
    }
    ,
    t.DynamicBufferAttribute = function(e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
        new ar(e,t).setDynamic(!0)
    }
    ,
    t.Int8Attribute = function(e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
        new sr(e,t)
    }
    ,
    t.Uint8Attribute = function(e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
        new cr(e,t)
    }
    ,
    t.Uint8ClampedAttribute = function(e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
        new lr(e,t)
    }
    ,
    t.Int16Attribute = function(e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
        new ur(e,t)
    }
    ,
    t.Uint16Attribute = function(e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
        new hr(e,t)
    }
    ,
    t.Int32Attribute = function(e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
        new pr(e,t)
    }
    ,
    t.Uint32Attribute = function(e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
        new dr(e,t)
    }
    ,
    t.Float32Attribute = function(e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
        new fr(e,t)
    }
    ,
    t.Float64Attribute = function(e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
        new mr(e,t)
    }
    ,
    t.ClosedSplineCurve3 = sc,
    t.SplineCurve3 = cc,
    t.Spline = lc,
    t.AxisHelper = function(e) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new ac(e)
    }
    ,
    t.BoundingBoxHelper = function(e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
        new rc(e,t)
    }
    ,
    t.EdgesHelper = function(e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
        new vi(new Co(e.geometry),new fi({
            color: void 0 !== t ? t : 16777215
        }))
    }
    ,
    t.WireframeHelper = function(e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
        new vi(new Si(e.geometry),new fi({
            color: void 0 !== t ? t : 16777215
        }))
    }
    ,
    t.XHRLoader = function(e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new fa(e)
    }
    ,
    t.BinaryTextureLoader = function(e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
        new ga(e)
    }
    ,
    t.GeometryUtils = uc,
    t.Projector = function() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
        this.projectVector = function(e, t) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."),
            e.project(t)
        }
        ,
        this.unprojectVector = function(e, t) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
            e.unproject(t)
        }
        ,
        this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }
    ,
    t.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been removed")
    }
    ,
    t.JSONLoader = function() {
        console.error("THREE.JSONLoader has been removed.")
    }
    ,
    t.SceneUtils = hc,
    t.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.scene = t.gameSpeed = t.player = t.camera = t.prevGameState = t.gameState = t.gameStarted = t.darkMaterial = t.basicMaterial = t.progressBar = t.STATE = void 0,
    t.getTestGroup = function() {
        return qe
    }
    ,
    t.init = function() {
        gtag("event", "screen", {
            event_category: "init"
        });
        var e = o.calculate()
          , r = e.width
          , b = e.height;
        try {
            if (localStorage.getItem("supernova/test-group"))
                qe = Object.values(We).find(function(e) {
                    return localStorage.getItem("supernova/test-group") === e
                }) ? localStorage.getItem("supernova/test-group") : We.EXISTING;
            else {
                var x = [We.EXISTING];
                qe = x[Math.floor(Math.random() * x.length)]
            }
            localStorage.setItem("supernova/test-group", qe),
            gtag("event", "set-test-group", {
                "test-group": qe
            })
        } catch (e) {
            qe = We.NO_STORAGE
        }
        document.body.setAttribute("test-group", qe),
        (0,
        E.generateLevels)(),
        t.scene = Ve = new n.Scene,
        _e = new n.Scene,
        t.camera = de = new n.PerspectiveCamera(87,r / b,.1,250),
        we = new n.PerspectiveCamera(50,r / b,.1,50),
        Oe = function(e) {
            var t = e.width
              , r = e.height
              , i = new n.WebGLRenderer({
                antialias: !0,
                alpha: !0
            });
            return i.shadowMap.enabled = !0,
            i.shadowMap.type = n.PCFSoftShadowMap,
            i.setSize(t, r),
            document.body.appendChild(i.domElement),
            i
        }({
            width: r,
            height: b
        });
        /*var _ = ["top", "indexOf", "aHR0cHM6Ly9wb2tpLmNvbS9zaXRlbG9jaw==", "hostname", "length", "location", "LnBva2ktZ2RuLmNvbQ==", "href"];
        !function(e, t) {
            !function(t) {
                for (; --t; )
                    e.push(e.shift())
            }(++t)
        }(_, 430);
        var M = function(e, t) {
            var r = _[e -= 0];
            return r
        };
        (function() {
            for (var e = ["bG9jYWxob3N0", "LnBva2kuY29t", M("0x0")], t = !1, r = window[M("0x7")][M("0x5")], n = 0; n < e[M("0x6")]; n++) {
                var i = atob(e[n]);
                if (-1 !== r[M("0x3")](i, r.length - i.length)) {
                    t = !0;
                    break
                }
            }
            if (!t) {
                var o = M("0x4")
                  , a = atob(o);
                window.location[M("0x1")] = a,
                this[M("0x2")][M("0x7")] !== this[M("0x7")] && (this[M("0x2")][M("0x7")] = this[M("0x7")])
            }
        }
        )(),*/
        window.devicePixelRatio <= 1 ? (se.className += " last",
        ce.style.display = "none") : ce.className += " last";
        try {
            var S = localStorage.getItem("supernova/resolution");
            "low" === S ? (ae.setAttribute("selected", !0),
            Oe.setPixelRatio(.4)) : "ultra" === S && window.devicePixelRatio > 1 ? (ce.setAttribute("selected", !0),
            Oe.setPixelRatio(window.devicePixelRatio)) : (se.setAttribute("selected", !0),
            Oe.setPixelRatio(1))
        } catch (e) {}
        (0,
        h.init)(),
        Fe = new n.Scene,
        je = new n.OrthographicCamera(0,0,0,0,1,100),
        (ke = new n.WebGLRenderer({
            antialias: !0,
            alpha: !0
        })).domElement.id = "ships-canvas",
        ke.domElement.setAttribute("data-states", "control-panel unlock"),
        W.push(ke.domElement),
        document.body.appendChild(ke.domElement),
        l.init(Fe),
        a.register(),
        be = function() {
            var e = new n.TextGeometry("SUPERNOVA",{
                font: i.resources.fonts.logoFont,
                size: 5,
                height: 7
            });
            e.center();
            var t = new n.Mesh(e,F);
            return t.position.copy(G),
            _e.add(t),
            t
        }(),
        ($e = new n.PointLight(16777215,4,40)).position.set(0, 6, 0),
        _e.add($e),
        (0,
        c.goToNextLevel)(!0),
        t.gameSpeed = He = (0,
        c.getCurrentSpeed)(),
        (xe = u.tube).create(Ve),
        de.position.copy(D),
        t.player = Se = function() {
            var e = new n.Group;
            Ae = new n.Group,
            Ee = new n.Group,
            e.add(Ee),
            Ee.add(Ae),
            tt((0,
            h.getPlayerShip)()),
            e.position.copy(N),
            Ve.add(e);
            var t = new n.Vector3(0,0,-3.6)
              , r = new n.Vector3(e.position.x + t.x,e.position.y + t.y,e.position.z + t.z)
              , i = new n.Raycaster(r,new n.Vector3(-1,0,0),0,.5)
              , o = new n.Raycaster(r,new n.Vector3(1,0,0),0,.5)
              , a = new n.Raycaster(e.position,new n.Vector3(0,0,-1),0,3.6);
            i.ray.__offset = t,
            o.ray.__offset = t,
            Pe.push(i),
            Pe.push(o),
            Pe.push(a);
            var s = !0
              , c = !1
              , l = void 0;
            try {
                for (var u, p = Pe[Symbol.iterator](); !(s = (u = p.next()).done); s = !0) {
                    var d = u.value;
                    d.ray.__originalDirection = d.ray.direction.clone()
                }
            } catch (e) {
                c = !0,
                l = e
            } finally {
                try {
                    !s && p.return && p.return()
                } finally {
                    if (c)
                        throw l
                }
            }
            return e
        }(),
        Re = function() {
            var e = new n.PointLight(16777215,2,40);
            return e.position.set(0, 10, 0),
            e.castShadow = !0,
            Ve.add(e),
            e
        }(),
        function() {
            var e = new n.HemisphereLight(16777215,6710886,1);
            Ve.add(e)
        }(),
        Ve.fog = new n.Fog(z,20,250),
        ye = function() {
            for (var e = [], t = 0; t < 10; t++)
                e.push(new n.Vector3(0,t,-30 * t));
            return new n.CatmullRomCurve3(e)
        }(),
        function() {
            var e = new n.TubeGeometry(ye,40,40,12,!1)
              , t = !0
              , r = !1
              , i = void 0;
            try {
                for (var o, a = e.vertices[Symbol.iterator](); !(t = (o = a.next()).done); t = !0) {
                    var s = o.value;
                    s.__originalPos = new n.Vector3(s.x,s.y,s.z)
                }
            } catch (e) {
                r = !0,
                i = e
            } finally {
                try {
                    !t && a.return && a.return()
                } finally {
                    if (r)
                        throw i
                }
            }
            var c = new n.TubeGeometry(ye,40,40,6,!1)
              , l = !0
              , u = !1
              , h = void 0;
            try {
                for (var p, d = c.vertices[Symbol.iterator](); !(l = (p = d.next()).done); l = !0) {
                    var f = p.value;
                    f.__originalPos = new n.Vector3(f.x,f.y,f.z)
                }
            } catch (e) {
                u = !0,
                h = e
            } finally {
                try {
                    !l && d.return && d.return()
                } finally {
                    if (u)
                        throw h
                }
            }
            var m = new n.TubeGeometry(ye,40,40,4,!1)
              , v = !0
              , g = !1
              , y = void 0;
            try {
                for (var b, x = m.vertices[Symbol.iterator](); !(v = (b = x.next()).done); v = !0) {
                    var w = b.value;
                    w.__originalPos = new n.Vector3(w.x,w.y,w.z)
                }
            } catch (e) {
                g = !0,
                y = e
            } finally {
                try {
                    !v && x.return && x.return()
                } finally {
                    if (g)
                        throw y
                }
            }
            var _ = new n.Mesh(e,k);
            _.position.clone(B),
            ze = _,
            Ve.add(_);
            var M = new n.Mesh(c,k);
            M.position.clone(B),
            Ge = M,
            Ve.add(M);
            var S = new n.Mesh(m,k);
            S.position.clone(B),
            Ue = S,
            Ve.add(S)
        }(),
        Ce = function() {
            for (var e = new n.Geometry, t = 0; t < 75; t++) {
                var r = void 0;
                do {
                    r = new n.Vector2(40 * Math.random(),40 * Math.random())
                } while (r.length() < 15);
                Math.random() >= .5 && (r.x *= -1),
                Math.random() >= .5 && (r.y *= -1);
                var i = Math.random() * V
                  , o = new n.Vector3(r.x,r.y,i);
                e.vertices.push(o)
            }
            var a = new n.Points(e,H);
            return Ve.add(a),
            a
        }(),
        function() {
            for (var e = [], t = 0; t < 10; t++)
                e.push((0,
                p.default)());
            for (var r = 0; r < 10; r++)
                e.push((0,
                f.default)());
            for (var n = 0; n < 30; n++)
                e.push((0,
                m.default)());
            for (var i = 0; i < 30; i++)
                e.push((0,
                v.default)());
            for (var o = 0; o < 10; o++)
                e.push((0,
                g.default)());
            for (var a = 0; a < 3; a++)
                e.push((0,
                y.default)());
            for (var s = 0; s < 100; s++)
                e.push((0,
                d.default)());
            e.forEach(function(e) {
                return e.pool()
            })
        }(),
        window.addEventListener("resize", nt),
        nt(),
        a.listenToAction(a.actions.PRIMARY, function(e) {
            if (e.preventDefault(),
            !me && ue !== R.INGAME && ue !== R.DYING && ue !== R.END_SCREEN) {
                var t = Array.from(document.body.getElementsByClassName("button"))
                  , r = t.find(function(e) {
                    return e.getAttribute("active")
                });
                "ships-button" === r.id ? l.toggle() : "continue-button" === r.id ? Ye() : "select-ship-button" === r.id ? (0,
                w.selectPlayerShip)() : "resume-button" === r.id ? ut(R.INGAME) : "continue-button-unlock" === r.id ? ut(R.INGAME) : "resume-button-unlock" === r.id ? (l.selectPlayerShip(),
                ut(R.INGAME)) : "pause-button" === r.id ? ut(R.PAUSED) : "exit-button" === r.id ? ut(R.MAIN_MENU) : "skip-button-pause" === r.id ? Je("pause") : "skip-button-ingame" === r.id ? Je("ingame") : "back-button-settings" === r.id ? ut(R.MAIN_MENU) : "settings-button" === r.id && (gtag("event", "screen", {
                    event_category: "settings"
                }),
                ut(R.SETTINGS))
            }
        }),
        q.addEventListener("click", function() {
            return l.toggle()
        }),
        J.addEventListener("click", function() {
            return (0,
            w.selectPlayerShip)()
        }),
        X.addEventListener("click", function() {
            return Ye()
        }),
        Z.addEventListener("click", function() {
            return ut(R.INGAME)
        }),
        Q.addEventListener("click", function() {
            return ut(R.INGAME)
        }),
        K.addEventListener("click", function() {
            l.selectPlayerShip(),
            ut(R.INGAME)
        }),
        $.addEventListener("click", function() {
            return ut(R.PAUSED)
        }),
        ee.addEventListener("click", function() {
            return ut(R.MAIN_MENU)
        }),
        te.addEventListener("click", function() {
            return Je("pause")
        }),
        re.addEventListener("click", function() {
            return Je("ingame")
        }),
        ie.addEventListener("click", function() {
            return ut(R.MAIN_MENU)
        }),
        oe.addEventListener("click", function() {
            gtag("event", "screen", {
                event_category: "settings"
            }),
            ut(R.SETTINGS)
        }),
        ae.addEventListener("click", function() {
            gtag("event", "setResolution", {
                event_category: "low"
            }),
            ae.setAttribute("selected", !0),
            se.removeAttribute("selected"),
            ce.removeAttribute("selected");
            try {
                localStorage.setItem("supernova/resolution", "low")
            } catch (e) {}
            Oe.setPixelRatio(.5)
        }),
        se.addEventListener("click", function() {
            gtag("event", "setResolution", {
                event_category: "default"
            }),
            ae.removeAttribute("selected"),
            se.setAttribute("selected", !0),
            ce.removeAttribute("selected");
            try {
                localStorage.setItem("supernova/resolution", "default")
            } catch (e) {}
            Oe.setPixelRatio(1)
        }),
        ce.addEventListener("click", function() {
            gtag("event", "setResolution", {
                event_category: "ultra"
            }),
            ae.removeAttribute("selected"),
            se.removeAttribute("selected"),
            ce.setAttribute("selected", !0);
            try {
                localStorage.setItem("supernova/resolution", "ultra")
            } catch (e) {}
            Oe.setPixelRatio(window.devicePixelRatio)
        }),
        a.listenToAction(a.actions.EXIT, function() {
            ue === R.INGAME || ue === R.DYING || ue === R.END_SCREEN ? ut(R.PAUSED) : ue === R.MAIN_MENU || ue === R.CONTROL_PANEL ? l.toggle() : ue === R.PAUSED && ut(pe)
        }),
        a.listenToAction(a.actions.PAUSE, function() {
            ue === R.INGAME && ut(R.PAUSED)
        }),
        a.listenToAction(a.actions.LEFT, function(e) {
            e.preventDefault(),
            mt(-1)
        }),
        a.listenToAction(a.actions.RIGHT, function(e) {
            e.preventDefault(),
            mt(1)
        }),
        a.listenToAction(a.actions.UP, function(e) {
            e.preventDefault(),
            mt(-1)
        }),
        a.listenToAction(a.actions.DOWN, function(e) {
            e.preventDefault(),
            mt(1)
        }),
        window.addEventListener("blur", function() {
            ue !== R.INGAME && ue !== R.DYING && ue !== R.END_SCREEN || ut(R.PAUSED)
        }),
        s.reset(),
        t.gameStarted = !0,
        Ke(),
        window.setTimeout(function() {}, 500)
    }
    ,
    t.cBreak = function() {
        if (Date.now() - Xe < 126e3)
            return;
        gtag("event", "ad", {
            event_category: "requested",
            "event-label": "commercial-break"
        }),
        ut(R.PAUSED),
        me = !0,
        Xe = Date.now(),
        PokiSDK.commercialBreak().then(function() {
            gtag("event", "ad", {
                event_category: "completed",
                "event-label": "commercial-break"
            }),
            Oe.domElement.focus(),
            me = !1,
            ut(R.INGAME)
        })
    }
    ,
    t.createBox = function(e, t, r) {
        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1
          , o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1
          , a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1
          , s = new n.BoxGeometry(e,t,r,i,o,a)
          , c = U;
        return new n.Mesh(s,c)
    }
    ,
    t.createSphere = function(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 15
          , r = new n.SphereGeometry(e,t,t)
          , i = U;
        return new n.Mesh(r,i)
    }
    ,
    t.createCylinder = function(e, t) {
        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 15
          , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1
          , o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
          , a = new n.CylinderGeometry(e,e,t,r,i,o)
          , s = U;
        return new n.Mesh(a,s)
    }
    ,
    t.createCone = function(e, t) {
        var r = new n.ConeGeometry(e,t,6)
          , i = U;
        return new n.Mesh(r,i)
    }
    ,
    t.changePlayerShip = tt,
    t.createTorus = function(e, t, r, i, o) {
        var a = new n.TorusGeometry(e,t,r,i,o)
          , s = U;
        return new n.Mesh(a,s)
    }
    ,
    t.changeGameState = ut,
    t.playerDied = function() {
        gtag("event", "level", {
            event_category: "fail",
            event_label: (0,
            c.getCurrentLevelNumber)().toString().padStart(6, "0"),
            value: (0,
            c.getCurrentLevelNumber)()
        }),
        ut(R.DYING),
        (0,
        T.decreaseSpeed)(),
        (0,
        T.sendStreak)(),
        (0,
        T.resetStreak)(),
        Ne = .01,
        (0,
        A.shake)(),
        le.className = "",
        le.offsetWidth,
        le.className = "flash",
        (0,
        S.canShowAds)() && (clearTimeout(ht),
        re.setAttribute("visible", "true"),
        ht = window.setTimeout(function() {
            re.removeAttribute("visible")
        }, 5e3))
    }
    ,
    t.rotatePoint = pt,
    t.getCurrentRotation = dt,
    t.lerp = ft,
    t.obstacleTrigger = function() {
        (0,
        T.increaseStreak)()
    }
    ;
    var n = r(0)
      , i = r(5)
      , o = P(r(19))
      , a = P(r(26))
      , s = P(r(4))
      , c = r(3)
      , l = P(r(17))
      , u = P(r(88))
      , h = r(18)
      , p = L(r(28))
      , d = L(r(7))
      , f = L(r(32))
      , m = L(r(29))
      , v = L(r(31))
      , g = L(r(33))
      , y = L(r(30))
      , b = r(36)
      , x = r(35)
      , w = r(17)
      , _ = r(4)
      , M = r(18)
      , S = r(13)
      , E = r(27)
      , T = r(3)
      , A = r(104);
    function L(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    function P(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }
    function C(e) {
        if (Array.isArray(e)) {
            for (var t = 0, r = Array(e.length); t < e.length; t++)
                r[t] = e[t];
            return r
        }
        return Array.from(e)
    }
    var R = t.STATE = {
        MAIN_MENU: 0,
        INGAME: 1,
        DYING: 2,
        END_SCREEN: 3,
        CONTROL_PANEL: 4,
        PAUSED: 5,
        SETTINGS: 6,
        UNLOCK: 7
    }
      , O = 0
      , I = 2
      , N = new n.Vector3(0,5.5,-3.8)
      , D = new n.Vector3(0,7.5,0)
      , B = new n.Vector3(0,0,0)
      , z = 16777215
      , G = new n.Vector3(0,7.5,-33)
      , U = new n.MeshPhongMaterial({
        color: 2927550,
        emissive: 468276,
        side: n.FrontSide,
        flatShading: !0
    })
      , j = new n.MeshPhongMaterial({
        color: 8738,
        emissive: 468276,
        side: n.FrontSide,
        flatShading: !0
    })
      , F = new n.MeshPhongMaterial({
        color: 15658734,
        emissive: 468276,
        side: n.FrontSide,
        flatShading: !0
    })
      , k = new n.MeshBasicMaterial({
        vertexColors: n.FaceColors,
        side: n.BackSide,
        flatShading: !0
    })
      , H = new n.PointsMaterial({
        color: 16777215,
        size: 1,
        transparent: !0,
        opacity: .3
    })
      , V = -150
      , W = [].concat(C(document.getElementsByTagName("section")))
      , q = document.getElementById("ships-button")
      , X = document.getElementById("continue-button")
      , Y = document.getElementById("progress-bar")
      , J = document.getElementById("select-ship-button")
      , Z = document.getElementById("resume-button")
      , K = document.getElementById("resume-button-unlock")
      , Q = document.getElementById("continue-button-unlock")
      , $ = document.getElementById("pause-button")
      , ee = document.getElementById("exit-button")
      , te = document.getElementById("skip-button-pause")
      , re = document.getElementById("skip-button-ingame")
      , ne = document.getElementById("ingame")
      , ie = document.getElementById("back-button-settings")
      , oe = document.getElementById("settings-button")
      , ae = document.getElementById("resolution-low")
      , se = document.getElementById("resolution-default")
      , ce = document.getElementById("resolution-ultra")
      , le = document.getElementById("flash");
    (0,
    b.applyBend)(U),
    (0,
    b.applyBend)(j),
    (0,
    b.applyBend)(k),
    window.addEventListener("touchmove", function(e) {
        return e.preventDefault()
    }),
    t.progressBar = Y,
    t.basicMaterial = U,
    t.darkMaterial = j;
    t.gameStarted = !1;
    var ue = t.gameState = R.MAIN_MENU
      , he = O
      , pe = t.prevGameState = null
      , de = t.camera = void 0
      , fe = !1
      , me = !1
      , ve = !1
      , ge = void 0
      , ye = void 0
      , be = void 0
      , xe = void 0
      , we = void 0
      , _e = void 0
      , Me = 0
      , Se = t.player = void 0
      , Ee = void 0
      , Te = 1e3
      , Ae = void 0
      , Le = void 0
      , Pe = []
      , Ce = void 0
      , Re = void 0
      , Oe = void 0
      , Ie = void 0
      , Ne = 1
      , De = 0
      , Be = 0
      , ze = void 0
      , Ge = void 0
      , Ue = void 0
      , je = void 0
      , Fe = void 0
      , ke = void 0
      , He = t.gameSpeed = void 0
      , Ve = t.scene = void 0
      , We = {
        EXISTING: "existing"
    }
      , qe = void 0;
    var Xe = 0;
    function Ye() {
        if (ue === R.MAIN_MENU) {
            var e = "start";
            try {
                localStorage.getItem("supernova/level-idx") && Number(localStorage.getItem("supernova/level-idx")) === (0,
                c.getCurrentLevelNumber)() - 1 && (e = "retry")
            } catch (e) {}
            gtag("event", "level", {
                event_category: e,
                event_label: (0,
                c.getCurrentLevelNumber)().toString().padStart(6, "0"),
                value: (0,
                c.getCurrentLevelNumber)()
            }),
            ve || (gtag("event", "screen", {
                event_category: "firstStart"
            }),
            ve = !0),
            (0,
            S.canShowAds)() && !fe ? (fe = !0,
            me = !0,
            PokiSDK.commercialBreak().then(function() {
                gtag("event", "ad", {
                    event_category: "completed",
                    "event-label": "commercial-break-preroll"
                }),
                Oe.domElement.focus(),
                me = !1,
                ut(R.INGAME)
            })) : ut(R.INGAME)
        }
        Xe = Date.now()
    }
    function Je(e) {
        (0,
        S.canShowAds)() && (gtag("event", "level", {
            event_category: "attemptSkip",
            value: (0,
            c.getCurrentLevelNumber)()
        }),
        ut(R.PAUSED),
        me = !0,
        (0,
        S.requestReward)().then(function(e) {
            if (Oe.domElement.focus(),
            me = !1,
            e) {
                gtag("event", "ad", {
                    event_category: "completed",
                    "event-label": "rewarded-break"
                }),
                gtag("event", "level", {
                    event_category: "didSkip",
                    value: (0,
                    c.getCurrentLevelNumber)()
                }),
                (0,
                c.goToNextLevel)(),
                (0,
                S.gameplayStart)({
                    type: "startLevel",
                    level: (0,
                    c.getCurrentLevelNumber)(),
                    skipped: "true"
                }),
                it(),
                ut(R.INGAME, !0);
                var t = re.parentElement;
                t.removeChild(re),
                t.appendChild(re)
            }
        }))
    }
    var Ze = 0;
    function Ke() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          , t = e - De
          , r = Math.min(t * Ne, 1e3 / 30);
        Ze += r,
        (0,
        x.setTime)(Ze),
        Qe.map(function(n) {
            return n(r, Ze, t, e)
        }),
        Oe.autoClear = !0,
        Oe.setClearColor(z),
        Oe.render(Ve, de),
        Oe.clearDepth(),
        Oe.autoClear = !1,
        Oe.render(_e, we),
        l.animate(t),
        ue !== R.CONTROL_PANEL && ue !== R.UNLOCK || (ke.autoClear = !0,
        ke.render(Fe, je)),
        De = e,
        ue === R.INGAME && s.checkCollisions(Se, Pe),
        requestAnimationFrame(Ke)
    }
    var Qe = [function(e) {
        ue === R.INGAME && be.position.z < 10 && (be.position.z += .1 * e),
        ue === R.SETTINGS || ue === R.CONTROL_PANEL ? be.visible = !1 : be.visible = !0
    }
    , function() {
        W.forEach(function(e) {
            var t = e.getAttribute("data-states");
            ue === R.INGAME ? vt(e, t.includes("ingame") ? "visible" : "hidden") : ue === R.DYING ? vt(e, t.includes("dying") ? "visible" : "hidden") : ue === R.CONTROL_PANEL ? vt(e, t.includes("control-panel") ? "visible" : "hidden") : ue === R.MAIN_MENU ? vt(e, t.includes("main-menu") ? "visible" : "hidden") : ue === R.PAUSED ? vt(e, t.includes("paused") ? "visible" : "hidden") : ue === R.END_SCREEN ? vt(e, t.includes("end-screen") ? "visible" : "hidden") : ue === R.SETTINGS ? vt(e, t.includes("settings") ? "visible" : "hidden") : ue === R.UNLOCK && vt(e, t.includes("unlock") ? "visible" : "hidden")
        })
    }
    , function(e, t, r) {
        (0,
        A.update)(r)
    }
    , function(e, t) {
        var r = he === I ? .06 : .05;
        ue === R.INGAME && (a.checkForInput(a.actions.LEFT) ? Me = Math.max(-r, Me - .008) : a.checkForInput(a.actions.RIGHT) ? Me = Math.min(r, Me + .008) : a.isTouching ? (null === ge && (ge = a.isTouching.x),
        a.isTouching.y > window.innerHeight / 2 && (Me = a.isTouching.x < window.innerWidth / 2 ? Math.max(-r, Me - .008) : Math.min(r, Me + .008))) : (ge = null,
        0 !== Me && (Me *= .9))),
        ue === R.MAIN_MENU && (Se.rotation.z = 0)
    }
    , function(e, t) {
        if (ue !== R.PAUSED && ue !== R.CONTROL_PANEL && ue !== R.SETTINGS) {
            ue === R.DYING || ue === R.END_SCREEN ? Se.position.z += He * e : (ue === R.INGAME && he === O || ue === R.MAIN_MENU) && (Se.position.z = N.z);
            var r = Me * e;
            ue === R.INGAME && function(e) {
                var t = 1;
                "tunnel" === xe.type && (t = -1);
                var r = pt(Se.position, xe.center, -.05 * e * t);
                Se.position.x = r.x,
                Se.position.y = r.y;
                var i = pt(Re.position, xe.center, -.05 * e * t);
                Re.position.x = i.x,
                Re.position.y = i.y;
                var o = !0
                  , a = !1
                  , s = void 0;
                try {
                    for (var c, l = Pe[Symbol.iterator](); !(o = (c = l.next()).done); o = !0) {
                        var u = c.value;
                        u.ray.set(new n.Vector3(Se.position.x + (u.ray.__offset ? u.ray.__offset.x : 0),Se.position.y + (u.ray.__offset ? u.ray.__offset.y : 0),Se.position.z + (u.ray.__offset ? u.ray.__offset.z : 0)), u.ray.__originalDirection.clone().applyAxisAngle(new n.Vector3(0,0,1), Se.rotation.z))
                    }
                } catch (e) {
                    a = !0,
                    s = e
                } finally {
                    try {
                        !o && l.return && l.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
            }(r),
            Se.rotation.z = dt(Se.position, xe.center) - .15 * r,
            Ee.position.y = .1 * Math.sin(.003 * t)
        }
    }
    , function(e) {
        if (ue !== R.PAUSED && ue !== R.CONTROL_PANEL && ue !== R.SETTINGS) {
            var t = He * e;
            xe.move(t),
            s.distanceMoved(t),
            ue === R.INGAME && (Be += t),
            (0,
            b.setDistanceTraveled)(Be)
        }
    }
    , function(e) {
        ue !== R.INGAME && ue !== R.MAIN_MENU || (Ne = 1),
        e <= 0 || (ue === R.END_SCREEN ? t.gameSpeed = He = Math.max(0, .95 * He) : He < (0,
        c.getCurrentSpeed)() ? t.gameSpeed = He = (0,
        c.getCurrentSpeed)() : He > (0,
        c.getCurrentSpeed)() && (t.gameSpeed = He = ft(He, (0,
        c.getCurrentSpeed)(), .08)))
    }
    , function(e, t, r) {
        ue !== R.PAUSED && ue !== R.CONTROL_PANEL && ue !== R.SETTINGS && (!function(e, t, r) {
            var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
                x: 0,
                y: 0
            }
              , i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .18
              , o = dt(e.position, n)
              , a = dt(t.position, n)
              , s = o - a;
            s > Math.PI ? a += 2 * Math.PI : s < -Math.PI && (a -= 2 * Math.PI);
            var c = ft(a, o, i)
              , l = pt(r, n, c);
            t.position.x = l.x,
            t.position.y = l.y,
            t.rotation.z = c
        }(Se, de, D, xe.center, .016 * e),
        de.position.x = de.position.x + A.shakeAmount.x,
        de.position.y = de.position.y + A.shakeAmount.y,
        R.DYING)
    }
    , function(e, t) {
        if (ue !== R.PAUSED && ue !== R.CONTROL_PANEL && ue !== R.SETTINGS) {
            H.color.setHex((0,
            c.getTunnelConfig)().particleColor);
            var r = !0
              , n = !1
              , i = void 0;
            try {
                for (var o, a = Ce.geometry.vertices[Symbol.iterator](); !(r = (o = a.next()).done); r = !0) {
                    var s = o.value;
                    s.z += He * e,
                    s.z > 0 && (s.z = V)
                }
            } catch (e) {
                n = !0,
                i = e
            } finally {
                try {
                    !r && a.return && a.return()
                } finally {
                    if (n)
                        throw i
                }
            }
            Ce.geometry.verticesNeedUpdate = !0
        }
    }
    , function() {
        s.spawn()
    }
    , function(e) {
        [R.MAIN_MENU, R.PAUSED, R.CONTROL_PANEL, R.SETTINGS, R.UNLOCK].includes(ue) || s.handleMove(e)
    }
    , function(e) {
        (0,
        T.update)(e),
        ue === R.INGAME && (Te <= 0 ? ((0,
        T.increaseSpeed)(),
        Te = 1e3) : Te -= e)
    }
    , function(e, t) {
        if (ue !== R.PAUSED && ue !== R.CONTROL_PANEL && ue !== R.SETTINGS) {
            var r = (0,
            c.getTunnelConfig)();
            if ("six" === r.geometry ? (Ie = Ge,
            ze.visible = !1,
            Ge.visible = !0,
            Ue.visible = !1) : "four" === r.geometry ? (Ie = Ue,
            ze.visible = !1,
            Ge.visible = !1,
            Ue.visible = !0) : (Ie = ze,
            ze.visible = !0,
            Ge.visible = !1,
            Ue.visible = !1),
            Ie) {
                Ie.scale.set(r.scaleX || 1, r.scaleY || 1, 1),
                Ie.rotation.z = de.rotation.z + r.rotationOffset;
                var n = !0
                  , i = !1
                  , o = void 0;
                try {
                    for (var a, s = Ie.geometry.faces[Symbol.iterator](); !(n = (a = s.next()).done); n = !0) {
                        var l = a.value
                          , u = Ie.geometry.vertices[l.b]
                          , h = r.hueModifier
                          , p = r.saturationModifier
                          , d = r.brightnessModifier;
                        h += l.normal.y / 20 + Math.abs(u.z / 500) / 1.5,
                        d += l.normal.y / 3 + Math.abs(u.z / 400) + Math.sin(u.z / 30) / 10,
                        isNaN(d) && (d = 0),
                        l.color.setHSL(h, p, d)
                    }
                } catch (e) {
                    i = !0,
                    o = e
                } finally {
                    try {
                        !n && s.return && s.return()
                    } finally {
                        if (i)
                            throw o
                    }
                }
                Ie.geometry.colorsNeedUpdate = !0;
                var f = !0
                  , m = !1
                  , v = void 0;
                try {
                    for (var g, y = Ie.geometry.vertices[Symbol.iterator](); !(f = (g = y.next()).done); f = !0) {
                        var b = g.value
                          , x = pt(b.__originalPos, {
                            x: 0,
                            y: 0
                        }, Math.sin(1 * b.z * (r.sineZModifier || 1) - .003 * t * (r.timeModifier || 1)) * r.sine);
                        b.x = x.x,
                        b.y = x.y
                    }
                } catch (e) {
                    m = !0,
                    v = e
                } finally {
                    try {
                        !f && y.return && y.return()
                    } finally {
                        if (m)
                            throw v
                    }
                }
                Ie.geometry.verticesNeedUpdate = !0
            }
        }
    }
    , function(e) {
        ue !== R.PAUSED && [].concat(C((0,
        M.getAllShips)()), [Le]).forEach(function(t) {
            t.update && t.update(e)
        })
    }
    ];
    var $e = void 0;
    function et(e, t) {
        var r = e / t;
        if (r < 1.4) {
            var n = r / 1.4;
            be.scale.set(n, n, n),
            r < 1 && (be.position.y = Math.min(14, G.y + 6 * (1 - r)),
            $e.position.set(0, be.position.y + 1.5, 0))
        } else
            be.scale.set(1, 1, 1)
    }
    function tt(e) {
        Le && Ae.remove(Le.object),
        Ae.add(e.object),
        Le = e
    }
    var rt = void 0;
    function nt() {
        var e = o.calculate()
          , t = e.width
          , r = e.height;
        de.aspect = t / r,
        de.updateProjectionMatrix(),
        we.aspect = t / r,
        we.updateProjectionMatrix(),
        Oe.setSize(t, r);
        var n = window.innerHeight / 3;
        je.left = t / -n,
        je.right = t / n,
        je.top = r / n,
        je.bottom = r / -n,
        je.updateProjectionMatrix(),
        ke.setSize(t, r),
        et(t, r),
        (0,
        S.canShowAds)() && (window.clearTimeout(rt),
        rt = window.setTimeout(function() {
            PokiSDK.destroyAd(ct),
            lt()
        }, 100))
    }
    function it() {
        s.reset(),
        Me = 0,
        _.obstaclesGroup.rotation.z = de.rotation.z
    }
    var ot = null
      , at = void 0
      , st = void 0
      , ct = document.getElementById("ingame-display");
    function lt() {
        (0,
        S.canShowAds)() && (ue === R.PAUSED ? PokiSDK.displayAd(ct, window.innerWidth > 970 && window.innerHeight > 960 ? "970x250" : window.innerWidth > 728 && window.innerHeight > 360 ? "728x90" : "320x50") : PokiSDK.destroyAd(ct))
    }
    function ut(e) {
        var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (ue !== e) {
            if ((e === R.MAIN_MENU || ue === R.MAIN_MENU && e === R.INGAME) && (0,
            T.resetSpeed)(),
            [R.INGAME, R.DYING, R.END_SCREEN].includes(e) || ((0,
            S.canShowAds)() && PokiSDK.destroyAd(ct),
            re.removeAttribute("visible")),
            ue === R.PAUSED && ot && (e === R.MAIN_MENU || r || (e = ot),
            ot = null),
            e === R.INGAME ? ue === R.MAIN_MENU ? (0,
            S.gameplayStart)({
                type: "startLevel",
                level: (0,
                c.getCurrentLevelNumber)()
            }) : (0,
            S.gameplayStart)() : ue === R.INGAME && (0,
            S.gameplayStop)(),
            e === R.PAUSED ? ne.setAttribute("inactive", "true") : ne.removeAttribute("inactive"),
            t.prevGameState = pe = ue,
            t.gameState = ue = e,
            lt(),
            [R.CONTROL_PANEL, R.MAIN_MENU, R.PAUSED, R.UNLOCK].includes(ue) && requestAnimationFrame(function() {
                var e = Array.from(document.body.getElementsByClassName("button"));
                e.forEach(function(e) {
                    return e.removeAttribute("active")
                });
                var t = document.getElementById(ue === R.CONTROL_PANEL ? "control-panel" : ue === R.PAUSED ? "paused" : ue === R.UNLOCK ? "unlock" : "main-menu");
                (e = Array.from(t.getElementsByClassName("button"))).forEach(function(e) {
                    "true" === e.getAttribute("default-active") && e.setAttribute("active", "true")
                })
            }, 0),
            e === R.MAIN_MENU && pe !== R.CONTROL_PANEL) {
                it(),
                be.position.copy(G);
                var n = o.calculate();
                et(n.width, n.height)
            }
            e === R.PAUSED && [R.DYING, R.END_SCREEN].includes(pe) && (ot = pe,
            clearTimeout(at),
            clearTimeout(st)),
            e === R.DYING && (at = window.setTimeout(function() {
                de.fov = 87,
                de.position.z = D.z,
                Ne = 1,
                ut(R.END_SCREEN)
            }, 500)),
            e === R.END_SCREEN && (st = window.setTimeout(function() {
                it(),
                gtag("event", "level", {
                    event_category: "retry",
                    event_label: (0,
                    c.getCurrentLevelNumber)().toString().padStart(6, "0"),
                    value: (0,
                    c.getCurrentLevelNumber)()
                }),
                (0,
                T.tmpDecreaseSpeed)(!0),
                ut(R.INGAME)
            }, 1e3))
        }
    }
    var ht = void 0;
    function pt(e, t, r) {
        return {
            x: Math.cos(r) * (e.x - t.x) - Math.sin(r) * (e.y - t.y) + t.x,
            y: Math.sin(r) * (e.x - t.x) + Math.cos(r) * (e.y - t.y) + t.y
        }
    }
    function dt(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
            x: 0,
            y: 0
        };
        return Math.atan2(e.y - t.y, e.x - t.x) - .5 * Math.PI
    }
    function ft(e, t, r) {
        return e + r * (t - e)
    }
    function mt(e) {
        if (ue === R.MAIN_MENU || ue === R.PAUSED) {
            var t = document.getElementById(ue === R.MAIN_MENU ? "main-menu" : "paused")
              , r = Array.from(t.getElementsByClassName("button")).filter(function(e) {
                return !e.hasAttribute("skip-focus") && !e.hasAttribute("disabled")
            })
              , n = r.find(function(e) {
                return e.hasAttribute("active")
            })
              , i = r.indexOf(n);
            n.removeAttribute("active");
            var o = i + e;
            (o >= r.length || o < 0) && (o = i),
            r[o].setAttribute("active", !0)
        }
    }
    function vt(e, t) {
        e.className !== t && (e.className = t)
    }
}
, function(e, t) {
    e.exports = function() {
        throw new Error("define cannot be used indirect")
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.worldIsTransitioning = t.levelEnd = t.level = t.getTunnelConfig = t.levelsPerWorld = t.unlocks = void 0,
    t.getSeededRandom = function() {
        return w
    }
    ,
    t.resetLevel = function() {
        _ = 0
    }
    ,
    t.getCurrentLevelNumber = S,
    t.isLastLevelInWorld = E,
    t.transitionWorld = function() {
        t.worldIsTransitioning = b = !0
    }
    ,
    t.getNextSegment = function() {
        var e = y.segments[_];
        if (!e)
            return null;
        ++M >= (e.repeat || 1) && (_++,
        M = 0);
        return e
    }
    ,
    t.goToNextWorld = T,
    t.goToNextLevel = function() {
        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        E() && T();
        if (!e) {
            var r = f[S()];
            r && o.toggleUnlock(r)
        }
        t.level = y = a.default.getLevelByIdx(++x),
        v.innerText = "LEVEL " + (x + 1),
        w = (0,
        n.default)(x),
        0 === x ? document.body.removeAttribute("notFirstLevel") : document.body.setAttribute("notFirstLevel", "true");
        e || (v.className = "active",
        z = 1e3);
        try {
            e && 0 === currrentLevelIdx || localStorage.setItem("supernova/level-idx", x)
        } catch (e) {}
        t.levelEnd = function() {
            var e = -s.spawnPos;
            return y.segments.forEach(function(t, r) {
                for (var n = 0; n < (t.repeat || 1); n++)
                    for (var o = t ? t.amount || 1 : 0, a = 0; a < o; a++)
                        e -= a < o - 1 ? t.obstacleInterval || i.default[t.type].defaultObstacleInterval || 60 : t.nextSegmentBuffer || y.segmentBuffer || 30
            }),
            e
        }(),
        _ = 0;
        var l = x + 1 - (x + 1) % m + m;
        document.getElementById("play-level-button").innerHTML = x + 1 + "<span>/</span>" + l,
        document.getElementById("level").innerText = x + 1,
        document.getElementById("next-level").innerText = x + 2;
        var u = Object.keys(f).map(function(e) {
            return Number(e)
        })
          , h = [].concat(function(e) {
            if (Array.isArray(e)) {
                for (var t = 0, r = Array(e.length); t < e.length; t++)
                    r[t] = e[t];
                return r
            }
            return Array.from(e)
        }(u)).reverse();
        S() > h[0] ? "none" !== g.style.display && (L.style.display = "none") : A.forEach(function(e, t) {
            var r = u.find(function(e) {
                return e > S() - 1
            });
            if (r) {
                var n = h.find(function(e) {
                    return e < S()
                })
                  , i = r - n
                  , o = x - n;
                e.className = "world-bar " + (t < o ? "active" : "") + " " + (t === o ? "current" : "") + " " + (t >= i ? "hidden" : "")
            } else
                e.className = "world-bar hidden"
        });
        c.default || 0 === x ? "flex" !== O.style.display && (O.style.display = "flex") : "flex" === O.style.display && (O.style.display = "none");
        e || (gtag("event", "level", {
            event_category: "complete",
            event_label: (S() - 1).toString().padStart(6, "0"),
            value: S() - 1
        }),
        gtag("event", "level", {
            event_category: "start",
            event_label: S().toString().padStart(6, "0"),
            value: S()
        }))
    }
    ,
    t.getCurrentSpeed = function() {
        return h * p
    }
    ,
    t.update = function(e) {
        if (l.gameState !== l.STATE.INGAME)
            return;
        z > 0 ? z -= e : "" !== v.className && (v.className = "");
        var t = d < p ? .002 : .015;
        (p = (0,
        l.lerp)(p, d, t * e)) <= .05 && (d = G,
        G = null);
        if (Math.round(100 * p) > D) {
            D = Math.round(100 * p);
            try {
                I.innerText = "BEST: " + D,
                localStorage.setItem("supernova/best-speed", D)
            } catch (e) {}
        }
        F()
    }
    ,
    t.resetSpeed = function() {
        G = null,
        p = 1
    }
    ,
    t.tmpDecreaseSpeed = function(e) {
        0 !== d && (G = d);
        d = 0,
        e && (p = .05)
    }
    ,
    t.increaseSpeed = function() {
        if (null === G && p < k) {
            var e = .01 * (k - d);
            d = Math.min(2, d + e)
        }
    }
    ,
    t.increaseStreak = function() {
        if (j.innerText = ++H,
        j.className = "",
        j.offsetWidth,
        j.className = "increase",
        H > B) {
            B = H;
            try {
                N.innerText = "BEST: " + B,
                localStorage.setItem("supernova/best-streak", B)
            } catch (e) {}
        }
    }
    ,
    t.resetStreak = function() {
        H = 0,
        j.innerText = H,
        j.className = "",
        j.offsetWidth,
        j.className = "decrease"
    }
    ,
    t.sendStreak = function() {
        PokiSDK && PokiSDK.sendHighscore && PokiSDK.sendHighscore(H)
    }
    ,
    t.decreaseSpeed = function() {
        if (p <= 1.1)
            p = 1;
        else {
            var e = .8 * (1 - (k - p));
            p = Math.max(1, p - e)
        }
        d = p,
        F(),
        U.className = "",
        U.offsetWidth,
        U.className = "decrease"
    }
    ;
    var n = u(r(23))
      , i = u(r(34))
      , o = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(17))
      , a = u(r(27))
      , s = r(4)
      , c = u(r(20))
      , l = r(1);
    function u(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var h = .1
      , p = 1
      , d = 1
      , f = t.unlocks = {}
      , m = t.levelsPerWorld = 5
      , v = document.getElementById("level-transition")
      , g = document.getElementById("world-bars")
      , y = (t.getTunnelConfig = function() {
        return a.default.getWorldByIdx(Math.floor(x / m) + (b ? 1 : 0))
    }
    ,
    t.level = void 0)
      , b = (t.levelEnd = void 0,
    t.worldIsTransitioning = !1)
      , x = void 0;
    try {
        x = (Number(localStorage.getItem("supernova/level-idx")) || 0) - 1
    } catch (e) {
        x = -1
    }
    var w = (0,
    n.default)(x);
    var _ = 0
      , M = 0;
    function S() {
        return x + 1
    }
    function E() {
        return x > 0 && (x + 1) % m == 0
    }
    function T() {
        t.worldIsTransitioning = b = !1
    }
    for (var A = [], L = document.getElementById("world-bars"), P = 0; P < 10; P++) {
        var C = document.createElement("div");
        C.className = "world-bar";
        var R = document.createElement("div");
        R.className = "inner",
        C.appendChild(R),
        L.appendChild(C),
        A.push(C)
    }
    var O = document.getElementById("controls");
    var I = document.getElementById("speed-best")
      , N = document.getElementById("streak-best")
      , D = 0
      , B = 0;
    try {
        D = Number(localStorage.getItem("supernova/best-speed")),
        B = Number(localStorage.getItem("supernova/best-streak"))
    } catch (e) {}
    I.innerText = "BEST: " + D,
    N.innerText = "BEST: " + B;
    var z = 0
      , G = null;
    var U = document.getElementById("speed-number")
      , j = document.getElementById("streak-number")
      , F = function() {
        var e = Math.round(100 * p);
        U.innerText != e && (e > U.innerText && (U.className = "",
        U.offsetWidth,
        U.className = "increase"),
        U.innerText = e)
    };
    F();
    var k = 2;
    var H = 0
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.obstaclesGroup = t.spawnPos = void 0;
    var n = function() {
        return function(e, t) {
            if (Array.isArray(e))
                return e;
            if (Symbol.iterator in Object(e))
                return function(e, t) {
                    var r = []
                      , n = !0
                      , i = !1
                      , o = void 0;
                    try {
                        for (var a, s = e[Symbol.iterator](); !(n = (a = s.next()).done) && (r.push(a.value),
                        !t || r.length !== t); n = !0)
                            ;
                    } catch (e) {
                        i = !0,
                        o = e
                    } finally {
                        try {
                            !n && s.return && s.return()
                        } finally {
                            if (i)
                                throw o
                        }
                    }
                    return r
                }(e, t);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }();
    t.getPercToLevelEnd = v,
    t.reset = H,
    t.spawn = function() {
        var e = z ? z.amount || 1 : 0;
        if (!z || G >= e)
            return z = (0,
            s.getNextSegment)(),
            G = 0,
            U = V(),
            void (j += .2 * z && z.rotationModifier || 1);
        if (Math.abs(B) - Math.abs(m.position.z) < p) {
            var t = a.default[z.type]
              , r = new t(z.data || {});
            d.push(r),
            r.group.position.z = B,
            "random" === z.rotation ? r.group.rotation.z = V() : "randomAsSegment" === z.rotation ? r.group.rotation.z = U : "increaseAsSegment" === z.rotation ? r.group.rotation.z = j : "sine" === z.rotation ? r.group.rotation.z = .5 * Math.sin(.5 * G) : "increase" === z.rotation ? r.group.rotation.z = (f ? f.group.rotation.z : 0) + (.2 * z.rotationModifier || 1) : "last" === z.rotation ? r.group.rotation.z = f ? f.group.rotation.z : 0 : isNaN(z.rotation) || (r.group.rotation.z = z.rotation),
            B -= G < e - 1 ? z.obstacleInterval || t.defaultObstacleInterval || 60 : z.nextSegmentBuffer || s.level.segmentBuffer || 30,
            m.add(r.group),
            G++,
            f = r
        }
        w.position.z = B,
        R.position.z = B
    }
    ,
    t.distanceMoved = function(e) {
        var t = !0
          , r = !1
          , n = void 0;
        try {
            for (var i, o = d[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                var a = i.value;
                a.distanceMoved && a.distanceMoved(e)
            }
        } catch (e) {
            r = !0,
            n = e
        } finally {
            try {
                !t && o.return && o.return()
            } finally {
                if (r)
                    throw n
            }
        }
    }
    ,
    t.handleMove = function(e) {
        R.rotation.z = o.camera.rotation.z - m.rotation.z,
        m.position.z += o.gameSpeed * e;
        var t = [];
        for (var r in d) {
            var i = d[r];
            i.update && i.update(e);
            var a = m.position.z + i.group.position.z;
            a > (i.poolBuffer || 0) && t.push(r)
        }
        if (t.forEach(function(e) {
            var t = d[e];
            t.pool(),
            d.splice(e, 1),
            m.remove(t.group)
        }),
        w.visible) {
            var c = !0
              , p = !1
              , f = void 0;
            try {
                for (var b, x = _.entries()[Symbol.iterator](); !(c = (b = x.next()).done); c = !0) {
                    var M = b.value
                      , S = n(M, 2)
                      , E = (S[0],
                    S[1])
                      , T = Math.abs(w.position.z + E.position.z) - m.position.z;
                    E.children[0].material = T > 35 ? y : g
                }
            } catch (e) {
                p = !0,
                f = e
            } finally {
                try {
                    !c && x.return && x.return()
                } finally {
                    if (p)
                        throw f
                }
            }
        }
        o.gameState === o.STATE.INGAME && (o.progressBar.style.transform = "scale3d(" + v() + ", 1, 1)");
        (0,
        s.isLastLevelInWorld)() && !s.worldIsTransitioning && (D.getWorldPosition(W),
        W.z + 10 > -u.player.position.z && (0,
        s.transitionWorld)());
        (0,
        s.isLastLevelInWorld)() || (C.getWorldPosition(q),
        q.z - 10 > -u.player.position.z && (0,
        h.tmpDecreaseSpeed)());
        if (F.getWorldPosition(X),
        X.z + 10 > -u.player.position.z)
            return (0,
            l.gameplayStop)(),
            (0,
            s.goToNextLevel)(),
            (0,
            l.gameplayStart)({
                type: "startLevel",
                level: (0,
                h.getCurrentLevelNumber)()
            }),
            (0,
            u.cBreak)(),
            m.rotation.z = o.camera.rotation.z,
            void H()
    }
    ,
    t.checkCollisions = function(e, t) {
        var r = !0
          , n = !1
          , i = void 0;
        try {
            for (var a, s = d[Symbol.iterator](); !(r = (a = s.next()).done); r = !0) {
                var c = a.value
                  , l = c.checkCollisions(t);
                if ("obstacle" === l)
                    return void (0,
                    o.playerDied)();
                "obstacleTrigger" === l && (0,
                o.obstacleTrigger)()
            }
        } catch (e) {
            n = !0,
            i = e
        } finally {
            try {
                !r && s.return && s.return()
            } finally {
                if (n)
                    throw i
            }
        }
    }
    ;
    var i = r(0)
      , o = r(1)
      , a = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(34))
      , s = r(3)
      , c = r(36)
      , l = r(13)
      , u = r(1)
      , h = r(3);
    var p = t.spawnPos = 320
      , d = []
      , f = void 0
      , m = t.obstaclesGroup = new i.Group;
    function v() {
        return -m.position.z / (s.levelEnd + F.position.z)
    }
    var g = new i.MeshPhongMaterial({
        color: 2927550,
        emissive: 468276,
        side: i.FrontSide,
        flatShading: !0
    })
      , y = new i.MeshPhongMaterial({
        color: 2236962,
        emissive: 468276,
        side: i.FrontSide,
        flatShading: !0
    })
      , b = new i.MeshPhongMaterial({
        color: 16777215,
        emissive: 468276,
        side: i.DoubleSide,
        flatShading: !0
    })
      , x = new i.MeshPhongMaterial({
        color: 2236962,
        emissive: 468276,
        side: i.DoubleSide,
        flatShading: !0
    });
    (0,
    c.applyBend)(g),
    (0,
    c.applyBend)(y),
    (0,
    c.applyBend)(b),
    (0,
    c.applyBend)(x);
    for (var w = new i.Group, _ = [], M = 0; M < 5; M++) {
        for (var S = new i.Group, E = [[20, 3]], T = 0; T < E.length; T++) {
            var A = E[T]
              , L = (0,
            o.createTorus)(A[0], A[1], 8, 15);
            L.material = g,
            L.scale.setScalar(1 - .005 * M),
            S.add(L)
        }
        _.push(S),
        w.add(S),
        S.position.z = -20 * M
    }
    var P = (0,
    o.createCylinder)(20, 4, 6);
    P.geometry.rotateX(.5 * Math.PI),
    P.visible = !1,
    P.position.z = _[_.length - 1].position.z,
    w.add(P);
    var C = (0,
    o.createCylinder)(20, 4, 6);
    C.geometry.rotateX(.5 * Math.PI),
    C.visible = !1,
    C.position.z = _[0].position.z,
    w.add(C),
    m.add(w);
    var R = (0,
    o.createCylinder)(20, 300, 3, 60, !0);
    R.material = b,
    R.geometry.rotateX(.5 * Math.PI),
    R.geometry.rotateZ(Math.PI),
    R.geometry.translate(0, 0, -150);
    var O = (0,
    o.createTorus)(20, 2, 8, 3, 2 * Math.PI);
    O.geometry.rotateZ(1.5 * -Math.PI),
    O.material = x,
    R.add(O);
    var I = (0,
    o.createTorus)(20, 2, 8, 3, 2 * Math.PI);
    I.geometry.rotateZ(1.5 * -Math.PI),
    I.material = x,
    I.position.z = -300,
    R.add(I);
    var N = (0,
    o.createCylinder)(20, 4, 6);
    N.geometry.rotateX(.5 * Math.PI),
    N.visible = !1,
    N.position.z = -300,
    R.add(N);
    var D = (0,
    o.createCylinder)(20, 4, 6);
    D.geometry.rotateX(.5 * Math.PI),
    D.visible = !1,
    D.position.z = -90,
    R.add(D),
    m.add(R);
    var B = void 0
      , z = void 0
      , G = void 0
      , U = void 0
      , j = 0
      , F = void 0
      , k = !1;
    function H() {
        k || (o.scene.add(m),
        k = !0),
        j = 0,
        function() {
            var e = !0
              , t = !1
              , r = void 0;
            try {
                for (var n, i = d[Symbol.iterator](); !(e = (n = i.next()).done); e = !0) {
                    var o = n.value;
                    o.pool()
                }
            } catch (e) {
                t = !0,
                r = e
            } finally {
                try {
                    !e && i.return && i.return()
                } finally {
                    if (t)
                        throw r
                }
            }
            d = []
        }(),
        B = -p,
        m.position.z = 0,
        G = 0,
        z = void 0,
        Object.values(m.children).forEach(function(e) {
            e !== w && e !== R && m.remove(e)
        }),
        (0,
        s.resetLevel)(),
        (0,
        s.isLastLevelInWorld)() ? (F = N,
        w.position.y = 500,
        R.position.y = 0) : (F = P,
        w.position.y = 0,
        R.position.y = 500)
    }
    function V() {
        var e = d[d.length - 1];
        return (e ? e.group.rotation.z : 0) - Math.PI * (0,
        s.getSeededRandom)()() * 2
    }
    var W = new i.Vector3
      , q = new i.Vector3
      , X = new i.Vector3
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.resources = void 0,
    t.load = function(e) {
        var t = new n.FontLoader
          , r = new i.default;
        new n.TextureLoader;
        Promise.all([new Promise(function(e) {
            r.load("ship.obj", function(t) {
                var r = new n.Geometry
                  , i = !0
                  , a = !1
                  , s = void 0;
                try {
                    for (var c, l = t.children[Symbol.iterator](); !(i = (c = l.next()).done); i = !0) {
                        var u = c.value;
                        r.merge((new n.Geometry).fromBufferGeometry(u.geometry))
                    }
                } catch (e) {
                    a = !0,
                    s = e
                } finally {
                    try {
                        !i && l.return && l.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
                o.models.ship = new n.Mesh(r),
                e()
            })
        }
        ), new Promise(function(e) {
            r.load("ship-2.obj", function(t) {
                var r = new n.Geometry
                  , i = !0
                  , a = !1
                  , s = void 0;
                try {
                    for (var c, l = t.children[Symbol.iterator](); !(i = (c = l.next()).done); i = !0) {
                        var u = c.value;
                        r.merge((new n.Geometry).fromBufferGeometry(u.geometry))
                    }
                } catch (e) {
                    a = !0,
                    s = e
                } finally {
                    try {
                        !i && l.return && l.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
                o.models.ship2 = new n.Mesh(r),
                e()
            })
        }
        ), new Promise(function(e) {
            r.load("ship-3.obj", function(t) {
                var r = new n.Geometry
                  , i = !0
                  , a = !1
                  , s = void 0;
                try {
                    for (var c, l = t.children[Symbol.iterator](); !(i = (c = l.next()).done); i = !0) {
                        var u = c.value;
                        r.merge((new n.Geometry).fromBufferGeometry(u.geometry))
                    }
                } catch (e) {
                    a = !0,
                    s = e
                } finally {
                    try {
                        !i && l.return && l.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
                o.models.ship3 = new n.Mesh(r),
                e()
            })
        }
        ), new Promise(function(e) {
            r.load("ship-4.obj", function(t) {
                var r = new n.Geometry
                  , i = !0
                  , a = !1
                  , s = void 0;
                try {
                    for (var c, l = t.children[Symbol.iterator](); !(i = (c = l.next()).done); i = !0) {
                        var u = c.value;
                        r.merge((new n.Geometry).fromBufferGeometry(u.geometry))
                    }
                } catch (e) {
                    a = !0,
                    s = e
                } finally {
                    try {
                        !i && l.return && l.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
                o.models.ship4 = new n.Mesh(r),
                e()
            })
        }
        ), new Promise(function(e) {
            r.load("ship-5.obj", function(t) {
                var r = new n.Geometry
                  , i = !0
                  , a = !1
                  , s = void 0;
                try {
                    for (var c, l = t.children[Symbol.iterator](); !(i = (c = l.next()).done); i = !0) {
                        var u = c.value;
                        r.merge((new n.Geometry).fromBufferGeometry(u.geometry))
                    }
                } catch (e) {
                    a = !0,
                    s = e
                } finally {
                    try {
                        !i && l.return && l.return()
                    } finally {
                        if (a)
                            throw s
                    }
                }
                o.models.ship5 = new n.Mesh(r),
                e()
            })
        }
        ), new Promise(function(e) {
            t.load("aldotheapache.json", function(t) {
                o.fonts.logoFont = t,
                e()
            })
        }
        )]).then(function() {
            return e(o)
        })
    }
    ;
    var n = r(0)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(90));
    var o = t.resources = {
        fonts: {},
        models: {},
        textures: {}
    }
}
, function(e, t, r) {
    "use strict";
    e.exports = function(e) {
        return e.webpackPolyfill || (e.deprecate = function() {}
        ,
        e.paths = [],
        e.children || (e.children = []),
        Object.defineProperty(e, "loaded", {
            enumerable: !0,
            get: function() {
                return e.l
            }
        }),
        Object.defineProperty(e, "id", {
            enumerable: !0,
            get: function() {
                return e.i
            }
        }),
        e.webpackPolyfill = 1),
        e
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }();
    t.default = function() {
        var e = a.get("obstacleTrigger");
        e || (e = new s);
        return e.object.visible = !0,
        e
    }
    ;
    var i = r(0)
      , o = r(1)
      , a = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(9));
    var s = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            o.gameStarted && console.warn("⚠️ Creating ObstacleTrigger in-game!");
            var t = new i.Group
              , r = (0,
            o.createCylinder)(20, 4, 6);
            r.geometry.rotateX(.5 * Math.PI),
            r.visible = !1,
            r.position.z = 2,
            t.add(r),
            this.trigger = r,
            this.object = t
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.object.visible = !1,
                this.object.position.setScalar(0),
                this.object.rotation.set(0, 0, 0),
                this.object.scale.setScalar(1),
                a.pool("obstacleTrigger", this)
            }
        }]),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }()
      , i = r(0)
      , o = r(3);
    var a = new i.MeshPhongMaterial({
        color: 16737826,
        emissive: 11150644,
        side: i.FrontSide,
        flatShading: !1
    })
      , s = new i.MeshBasicMaterial({
        color: 0,
        side: i.FrontSide,
        flatShading: !1
    })
      , c = function() {
        function e(t) {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e);
            var r = t.id
              , n = t.color
              , i = t.object
              , c = t.name
              , l = t.applyShader
              , u = t.update
              , h = t.unlockLevel;
            this.options = t,
            this.id = r,
            this.name = c,
            this.object = i.clone(),
            this.object.geometry.center(),
            this.material = a.clone(),
            this.object.material = this.material,
            this.unlockLevel = h,
            o.unlocks[this.unlockLevel] = this.id,
            this.object.frustumCulled = !0,
            l ? (l(this.material),
            this.inactiveMaterial = s.clone(),
            l(this.inactiveMaterial)) : this.inactiveMaterial = s,
            this.object.geometry.computeBoundingBox(),
            this.setColor(n),
            u && (this.update = u.bind(this))
        }
        return n(e, [{
            key: "setColor",
            value: function(e) {
                switch (e) {
                default:
                case "yellow":
                    this.object.material.color.setHex(16737826),
                    this.object.material.emissive.setHex(11150644);
                    break;
                case "white":
                    this.object.material.color.setHex(6728379),
                    this.object.material.emissive.setHex(4456482);
                    break;
                case "black":
                    this.object.material.color.setHex(1118481),
                    this.object.material.emissive.setHex(2236962);
                    break;
                case "red":
                    this.object.material.color.setHex(7803136),
                    this.object.material.emissive.setHex(0)
                }
            }
        }, {
            key: "setActive",
            value: function() {
                this.object.material = this.material
            }
        }, {
            key: "setInactive",
            value: function() {
                this.object.material = this.inactiveMaterial
            }
        }, {
            key: "isUnlocked",
            value: function() {
                var e = void 0
                  , t = !1;
                try {
                    e = Number(localStorage.getItem("supernova/level-idx")) || 0,
                    t = localStorage.getItem("supernova/ship-unlocked-" + this.id)
                } catch (t) {
                    e = 0
                }
                return e > this.unlockLevel - 1 || t
            }
        }, {
            key: "clone",
            value: function() {
                var t = new e(this.options);
                return t.object = t.object.clone(),
                t
            }
        }]),
        e
    }();
    t.default = function(e) {
        return new c(e)
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.pool = function(e, t) {
        n[e] || (n[e] = []);
        if (t._pooled)
            return;
        t._pooled = !0,
        n[e].push(t)
    }
    ,
    t.get = function(e) {
        if (!n[e] || 0 === n[e].length)
            return null;
        var t = n[e].pop();
        return t._pooled = !1,
        t
    }
    ;
    var n = {};
    window.pools = n
}
, function(e, t) {
    (function(t) {
        e.exports = t
    }
    ).call(t, {})
}
, function(e, t, r) {
    "use strict";
    var n = r(24)
      , i = r(85)
      , o = r(48)
      , a = r(54)
      , s = r(56);
    (e.exports = function(e, t) {
        var r, i, c, l, u;
        return arguments.length < 2 || "string" != typeof e ? (l = t,
        t = e,
        e = null) : l = arguments[2],
        n(e) ? (r = s.call(e, "c"),
        i = s.call(e, "e"),
        c = s.call(e, "w")) : (r = c = !0,
        i = !1),
        u = {
            value: t,
            configurable: r,
            enumerable: i,
            writable: c
        },
        l ? o(a(l), u) : u
    }
    ).gs = function(e, t, r) {
        var c, l, u, h;
        return "string" != typeof e ? (u = r,
        r = t,
        t = e,
        e = null) : u = arguments[3],
        n(t) ? i(t) ? n(r) ? i(r) || (u = r,
        r = void 0) : r = void 0 : (u = t,
        t = r = void 0) : t = void 0,
        n(e) ? (c = s.call(e, "c"),
        l = s.call(e, "e")) : (c = !0,
        l = !1),
        h = {
            get: t,
            set: r,
            configurable: c,
            enumerable: l
        },
        u ? o(a(u), h) : h
    }
}
, function(e, t, r) {
    "use strict";
    e.exports = r(66)() ? globalThis : r(65)
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.canShowAds = function() {
        return i
    }
    ,
    t.trackLoadingStarted = function() {
        n ? (console.info("✨POKISDK: Loading started on time"),
        PokiSDK.gameLoadingStart()) : window.loadingStartedButNotSent = !0
    }
    ,
    t.trackLoadingFinished = function() {
        n ? (console.info("✨POKISDK: Loading finished on time"),
        PokiSDK.gameLoadingFinished()) : window.loadingFinishedButNotSent = !0
    }
    ,
    t.requestReward = function() {
        return PokiSDK.rewardedBreak()
    }
    ,
    t.gameplayStart = function(e) {
        n && PokiSDK.gameplayStart(e)
    }
    ,
    t.gameplayStop = function(e) {
        n && PokiSDK.gameplayStop(e)
    }
    ,
    t.attemptSDKInit = function e() {
        if ("undefined" == typeof PokiSDK)
            return void window.setTimeout(function() {
                e()
            }, 500);
        PokiSDK.init().then(function() {
            n = !0,
            i = !0,
            document.getElementById("skip-button-pause").removeAttribute("disabled"),
            o()
        }).catch(function() {
            n = !0,
            o()
        })
    }
    ;
    var n = !1
      , i = !1;
    function o() {
        window.loadingStartedButNotSent && (console.info("✨POKISDK: Loading started catchup"),
        PokiSDK.gameLoadingStart(),
        window.loadingStartedButNotSent = !1),
        window.loadingFinishedButNotSent && (console.info("✨POKISDK: Loading finished catchup"),
        PokiSDK.gameLoadingFinished(),
        window.loadingFinishedButNotSent = !1)
    }
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
      , i = TypeError
      , o = Object.getOwnPropertyDescriptor;
    if (o)
        try {
            o({}, "")
        } catch (e) {
            o = null
        }
    var a = function() {
        throw new i
    }
      , s = o ? function() {
        try {
            return arguments.callee,
            a
        } catch (e) {
            try {
                return o(arguments, "callee").get
            } catch (e) {
                return a
            }
        }
    }() : a
      , c = r(68)()
      , l = Object.getPrototypeOf || function(e) {
        return e.__proto__
    }
      , u = void 0
      , h = "undefined" == typeof Uint8Array ? void 0 : l(Uint8Array)
      , p = {
        "%Array%": Array,
        "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer,
        "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype,
        "%ArrayIteratorPrototype%": c ? l([][Symbol.iterator]()) : void 0,
        "%ArrayPrototype%": Array.prototype,
        "%ArrayProto_entries%": Array.prototype.entries,
        "%ArrayProto_forEach%": Array.prototype.forEach,
        "%ArrayProto_keys%": Array.prototype.keys,
        "%ArrayProto_values%": Array.prototype.values,
        "%AsyncFromSyncIteratorPrototype%": void 0,
        "%AsyncFunction%": void 0,
        "%AsyncFunctionPrototype%": void 0,
        "%AsyncGenerator%": void 0,
        "%AsyncGeneratorFunction%": void 0,
        "%AsyncGeneratorPrototype%": void 0,
        "%AsyncIteratorPrototype%": u && c && Symbol.asyncIterator ? u[Symbol.asyncIterator]() : void 0,
        "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics,
        "%Boolean%": Boolean,
        "%BooleanPrototype%": Boolean.prototype,
        "%DataView%": "undefined" == typeof DataView ? void 0 : DataView,
        "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype,
        "%Date%": Date,
        "%DatePrototype%": Date.prototype,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%ErrorPrototype%": Error.prototype,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%EvalErrorPrototype%": EvalError.prototype,
        "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array,
        "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype,
        "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array,
        "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype,
        "%Function%": Function,
        "%FunctionPrototype%": Function.prototype,
        "%Generator%": void 0,
        "%GeneratorFunction%": void 0,
        "%GeneratorPrototype%": void 0,
        "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array,
        "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype,
        "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array,
        "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype,
        "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array,
        "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": c ? l(l([][Symbol.iterator]())) : void 0,
        "%JSON%": "object" === ("undefined" == typeof JSON ? "undefined" : n(JSON)) ? JSON : void 0,
        "%JSONParse%": "object" === ("undefined" == typeof JSON ? "undefined" : n(JSON)) ? JSON.parse : void 0,
        "%Map%": "undefined" == typeof Map ? void 0 : Map,
        "%MapIteratorPrototype%": "undefined" != typeof Map && c ? l((new Map)[Symbol.iterator]()) : void 0,
        "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype,
        "%Math%": Math,
        "%Number%": Number,
        "%NumberPrototype%": Number.prototype,
        "%Object%": Object,
        "%ObjectPrototype%": Object.prototype,
        "%ObjProto_toString%": Object.prototype.toString,
        "%ObjProto_valueOf%": Object.prototype.valueOf,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": "undefined" == typeof Promise ? void 0 : Promise,
        "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype,
        "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then,
        "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all,
        "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject,
        "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve,
        "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy,
        "%RangeError%": RangeError,
        "%RangeErrorPrototype%": RangeError.prototype,
        "%ReferenceError%": ReferenceError,
        "%ReferenceErrorPrototype%": ReferenceError.prototype,
        "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect,
        "%RegExp%": RegExp,
        "%RegExpPrototype%": RegExp.prototype,
        "%Set%": "undefined" == typeof Set ? void 0 : Set,
        "%SetIteratorPrototype%": "undefined" != typeof Set && c ? l((new Set)[Symbol.iterator]()) : void 0,
        "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype,
        "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer,
        "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype,
        "%String%": String,
        "%StringIteratorPrototype%": c ? l(""[Symbol.iterator]()) : void 0,
        "%StringPrototype%": String.prototype,
        "%Symbol%": c ? Symbol : void 0,
        "%SymbolPrototype%": c ? Symbol.prototype : void 0,
        "%SyntaxError%": SyntaxError,
        "%SyntaxErrorPrototype%": SyntaxError.prototype,
        "%ThrowTypeError%": s,
        "%TypedArray%": h,
        "%TypedArrayPrototype%": h ? h.prototype : void 0,
        "%TypeError%": i,
        "%TypeErrorPrototype%": i.prototype,
        "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array,
        "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype,
        "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray,
        "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype,
        "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array,
        "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype,
        "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array,
        "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype,
        "%URIError%": URIError,
        "%URIErrorPrototype%": URIError.prototype,
        "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap,
        "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype,
        "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet,
        "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype
    }
      , d = r(16).call(Function.call, String.prototype.replace)
      , f = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
      , m = /\\(\\)?/g;
    e.exports = function(e, t) {
        if ("string" != typeof e || 0 === e.length)
            throw new TypeError("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof t)
            throw new TypeError('"allowMissing" argument must be a boolean');
        for (var r = function(e) {
            var t = [];
            return d(e, f, function(e, r, n, i) {
                t[t.length] = n ? d(i, m, "$1") : r || e
            }),
            t
        }(e), n = function(e, t) {
            if (!(e in p))
                throw new SyntaxError("intrinsic " + e + " does not exist!");
            if (void 0 === p[e] && !t)
                throw new i("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return p[e]
        }("%" + (r.length > 0 ? r[0] : "") + "%", t), a = 1; a < r.length; a += 1)
            if (null != n)
                if (o && a + 1 >= r.length) {
                    var s = o(n, r[a]);
                    n = s ? s.get || s.value : n[r[a]]
                } else
                    n = n[r[a]];
        return n
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(47)();
    e.exports = function(e) {
        return e !== n && null !== e
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(67);
    e.exports = Function.prototype.bind || n
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        return function(e, t) {
            if (Array.isArray(e))
                return e;
            if (Symbol.iterator in Object(e))
                return function(e, t) {
                    var r = []
                      , n = !0
                      , i = !1
                      , o = void 0;
                    try {
                        for (var a, s = e[Symbol.iterator](); !(n = (a = s.next()).done) && (r.push(a.value),
                        !t || r.length !== t); n = !0)
                            ;
                    } catch (e) {
                        i = !0,
                        o = e
                    } finally {
                        try {
                            !n && s.return && s.return()
                        } finally {
                            if (i)
                                throw o
                        }
                    }
                    return r
                }(e, t);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }
    }();
    t.init = function(e) {
        var t = !0
          , r = !1
          , a = void 0;
        try {
            for (var c, w = (0,
            s.getAllShips)().entries()[Symbol.iterator](); !(t = (c = w.next()).done); t = !0) {
                var _ = c.value
                  , M = n(_, 2)
                  , S = M[0]
                  , E = M[1];
                E.object.rotation.x = .2,
                E.object.position.x += S * p,
                E.object.position.z = -50,
                E.isUnlocked() ? E.setActive() : E.setInactive(),
                f.add(E.object),
                d.push(E)
            }
        } catch (e) {
            r = !0,
            a = e
        } finally {
            try {
                !t && w.return && w.return()
            } finally {
                if (r)
                    throw a
            }
        }
        f.position.z = -5,
        e.add(f);
        var T = new i.DirectionalLight(16777215,2);
        T.position.set(0, .5, 1),
        e.add(T);
        var A = new i.HemisphereLight(16777215,6710886,.7);
        e.add(A),
        o.listenToAction(o.actions.LEFT, function() {
            return g(-1)
        }),
        o.listenToAction(o.actions.RIGHT, function() {
            return g(1)
        }),
        o.listenToAction(o.actions.PRIMARY, function() {
            return x()
        }),
        l.addEventListener("click", function() {
            g(-1),
            l.blur()
        }),
        u.addEventListener("click", function() {
            g(1),
            u.blur()
        }),
        h.addEventListener("click", function() {
            return v(!1)
        }),
        b(),
        y(),
        l.setAttribute("disabled", 0 === m),
        u.setAttribute("disabled", m === f.children.length - 1)
    }
    ,
    t.animate = function(e) {
        if (a.gameState !== a.STATE.CONTROL_PANEL && a.gameState !== a.STATE.UNLOCK)
            return;
        var t = !0
          , r = !1
          , n = void 0;
        try {
            for (var i, o = f.children[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                var s = i.value;
                s.rotation.y += .001 * e
            }
        } catch (e) {
            r = !0,
            n = e
        } finally {
            try {
                !t && o.return && o.return()
            } finally {
                if (r)
                    throw n
            }
        }
        if (a.gameState !== a.STATE.CONTROL_PANEL)
            return;
        var l = m * p * -1;
        f.position.x = (0,
        a.lerp)(f.position.x, l, .01 * e);
        var u = d[m]
          , h = void 0;
        u.isUnlocked() ? (h = "SELECT",
        "false" !== c.getAttribute("disabled") && c.setAttribute("disabled", "false")) : (h = "LEVEL " + u.unlockLevel,
        "true" !== c.getAttribute("disabled") && c.setAttribute("disabled", "true"));
        c.innerText != h && (c.innerText = h)
    }
    ,
    t.toggle = v,
    t.toggleUnlock = function(e) {
        var t = d.indexOf(d.find(function(t) {
            return t.id === e
        }));
        if (m = t,
        f.position.x = t * p * -1,
        d[m].isUnlocked())
            return;
        try {
            localStorage.setItem("supernova/ship-unlocked-" + d[m].id, !0)
        } catch (e) {}
        v(!0, !0)
    }
    ,
    t.selectPlayerShip = x;
    var i = r(0)
      , o = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(26))
      , a = r(1)
      , s = r(18);
    r(1);
    var c = document.getElementById("select-ship-button")
      , l = document.getElementById("prev-ship")
      , u = document.getElementById("next-ship")
      , h = document.getElementById("back-button")
      , p = 3
      , d = []
      , f = new i.Group
      , m = 0;
    function v(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (a.gameState !== a.STATE.DYING && a.gameState !== a.STATE.END_SCREEN) {
            if (e)
                return gtag("event", "screen", {
                    event_category: t ? "unlock" : "controlPanel"
                }),
                gtag("event", t ? "openUnlock" : "openControlPanel"),
                (0,
                a.changeGameState)(t ? a.STATE.UNLOCK : a.STATE.CONTROL_PANEL),
                b(),
                void y();
            a.gameState === (t ? a.STATE.UNLOCK : a.STATE.CONTROL_PANEL) ? (0,
            a.changeGameState)(a.prevGameState) : (gtag("event", "screen", {
                event_category: t ? "unlock" : "controlPanel"
            }),
            gtag("event", t ? "openUnlock" : "openControlPanel"),
            (0,
            a.changeGameState)(t ? a.STATE.UNLOCK : a.STATE.CONTROL_PANEL)),
            b(),
            y()
        }
    }
    function g(e) {
        if (a.gameState === a.STATE.CONTROL_PANEL) {
            m = Math.max(0, Math.min(f.children.length - 1, m + e)),
            l.setAttribute("disabled", 0 === m),
            u.setAttribute("disabled", m === f.children.length - 1);
            var t = void 0;
            e > 0 && "true" !== u.getAttribute("disabled") ? t = u : e < 0 && "true" !== l.getAttribute("disabled") && (t = l),
            t && (t.setAttribute("active", !0),
            window.setTimeout(function() {
                t.removeAttribute("active", !0)
            }, 100)),
            y()
        }
    }
    function y() {
        d.forEach(function(e, t) {
            var r = t === m
              , n = .7;
            a.gameState === a.STATE.UNLOCK ? (n = .5,
            e.object.visible = !!r,
            e.setActive()) : (e.object.visible = !0,
            d[t].isUnlocked() ? e.setActive() : e.setInactive()),
            e.object.scale.setScalar(r ? n : .2)
        })
    }
    function b() {
        if (a.gameState !== a.STATE.UNLOCK) {
            var e = d.indexOf(d.find(function(e) {
                return e.id === (0,
                s.getPlayerShip)().id
            }));
            m = e,
            f.position.x = e * p * -1
        }
    }
    function x() {
        a.gameState !== a.STATE.CONTROL_PANEL && a.gameState !== a.STATE.UNLOCK || d[m].isUnlocked() && (gtag("event", "selectedShip", {
            event_category: d[m].name
        }),
        (0,
        s.setPlayerShip)(d[m].id),
        v(!1))
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.getPlayerShip = t.init = t.setPlayerShip = t.getAllShips = void 0;
    var n = r(1)
      , i = h(r(100))
      , o = h(r(103))
      , a = h(r(102))
      , s = h(r(99))
      , c = h(r(98))
      , l = h(r(101))
      , u = h(r(97));
    function h(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var p = void 0
      , d = []
      , f = [];
    t.getAllShips = function() {
        return f
    }
    ,
    t.setPlayerShip = function(e) {
        try {
            localStorage.setItem("supernova/player_ship", e)
        } catch (e) {}
        return p = d.find(function(t) {
            return t.id === e
        }),
        (0,
        n.changePlayerShip)(p),
        p
    }
    ,
    t.init = function() {
        f.push((0,
        i.default)(), (0,
        o.default)(), (0,
        a.default)(), (0,
        s.default)(), (0,
        c.default)(), (0,
        u.default)(), (0,
        l.default)()),
        f = f.sort(function(e, t) {
            return e.unlockLevel - t.unlockLevel
        }),
        d.push.apply(d, function(e) {
            if (Array.isArray(e)) {
                for (var t = 0, r = Array(e.length); t < e.length; t++)
                    r[t] = e[t];
                return r
            }
            return Array.from(e)
        }(f.map(function(e) {
            var t = e.clone();
            return t.object.castShadow = !0,
            t.object.scale.set(.35, .35, .35),
            t.object.position.z = .5 * -t.object.geometry.boundingBox.max.z,
            t
        })))
    }
    ,
    t.getPlayerShip = function() {
        if (!p)
            try {
                p = d.find(function(e) {
                    return e.id === localStorage.getItem("supernova/player_ship")
                }) || d[0]
            } catch (e) {
                p = d[0]
            }
        return p
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.calculate = function() {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        }
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = function() {
        var e = !1;
        return function(t) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0)
        }(navigator.userAgent || navigator.vendor || window.opera),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    var n = r(60);
    e.exports = function(e) {
        if (!n(e))
            throw new TypeError(e + " is not a symbol");
        return e
    }
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
      , i = Object.prototype.toString;
    e.exports = function(e) {
        var t = i.call(e)
          , r = "[object Arguments]" === t;
        return r || (r = "[object Array]" !== t && null !== e && "object" === (void 0 === e ? "undefined" : n(e)) && "number" == typeof e.length && e.length >= 0 && "[object Function]" === i.call(e.callee)),
        r
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(76)
      , i = r(78)
      , o = r(81)
      , a = r(80)
      , s = r(79)
      , c = r(77)
      , l = r(82);
    l.alea = n,
    l.xor128 = i,
    l.xorwow = o,
    l.xorshift7 = a,
    l.xor4096 = s,
    l.tychei = c,
    e.exports = l
}
, function(e, t, r) {
    "use strict";
    e.exports = function(e) {
        return void 0 !== e && null !== e
    }
}
, function(e, t, r) {
    "use strict";
    var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    n = function() {
        return this
    }();
    try {
        n = n || Function("return this")() || (0,
        eval)("this")
    } catch (e) {
        "object" === ("undefined" == typeof window ? "undefined" : i(window)) && (n = window)
    }
    e.exports = n
}
, function(e, t, r) {
    "use strict";
    var n;
    function i(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r,
        e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.checkForInput = function(e) {
        return a[e]
    }
    ,
    t.register = function() {
        window.addEventListener("keydown", h),
        window.addEventListener("keyup", p),
        window.addEventListener("touchstart", d),
        window.addEventListener("touchmove", d),
        window.addEventListener("touchend", f)
    }
    ,
    t.listenToAction = function(e, t) {
        l[e] = [].concat(function(e) {
            if (Array.isArray(e)) {
                for (var t = 0, r = Array(e.length); t < e.length; t++)
                    r[t] = e[t];
                return r
            }
            return Array.from(e)
        }(l[e] || []), [t])
    }
    ;
    var o = t.actions = {
        PRIMARY: 1,
        SECONDARY: 2,
        LEFT: 3,
        RIGHT: 4,
        UP: 5,
        DOWN: 6,
        DEBUG: 7,
        TOUCH: 8,
        PAUSE: 9,
        EXIT: 10
    }
      , a = (t.isTouching = !1,
    {});
    Object.keys(o).forEach(function(e) {
        return a[e] = !1
    }),
    Object.keys(o).forEach(function(e) {
        return a[e] = []
    });
    var s = (i(n = {}, o.PRIMARY, [13, 32, 90]),
    i(n, o.SECONDARY, [88]),
    i(n, o.LEFT, [37, 65]),
    i(n, o.RIGHT, [39, 68]),
    i(n, o.UP, [38, 87]),
    i(n, o.DOWN, [40, 83]),
    i(n, o.DEBUG, [84]),
    i(n, o.PAUSE, [80]),
    i(n, o.EXIT, [27]),
    n)
      , c = {};
    Object.keys(s).forEach(function(e) {
        s[e].forEach(function(t) {
            c[t] = e
        })
    });
    var l = {};
    function u(e, t) {
        (l[e] || []).forEach(function(e) {
            return e(t)
        })
    }
    function h(e) {
        var t = c[e.keyCode];
        void 0 !== t && (a[t] || u(t, e),
        a[t] = !0)
    }
    function p(e) {
        var t = c[e.keyCode];
        a[t] = !1
    }
    function d(e) {
        e.target.className && e.target.className.includes && !e.target.className.includes("button") && e.preventDefault();
        var r = e.touches[0];
        t.isTouching = {
            x: r.pageX,
            y: r.pageY
        },
        a[o.TOUCH] || u(o.TOUCH, e)
    }
    function f(e) {
        t.isTouching = !1
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.generateLevels = void 0;
    var n = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(23));
    function i(e) {
        if (Array.isArray(e)) {
            for (var t = 0, r = Array(e.length); t < e.length; t++)
                r[t] = e[t];
            return r
        }
        return Array.from(e)
    }
    var o = {
        basicTwoSuperEasy: [{
            type: "basic",
            rotation: 1 * Math.PI / 2
        }, {
            type: "basic",
            rotation: 1 * Math.PI / 2
        }],
        basicFourPrettyEasy: [{
            type: "basic",
            rotation: 1 * Math.PI / 2
        }, {
            type: "basic",
            rotation: 1 * Math.PI / 2
        }, {
            type: "basic",
            rotation: 0
        }, {
            type: "basic",
            rotation: 0
        }],
        basicFourAlternate: [{
            type: "basic",
            rotation: 0
        }, {
            type: "basic",
            rotation: 1 * Math.PI / 2
        }, {
            type: "basic",
            rotation: 0
        }, {
            type: "basic",
            rotation: 1 * Math.PI / 2
        }],
        basicFourIncrease: [{
            type: "basic",
            amount: 4,
            rotation: "increase",
            rotationModifier: -1.5
        }],
        basicFourDecrease: [{
            type: "basic",
            amount: 4,
            rotation: "increase",
            rotationModifier: 1.5
        }],
        cylinderCorridor: [{
            type: "cylinderCorridor",
            amount: 5
        }],
        cylinderCorridorAlternate: [{
            type: "cylinderCorridor",
            amount: 5,
            rotation: 1 * Math.PI / 3
        }],
        cylinderCorridorLong: [{
            type: "cylinderCorridor",
            amount: 10
        }],
        cylinderCorridorAlternateLong: [{
            type: "cylinderCorridor",
            amount: 10,
            rotation: 1 * Math.PI / 3
        }],
        cylinderCorridorShort: [{
            type: "cylinderCorridor",
            amount: 2,
            rotation: "increaseAsSegment",
            repeat: 5
        }],
        risers: [{
            type: "risers",
            amount: 15
        }],
        risersAlternate: [{
            type: "risers",
            amount: 15,
            rotation: 1 * Math.PI / 3
        }],
        risersSine: [{
            type: "risers",
            amount: 20,
            rotation: "increase",
            rotationModifier: 1,
            obstacleInterval: 20,
            nextSegmentBuffer: 20
        }, {
            type: "risers",
            amount: 20,
            rotation: "increase",
            rotationModifier: -1,
            obstacleInterval: 20
        }],
        tripleGapAlternate: [{
            type: "tripleGap",
            rotation: 0
        }, {
            type: "tripleGap",
            rotation: 1 * Math.PI / 3
        }, {
            type: "tripleGap",
            rotation: 2 * Math.PI / 3
        }, {
            type: "tripleGap",
            rotation: Math.PI
        }],
        tripleGapIncrease: [{
            type: "tripleGap",
            amount: 8,
            rotation: "increase",
            rotationModifier: -1.5
        }],
        tripleGapDecrease: [{
            type: "tripleGap",
            amount: 8,
            rotation: "increase",
            rotationModifier: 1.5
        }],
        fansRandom: [{
            type: "fan",
            amount: 3,
            rotation: "random",
            obstacleInterval: 150,
            nextSegmentBuffer: 150
        }],
        fansInverseRandom: [{
            type: "fan",
            amount: 3,
            obstacleInterval: 150,
            nextSegmentBuffer: 150,
            data: {
                type: "inverse"
            }
        }],
        spinnerSingle: [{
            type: "spinner",
            amount: 1,
            rotation: 0
        }],
        spinnerThree: [{
            type: "spinner",
            amount: 3,
            rotation: "increase"
        }]
    }
      , a = Object.values(o)
      , s = []
      , c = (t.generateLevels = function() {
        s.push({
            segmentBuffer: 150,
            segments: [].concat(i(o.basicTwoSuperEasy))
        }),
        s.push({
            segmentBuffer: 150,
            segments: [].concat(i(o.basicFourPrettyEasy))
        }),
        s.push({
            segmentBuffer: 150,
            segments: [].concat(i(o.basicFourAlternate))
        }),
        s.push({
            segmentBuffer: 125,
            segments: [].concat(i(o.basicFourAlternate), i(o.basicFourAlternate))
        }),
        s.push({
            segmentBuffer: 75,
            segments: [].concat(i(o.basicFourAlternate), i(o.basicFourAlternate))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.basicFourIncrease))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.basicFourIncrease), i(o.basicFourDecrease))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.cylinderCorridor), i(o.cylinderCorridor), i(o.cylinderCorridor), i(o.cylinderCorridor))
        }),
        s.push({
            segmentBuffer: 75,
            segments: [].concat(i(o.cylinderCorridor), i(o.cylinderCorridorAlternateLong), i(o.cylinderCorridor), i(o.cylinderCorridorAlternateLong))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.cylinderCorridorLong), i(o.basicFourAlternate), i(o.cylinderCorridorLong), i(o.basicFourAlternate), i(o.basicFourIncrease))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.cylinderCorridorLong), i(o.basicFourAlternate), i(o.cylinderCorridorLong), i(o.basicFourAlternate), i(o.basicFourIncrease))
        }),
        s.push({
            segmentBuffer: 75,
            segments: [].concat(i(o.cylinderCorridorShort), i(o.cylinderCorridorLong), i(o.cylinderCorridorShort))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.risers), i(o.risers))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.risers), i(o.risersAlternate), i(o.risers), i(o.risersAlternate), i(o.risers))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.basicFourAlternate), i(o.risers), i(o.basicFourAlternate), i(o.risers), i(o.basicFourAlternate))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.cylinderCorridorLong), i(o.risers), i(o.cylinderCorridorShort), i(o.risers), i(o.cylinderCorridorShort), i(o.risers), i(o.cylinderCorridorLong))
        }),
        s.push({
            segmentBuffer: 75,
            segments: [].concat(i(o.basicFourIncrease), i(o.risersSine), i(o.basicFourDecrease))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.tripleGapAlternate), i(o.tripleGapAlternate))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.tripleGapIncrease), i(o.tripleGapAlternate), i(o.tripleGapDecrease))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.risers), i(o.tripleGapAlternate), i(o.cylinderCorridorLong), i(o.cylinderCorridorShort), i(o.cylinderCorridorLong), i(o.tripleGapAlternate), i(o.risers))
        }),
        s.push({
            segmentBuffer: 90,
            segments: [].concat(i(o.basicFourAlternate), i(o.basicFourIncrease), i(o.basicFourDecrease), i(o.risers), i(o.cylinderCorridorLong), i(o.basicFourAlternate), i(o.tripleGapAlternate), i(o.risers))
        }),
        s.push({
            segmentBuffer: 80,
            segments: [].concat(i(o.risers), i(o.risersAlternate), i(o.risersSine), i(o.tripleGapIncrease), i(o.tripleGapDecrease), i(o.cylinderCorridorShort), i(o.basicFourAlternate), i(o.tripleGapAlternate), i(o.cylinderCorridorLong))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.fansRandom), i(o.fansRandom), i(o.fansRandom))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.fansInverseRandom), i(o.fansInverseRandom), i(o.fansInverseRandom))
        }),
        s.push({
            segmentBuffer: 75,
            segments: [].concat(i(o.fansRandom), i(o.fansInverseRandom), i(o.fansRandom), i(o.fansInverseRandom), i(o.fansRandom))
        }),
        s.push({
            segmentBuffer: 75,
            segments: [].concat(i(o.cylinderCorridorShort), i(o.fansRandom), i(o.risers), i(o.tripleGapAlternate), i(o.risers), i(o.fansRandom), i(o.cylinderCorridorLong))
        }),
        s.push({
            segmentBuffer: 75,
            segments: [].concat(i(o.fansInverseRandom), i(o.cylinderCorridorLong), i(o.fansRandom), i(o.basicFourAlternate), i(o.tripleGapAlternate), i(o.basicFourAlternate), i(o.fansRandom), i(o.cylinderCorridorShort), i(o.fansInverseRandom))
        }),
        s.push({
            segments: [{
                type: "risers",
                amount: 15,
                rotation: "increase",
                rotationModifier: 1,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                amount: 15,
                rotation: "increase",
                rotationModifier: -1,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                amount: 40,
                rotation: "increase",
                rotationModifier: 1,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                amount: 15,
                rotation: "increase",
                rotationModifier: -1,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                amount: 10,
                rotation: "increase",
                rotationModifier: 1,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                amount: 10,
                rotation: "increase",
                rotationModifier: -1,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                amount: 5,
                rotation: "increase",
                rotationModifier: 1,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                rotation: "last",
                amount: 10,
                obstacleInterval: 20,
                nextSegmentBuffer: 20
            }, {
                type: "risers",
                rotation: "last",
                amount: 5,
                obstacleInterval: 35,
                nextSegmentBuffer: 35
            }, {
                type: "risers",
                rotation: "last",
                amount: 5,
                obstacleInterval: 50,
                nextSegmentBuffer: 150
            }]
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.fansRandom), i(o.basicFourAlternate), i(o.spinnerSingle), i(o.basicFourAlternate), i(o.fansRandom))
        }),
        s.push({
            segmentBuffer: 100,
            segments: [].concat(i(o.spinnerSingle), i(o.cylinderCorridor), i(o.spinnerThree), i(o.cylinderCorridor), i(o.spinnerSingle))
        }),
        s.push({
            segmentBuffer: 80,
            segments: [].concat(i(o.tripleGapAlternate), i(o.spinnerThree), i(o.risersSine), i(o.spinnerSingle), i(o.risersSine), i(o.spinnerThree), i(o.tripleGapAlternate))
        })
    }
    ,
    function(e, t, r) {
        return Math.floor(e * (r - t + 1) + t)
    }
    );
    t.default = {
        levels: s,
        worlds: [{
            hueModifier: .75,
            saturationModifier: 1,
            brightnessModifier: .25,
            sine: .2,
            rotationOffset: 0,
            particleColor: 16777215
        }, {
            geometry: "six",
            hueModifier: .4,
            saturationModifier: 1,
            brightnessModifier: .2,
            scaleX: .8,
            scaleY: .8,
            sine: .4,
            rotationOffset: Math.PI,
            particleColor: 2254472,
            timeModifier: -.7,
            sineZModifier: .9
        }, {
            geometry: "four",
            hueModifier: .01,
            saturationModifier: 1,
            brightnessModifier: .2,
            sine: .2,
            rotationOffset: 0,
            particleColor: 16777215,
            scaleX: 1.5,
            scaleY: 1.2
        }, {
            geometry: "twelve",
            hueModifier: .6,
            saturationModifier: 1,
            brightnessModifier: .2,
            sine: .2,
            rotationOffset: Math.PI,
            particleColor: 16777215,
            scaleY: 8,
            scaleX: 1,
            timeModifier: .8
        }, {
            geometry: "six",
            hueModifier: .85,
            saturationModifier: 1,
            brightnessModifier: .1,
            scaleX: 1.5,
            scaleY: 1.5,
            sine: .3,
            rotationOffset: 0,
            particleColor: 2236962,
            timeModifier: .5
        }, {
            geometry: "six",
            hueModifier: .75,
            saturationModifier: 0,
            brightnessModifier: .6,
            scaleX: 3.5,
            scaleY: 3.5,
            sine: .3,
            rotationOffset: 0,
            particleColor: 2236962
        }],
        getLevelByIdx: function(e) {
            if (!this.levels[e]) {
                var t = (0,
                n.default)("level-" + e)
                  , r = function(e, t) {
                    return function(r) {
                        var n = e < 50
                          , o = [];
                        return r.forEach(function(t) {
                            t.minLevel && t.minLevel > e || o.push.apply(o, i(Array(n ? t.experiencedPlayer : t.fanPlayer).fill(t.data)))
                        }),
                        o[Math.floor(t() * o.length)]
                    }
                }(e, t)
                  , o = r([{
                    data: 100,
                    experiencedPlayer: 3,
                    fanPlayer: 1
                }, {
                    data: 75,
                    experiencedPlayer: 5,
                    fanPlayer: 3
                }])
                  , s = r([{
                    data: 5,
                    experiencedPlayer: 1,
                    fanPlayer: 1
                }, {
                    data: 10,
                    experiencedPlayer: 1,
                    fanPlayer: 5
                }])
                  , c = [];
                Array(s).fill(0).forEach(function() {
                    c.push.apply(c, i(a[Math.floor(t() * a.length)]))
                });
                var l = {
                    segmentBuffer: o,
                    segments: c
                };
                this.levels[e] = l
            }
            return e < 25 ? this.levels[e].segmentBuffer = Math.max(150, this.levels[e].segmentBuffer) : e < 40 && (this.levels[e].segmentBuffer = Math.max(125, this.levels[e].segmentBuffer)),
            this.levels[e]
        },
        getWorldByIdx: function(e) {
            if (!this.worlds[e]) {
                var t = (0,
                n.default)("world-" + e)
                  , r = ["six", "twelve", "six", "twelve", "four", "twelve", "twelve"]
                  , i = t()
                  , o = [0, .1, .15]
                  , a = [.8, .8, .8, .9, .9, .9, .9, .9, .9, .9, .9, .9, .9, .9, .9, .9, .9]
                  , s = [.2, .3, .3, .3, .4, .4, .4]
                  , l = [.5, .8, .7]
                  , u = [.4, .75, .4, .85, .6, .01]
                  , h = [2254472, 16777215, 2236962]
                  , p = h[Math.floor(t() * h.length)]
                  , d = r[e % r.length]
                  , f = t() < .05;
                this.worlds[e] = {
                    geometry: d,
                    hueModifier: u[e % u.length],
                    saturationModifier: a[Math.floor(t() * a.length)],
                    brightnessModifier: o[Math.floor(t() * o.length)],
                    scaleX: c(i, "four" === d ? 1.2 : .8, 1.3),
                    scaleY: f ? 6 : c(i, "four" === d ? 1.2 : .8, 1.3),
                    sine: f ? .2 : s[Math.floor(t() * s.length)],
                    rotationOffset: t() > .7 ? 0 : Math.PI,
                    particleColor: p,
                    timeModifier: l[Math.floor(t() * l.length)],
                    sineZModifier: c(t, .9, 1.05)
                }
            }
            return this.worlds[e]
        }
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }();
    t.default = function() {
        var e = a.get("basicObstacle");
        e || (e = new s);
        return e.object.visible = !0,
        e
    }
    ;
    var i = r(0)
      , o = r(1)
      , a = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(9));
    var s = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            o.gameStarted && console.warn("⚠️ Creating BasicObstacle in-game!");
            var t = new i.Group
              , r = (0,
            o.createTorus)(12, 4, 8, 3.75, .5 * Math.PI)
              , n = (0,
            o.createTorus)(12, 4, 8, 3.75, .5 * Math.PI);
            n.geometry.rotateZ(Math.PI),
            r.geometry.merge(n.geometry);
            var a = (0,
            o.createTorus)(5, 2, 4, 3.75, .5 * Math.PI)
              , s = (0,
            o.createTorus)(5, 2, 4, 3.75, .5 * Math.PI);
            s.geometry.rotateZ(Math.PI),
            a.geometry.merge(s.geometry),
            a.material = o.darkMaterial,
            t.add(r),
            t.add(a),
            this.object = t
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.object.visible = !1,
                this.object.position.setScalar(0),
                this.object.rotation.set(0, 0, 0),
                this.object.scale.setScalar(1),
                a.pool("basicObstacle", this)
            }
        }]),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }();
    t.default = function() {
        var e = a.get("cylinderRow");
        e || (e = new s);
        return e.object.visible = !0,
        e
    }
    ;
    var i = r(0)
      , o = r(1)
      , a = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(9));
    var s = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            o.gameStarted && console.warn("⚠️ Creating CylinderRow in-game!");
            for (var t = new i.Group, r = 0; r < 3; r++) {
                var n = (0,
                o.createCylinder)(2, 10, 8);
                n.position.y = 4,
                n.rotation.z = 2 * Math.PI + 2 * Math.PI / 3 * r;
                var a = (0,
                o.rotatePoint)(n.position, {
                    x: 0,
                    y: 0
                }, n.rotation.z);
                n.position.x = a.x,
                n.position.y = a.y,
                t.add(n)
            }
            this.object = t
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.object.visible = !1,
                this.object.position.setScalar(0),
                this.object.rotation.set(0, 0, 0),
                this.object.scale.setScalar(1),
                a.pool("cylinderRow", this)
            }
        }]),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }();
    t.default = function(e) {
        var t = a.get("fan");
        t || (t = new s);
        return t.type = e,
        t.object.visible = !0,
        t
    }
    ;
    var i = r(0)
      , o = r(1)
      , a = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(9));
    var s = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            o.gameStarted && console.warn("⚠️ Creating Fan in-game!");
            var t = new i.Group;
            this.partOne = (0,
            o.createBox)(2.5, 19.5, 44.5, 1, 1, 3);
            var r = (0,
            o.createBox)(2.5, 25, 2.5, 1, 1, 3)
              , n = (0,
            o.createBox)(2.5, 25, 2.5, 1, 1, 3)
              , a = (0,
            o.createBox)(2.5, 2.5, 50, 1, 1, 3)
              , s = (0,
            o.createBox)(2.5, 2.5, 50, 1, 1, 3);
            r.geometry.translate(0, 0, -23.75),
            n.geometry.translate(0, 0, 23.75),
            a.geometry.translate(0, 12.5, 0),
            s.geometry.translate(0, -12.5, 0),
            r.geometry.merge(n.geometry),
            r.geometry.merge(a.geometry),
            r.geometry.merge(s.geometry),
            this.partTwo = r,
            this.partOne.material = o.basicMaterial,
            this.partTwo.material = o.darkMaterial,
            t.add(this.partOne),
            t.add(this.partTwo),
            this.object = t
        }
        return n(e, [{
            key: "update",
            value: function(e) {
                this.object.visible && ("double" === this.type ? (this.partOne.rotation.z += .001 * e,
                this.partTwo.rotation.z -= .001 * e) : "inverse" === this.type ? this.partTwo.rotation.z -= .002 * e : this.partOne.rotation.z += .002 * e)
            }
        }, {
            key: "pool",
            value: function() {
                this.object.visible = !1,
                this.object.position.setScalar(0),
                this.object.rotation.set(0, 0, 0),
                this.object.scale.setScalar(1),
                this.partOne.rotation.z = 0,
                this.partTwo.rotation.z = 0,
                a.pool("fan", this)
            }
        }]),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = Object.assign || function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t];
            for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
        }
        return e
    }
      , i = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }();
    t.default = function() {
        var e = s.get("riserRow");
        e || (e = new l);
        return e.object.visible = !0,
        e
    }
    ;
    var o = r(0)
      , a = r(1)
      , s = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(9));
    var c = new o.Vector3(0,12,0)
      , l = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            a.gameStarted && console.warn("⚠️ Creating RiserRow in-game!");
            for (var t = new o.Group, r = 0; r < 6; r++) {
                var n = new o.BoxGeometry(4,10,10)
                  , i = r % 2 == 0 ? a.darkMaterial : a.basicMaterial
                  , s = new o.Mesh(n,i);
                s.position.copy(c),
                s.rotation.z = 2 * Math.PI + 2 * Math.PI / 6 * r;
                var l = (0,
                a.rotatePoint)(s.position, {
                    x: 0,
                    y: 0
                }, s.rotation.z);
                s.position.x = l.x,
                s.position.y = l.y,
                t.add(s)
            }
            this.object = t,
            this.totalDistanceMoved = 0
        }
        return i(e, [{
            key: "distanceMoved",
            value: function(e) {
                var t = this;
                this.totalDistanceMoved += e,
                this.object.children.forEach(function(e, r) {
                    var i = r % 2 == 0 ? 1 : -1
                      , o = (0,
                    a.rotatePoint)(n({}, c, {
                        y: c.y + 6.3 * Math.sin(.03 * (t.totalDistanceMoved - 30)) * i
                    }), {
                        x: 0,
                        y: 0
                    }, e.rotation.z);
                    e.position.copy(n({}, o, {
                        z: 0
                    }))
                })
            }
        }, {
            key: "pool",
            value: function() {
                this.totalDistanceMoved = 0,
                this.object.visible = !1,
                this.object.position.setScalar(0),
                this.object.rotation.set(0, 0, 0),
                this.object.scale.setScalar(1),
                s.pool("riserRow", this)
            }
        }]),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }();
    t.default = function() {
        var e = a.get("spinner");
        e || (e = new s);
        return e.object.visible = !0,
        e
    }
    ;
    var i = r(0)
      , o = r(1)
      , a = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(9));
    var s = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            o.gameStarted && console.warn("⚠️ Creating spinner in-game!");
            var t = new i.Group;
            this.torusOne = (0,
            o.createTorus)(15, 2.5, 8, 15, 2 * Math.PI);
            for (var r = 0; r < 4; r++) {
                for (var n = new i.BoxGeometry(1,10,2), a = 0; a < 6; a++) {
                    var s = n.vertices[a];
                    a < 2 && (s.x += 4),
                    a > 3 && (s.x -= 4)
                }
                var c = 2 * Math.PI + 2 * Math.PI / 4 * r;
                n.rotateZ(c);
                var l = (0,
                o.rotatePoint)({
                    x: 0,
                    y: 8
                }, {
                    x: 0,
                    y: 0
                }, c);
                n.translate(l.x, l.y, 0),
                this.boxes ? this.boxes.geometry.merge(n) : this.boxes = new i.Mesh(n,o.darkMaterial)
            }
            t.add(this.torusOne),
            t.add(this.boxes),
            this.object = t
        }
        return n(e, [{
            key: "move",
            value: function(e, t) {
                this.object.rotation.z -= .0015 * e * t
            }
        }, {
            key: "pool",
            value: function() {
                this.object.visible = !1,
                this.object.position.setScalar(0),
                this.object.rotation.set(0, 0, 0),
                this.object.scale.setScalar(1),
                a.pool("spinner", this)
            }
        }]),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }();
    t.default = function() {
        var e = a.get("tripleGap");
        e || (e = new c);
        return e.object.visible = !0,
        e
    }
    ;
    var i = r(0)
      , o = r(1)
      , a = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(9))
      , s = r(1);
    var c = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            o.gameStarted && console.warn("⚠️ Creating TripleGap in-game!");
            var t = new i.Group
              , r = (0,
            o.createTorus)(7, 4, 4, 15 * (1 - .85), Math.PI * (2 - 1.7))
              , n = (0,
            o.createTorus)(7, 4, 4, 15 * (1 - .85), Math.PI * (2 - 1.7))
              , a = (0,
            o.createTorus)(7, 4, 4, 15 * (1 - .85), Math.PI * (2 - 1.7));
            n.geometry.rotateZ(2 * Math.PI / 3),
            a.geometry.rotateZ(4 * Math.PI / 3),
            r.geometry.merge(n.geometry),
            r.geometry.merge(a.geometry);
            var c = (0,
            o.createTorus)(10, 2, 4, 10 * (1 - .85), Math.PI * (2 - 1.7) / 2)
              , l = (0,
            o.createTorus)(10, 2, 4, 10 * (1 - .85), Math.PI * (2 - 1.7) / 2)
              , u = (0,
            o.createTorus)(10, 2, 4, 10 * (1 - .85), Math.PI * (2 - 1.7) / 2);
            c.geometry.rotateZ(.2 * Math.PI / 3),
            l.geometry.rotateZ(2.2 * Math.PI / 3),
            u.geometry.rotateZ(4.2 * Math.PI / 3),
            c.geometry.merge(l.geometry),
            c.geometry.merge(u.geometry),
            c.material = s.darkMaterial,
            t.add(r),
            t.add(c),
            this.object = t
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.object.visible = !1,
                this.object.position.setScalar(0),
                this.object.rotation.set(0, 0, 0),
                this.object.scale.setScalar(1),
                a.pool("tripleGap", this)
            }
        }]),
        e
    }()
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = l(r(91))
      , i = l(r(92))
      , o = l(r(94))
      , a = l(r(95))
      , s = l(r(93))
      , c = l(r(96));
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    t.default = {
        basic: n.default,
        cylinderCorridor: i.default,
        risers: o.default,
        spinner: a.default,
        fan: s.default,
        tripleGap: c.default
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = [];
    t.applyDistortion = function(e) {
        e.onBeforeCompile = function(e) {
            e.uniforms.time = {
                value: 0
            },
            e.vertexShader = "uniform float time;\n" + e.vertexShader,
            e.vertexShader = e.vertexShader.replace("#include <project_vertex>", "\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n\t\t\tfloat maxOffLen = 0.1;\n\t\t\tvec2 p = uv * vec2(PI*2.0);\n\n\t\t\tvec3 offset = normalize(normal) * vec3(sin((time / 150.0) + p.y ) * maxOffLen - maxOffLen);\n\n\t\t\tmvPosition.x += offset.x;\n\t\t\tmvPosition.y += offset.y;\n\t\t\tmvPosition.z += offset.z;\n\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t"),
            n.push(e)
        }
    }
    ,
    t.applyBubble = function(e) {}
    ,
    t.setTime = function(e) {
        var t = !0
          , r = !1
          , i = void 0;
        try {
            for (var o, a = n[Symbol.iterator](); !(t = (o = a.next()).done); t = !0) {
                o.value.uniforms.time = {
                    value: e
                }
            }
        } catch (e) {
            r = !0,
            i = e
        } finally {
            try {
                !t && a.return && a.return()
            } finally {
                if (r)
                    throw i
            }
        }
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = []
      , i = Math.random() > .5 ? -1 : 1
      , o = Math.random() > .5 ? -1 : 1;
    t.applyBend = function(e) {
        e.onBeforeCompile = function(e) {
            e.uniforms.distance = {
                value: 0
            },
            e.vertexShader = "uniform float distance;\n" + e.vertexShader,
            e.vertexShader = e.vertexShader.replace("#include <project_vertex>", "\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n\t\t\tfloat adjustedDistance = distance / 1500.0;\n\t\t\tfloat sine = sin(1.0 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(1.5 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(0.2 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(0.01 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(3.0 * " + Math.PI + " * adjustedDistance)\n\t\t\t;\n\n\t\t\tfloat sineY = sin(1.2 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(1.1 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(0.3 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(0.02 * " + Math.PI + " * adjustedDistance)\n\t\t\t + sin(2.4 * " + Math.PI + " * adjustedDistance)\n\t\t\t;\n\n\t\t\tfloat sineXModifier = 1500.0;\n\t\t\tfloat sineYModifier = 2500.0;\n\n\t\t\t// Exponential\n\t\t\tmvPosition.x = mvPosition.x + ((mvPosition.z * mvPosition.z) * sine / sineXModifier) * " + i + ".0;\n\t\t\tmvPosition.y = mvPosition.y + ((mvPosition.z * mvPosition.z) * sineY / sineYModifier) * " + o + ".0 + (mvPosition.z * mvPosition.z * 0.0008);\n\n\t\t\t// mvPosition.y = mvPosition.y + (mvPosition.z * mvPosition.z) * 0.0005;\n\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t"),
            n.push(e)
        }
    }
    ,
    t.setDistanceTraveled = function(e) {
        var t = !0
          , r = !1
          , i = void 0;
        try {
            for (var o, a = n[Symbol.iterator](); !(t = (o = a.next()).done); t = !0) {
                o.value.uniforms.distance = {
                    value: e
                }
            }
        } catch (e) {
            r = !0,
            i = e
        } finally {
            try {
                !t && a.return && a.return()
            } finally {
                if (r)
                    throw i
            }
        }
    }
}
, function(e, t, r) {
    "use strict";
    r(41)
}
, function(e, t, r) {
    "use strict";
    r(59)() || Object.defineProperty(r(12), "Symbol", {
        value: r(64),
        configurable: !0,
        enumerable: !1,
        writable: !0
    })
}
, function(e, t, r) {
    "use strict";
    (function(t) {
        var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        ;
        !function(e, n) {
            if (!(n in e)) {
                var i, o = (void 0 === t ? "undefined" : r(t)) === (void 0 === o ? "undefined" : r(o)) ? window : t, a = 0, s = "" + Math.random(), c = "__symbol:", l = c.length, u = "__symbol@@" + s, h = "defineProperty", p = "defineProperties", d = "getOwnPropertyNames", f = "getOwnPropertyDescriptor", m = "propertyIsEnumerable", v = e[d], g = e[f], y = e.create, b = e.keys, x = e.freeze || e, w = e[h], _ = e[p], M = g(e, d), S = e.prototype, E = S.hasOwnProperty, T = S[m], A = S.toString, L = function(e, t, r) {
                    E.call(e, u) || w(e, u, {
                        enumerable: !1,
                        configurable: !1,
                        writable: !1,
                        value: {}
                    }),
                    e[u]["@@" + t] = r
                }, P = function() {}, C = function(e) {
                    return e != u && !E.call(D, e)
                }, R = function(e) {
                    return e != u && E.call(D, e)
                }, O = function(e) {
                    var t = "" + e;
                    return R(t) ? E.call(this, t) && this[u]["@@" + t] : T.call(this, e)
                }, I = function(t) {
                    return w(S, t, {
                        enumerable: !1,
                        configurable: !0,
                        get: P,
                        set: function(e) {
                            i(this, t, {
                                enumerable: !1,
                                configurable: !0,
                                writable: !0,
                                value: e
                            }),
                            L(this, t, !0)
                        }
                    }),
                    x(D[t] = w(e(t), "constructor", B))
                }, N = function e(t) {
                    if (this instanceof e)
                        throw new TypeError("Symbol is not a constructor");
                    return I(c.concat(t || "", s, ++a))
                }, D = y(null), B = {
                    value: N
                }, z = function(e) {
                    return D[e]
                }, G = function(e, t, r) {
                    var n = "" + t;
                    return R(n) ? (i(e, n, r.enumerable ? function(e) {
                        var t = y(e);
                        return t.enumerable = !1,
                        t
                    }(r) : r),
                    L(e, n, !!r.enumerable)) : w(e, t, r),
                    e
                }, U = function(e) {
                    return v(e).filter(R).map(z)
                };
                M.value = G,
                w(e, h, M),
                M.value = U,
                w(e, n, M),
                M.value = function(e) {
                    return v(e).filter(C)
                }
                ,
                w(e, d, M),
                M.value = function(e, t) {
                    var r = U(t);
                    return r.length ? b(t).concat(r).forEach(function(r) {
                        O.call(t, r) && G(e, r, t[r])
                    }) : _(e, t),
                    e
                }
                ,
                w(e, p, M),
                M.value = O,
                w(S, m, M),
                M.value = N,
                w(o, "Symbol", M),
                M.value = function(e) {
                    var t = c.concat(c, e, s);
                    return t in S ? D[t] : I(t)
                }
                ,
                w(N, "for", M),
                M.value = function(e) {
                    if (C(e))
                        throw new TypeError(e + " is not a symbol");
                    if (E.call(D, e)) {
                        var t = e.slice(l);
                        if (t.slice(0, l) === c && (t = t.slice(l)) !== s)
                            return (t = t.slice(0, t.length - s.length)).length > 0 ? t : void 0
                    }
                }
                ,
                w(N, "keyFor", M),
                M.value = function(e, t) {
                    var r = g(e, t);
                    return r && R(t) && (r.enumerable = O.call(e, t)),
                    r
                }
                ,
                w(e, f, M),
                M.value = function(e, t) {
                    return 1 === arguments.length || void 0 === t ? y(e) : function(e, t) {
                        var r = y(e);
                        return v(t).forEach(function(e) {
                            O.call(t, e) && G(r, e, t[e])
                        }),
                        r
                    }(e, t)
                }
                ,
                w(e, "create", M),
                M.value = function() {
                    var e = A.call(this);
                    return "[object String]" === e && R(this) ? "[object Symbol]" : e
                }
                ,
                w(S, "toString", M);
                try {
                    if (!0 !== y(w({}, c, {
                        get: function() {
                            return w(this, c, {
                                value: !0
                            })[c]
                        }
                    }))[c])
                        throw "IE11";
                    i = w
                } catch (e) {
                    i = function(e, t, r) {
                        var n = g(S, t);
                        delete S[t],
                        w(e, t, r),
                        w(S, t, n)
                    }
                }
            }
        }(Object, "getOwnPropertySymbols"),
        function(e, t) {
            var r, n = e.defineProperty, i = e.prototype, o = i.toString, a = "toStringTag";
            ["iterator", "match", "replace", "search", "split", "hasInstance", "isConcatSpreadable", "unscopables", "species", "toPrimitive", a].forEach(function(s) {
                if (!(s in t))
                    switch (n(t, s, {
                        value: t(s)
                    }),
                    s) {
                    case a:
                        (r = e.getOwnPropertyDescriptor(i, "toString")).value = function() {
                            var e = o.call(this)
                              , r = null != this ? this[t.toStringTag] : this;
                            return null == r ? e : "[object " + r + "]"
                        }
                        ,
                        n(i, "toString", r)
                    }
            })
        }(Object, Symbol),
        function(e, t, r) {
            function n() {
                return this
            }
            t[e] || (t[e] = function() {
                var t = 0
                  , r = this
                  , i = {
                    next: function() {
                        var e = r.length <= t;
                        return e ? {
                            done: e
                        } : {
                            done: e,
                            value: r[t++]
                        }
                    }
                };
                return i[e] = n,
                i
            }
            ),
            r[e] || (r[e] = function() {
                var t = String.fromCodePoint
                  , r = this
                  , i = 0
                  , o = r.length
                  , a = {
                    next: function() {
                        var e = o <= i
                          , n = e ? "" : t(r.codePointAt(i));
                        return i += n.length,
                        e ? {
                            done: e
                        } : {
                            done: e,
                            value: n
                        }
                    }
                };
                return a[e] = n,
                a
            }
            )
        }(Symbol.iterator, Array.prototype, String.prototype),
        e.exports = Object.getOwnPropertySymbols
    }
    ).call(t, r(25))
}
, function(e, t, r) {
    "use strict";
    r(75)()
}
, function(e, t, r) {
    "use strict";
    !function(e) {
        function t(n) {
            if (r[n])
                return r[n].exports;
            var i = r[n] = {
                i: n,
                l: !1,
                exports: {}
            };
            return e[n].call(i.exports, i, i.exports, t),
            i.l = !0,
            i.exports
        }
        var r = {};
        t.m = e,
        t.c = r,
        t.d = function(e, r, n) {
            t.o(e, r) || Object.defineProperty(e, r, {
                configurable: !1,
                enumerable: !0,
                get: n
            })
        }
        ,
        t.n = function(e) {
            var r = e && e.__esModule ? function() {
                return e.default
            }
            : function() {
                return e
            }
            ;
            return t.d(r, "a", r),
            r
        }
        ,
        t.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }
        ,
        t.p = "",
        t(t.s = 0)
    }([function(e, t) {
        Array.from || (Array.from = function() {
            var e = Object.prototype.toString
              , t = function(t) {
                return "function" == typeof t || "[object Function]" === e.call(t)
            }
              , r = Math.pow(2, 53) - 1
              , n = function(e) {
                var t = function(e) {
                    var t = Number(e);
                    return isNaN(t) ? 0 : 0 !== t && isFinite(t) ? (t > 0 ? 1 : -1) * Math.floor(Math.abs(t)) : t
                }(e);
                return Math.min(Math.max(t, 0), r)
            };
            return function(e) {
                var r = Object(e);
                if (null == e)
                    throw new TypeError("Array.from requires an array-like object - not null or undefined");
                var i, o = arguments.length > 1 ? arguments[1] : void 0;
                if (void 0 !== o) {
                    if (!t(o))
                        throw new TypeError("Array.from: when provided, the second argument must be a function");
                    arguments.length > 2 && (i = arguments[2])
                }
                for (var a, s = n(r.length), c = t(this) ? Object(new this(s)) : new Array(s), l = 0; l < s; )
                    a = r[l],
                    c[l] = o ? void 0 === i ? o(a, l) : o.call(i, a, l) : a,
                    l += 1;
                return c.length = s,
                c
            }
        }())
    }
    ])
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
      , i = r(72)
      , o = "function" == typeof Symbol && "symbol" === n(Symbol("foo"))
      , a = Object.prototype.toString
      , s = Array.prototype.concat
      , c = Object.defineProperty
      , l = c && function() {
        var e = {};
        try {
            for (var t in c(e, "x", {
                enumerable: !1,
                value: e
            }),
            e)
                return !1;
            return e.x === e
        } catch (e) {
            return !1
        }
    }()
      , u = function(e, t, r, n) {
        (!(t in e) || function(e) {
            return "function" == typeof e && "[object Function]" === a.call(e)
        }(n) && n()) && (l ? c(e, t, {
            configurable: !0,
            enumerable: !1,
            value: r,
            writable: !0
        }) : e[t] = r)
    }
      , h = function(e, t) {
        var r = arguments.length > 2 ? arguments[2] : {}
          , n = i(t);
        o && (n = s.call(n, Object.getOwnPropertySymbols(t)));
        for (var a = 0; a < n.length; a += 1)
            u(e, n[a], t[n[a]], r[n[a]])
    };
    h.supportsDescriptors = !!l,
    e.exports = h
}
, function(e, t, r) {
    "use strict";
    e.exports = r(44)
}
, function(e, t, r) {
    "use strict";
    var n = r(14)("%TypeError%");
    e.exports = function(e, t) {
        if (null == e)
            throw new n(t || "Cannot call method on " + e);
        return e
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(16)
      , i = r(14)("%Function%")
      , o = i.apply
      , a = i.call;
    e.exports = function() {
        return n.apply(a, arguments)
    }
    ,
    e.exports.apply = function() {
        return n.apply(o, arguments)
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(14)
      , i = r(45)
      , o = i(n("String.prototype.indexOf"));
    e.exports = function(e, t) {
        var r = n(e, !!t);
        return "function" == typeof r && o(e, ".prototype.") ? i(r) : r
    }
}
, function(e, t, r) {
    "use strict";
    e.exports = function() {}
}
, function(e, t, r) {
    "use strict";
    e.exports = r(49)() ? Object.assign : r(50)
}
, function(e, t, r) {
    "use strict";
    e.exports = function() {
        var e, t = Object.assign;
        return "function" == typeof t && (t(e = {
            foo: "raz"
        }, {
            bar: "dwa"
        }, {
            trzy: "trzy"
        }),
        e.foo + e.bar + e.trzy === "razdwatrzy")
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(51)
      , i = r(55)
      , o = Math.max;
    e.exports = function(e, t) {
        var r, a, s, c = o(arguments.length, 2);
        for (e = Object(i(e)),
        s = function(n) {
            try {
                e[n] = t[n]
            } catch (e) {
                r || (r = e)
            }
        }
        ,
        a = 1; a < c; ++a)
            t = arguments[a],
            n(t).forEach(s);
        if (void 0 !== r)
            throw r;
        return e
    }
}
, function(e, t, r) {
    "use strict";
    e.exports = r(52)() ? Object.keys : r(53)
}
, function(e, t, r) {
    "use strict";
    e.exports = function() {
        try {
            return Object.keys("primitive"),
            !0
        } catch (e) {
            return !1
        }
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(15)
      , i = Object.keys;
    e.exports = function(e) {
        return i(n(e) ? Object(e) : e)
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(15)
      , i = Array.prototype.forEach
      , o = Object.create;
    e.exports = function(e) {
        var t = o(null);
        return i.call(arguments, function(e) {
            n(e) && function(e, t) {
                var r;
                for (r in e)
                    t[r] = e[r]
            }(Object(e), t)
        }),
        t
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(15);
    e.exports = function(e) {
        if (!n(e))
            throw new TypeError("Cannot use null or undefined");
        return e
    }
}
, function(e, t, r) {
    "use strict";
    e.exports = r(57)() ? String.prototype.contains : r(58)
}
, function(e, t, r) {
    "use strict";
    var n = "razdwatrzy";
    e.exports = function() {
        return "function" == typeof n.contains && (!0 === n.contains("dwa") && !1 === n.contains("foo"))
    }
}
, function(e, t, r) {
    "use strict";
    var n = String.prototype.indexOf;
    e.exports = function(e) {
        return n.call(this, e, arguments[1]) > -1
    }
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
      , i = r(12)
      , o = {
        object: !0,
        symbol: !0
    };
    e.exports = function() {
        var e, t = i.Symbol;
        if ("function" != typeof t)
            return !1;
        e = t("test symbol");
        try {
            String(e)
        } catch (e) {
            return !1
        }
        return !!o[n(t.iterator)] && (!!o[n(t.toPrimitive)] && !!o[n(t.toStringTag)])
    }
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    e.exports = function(e) {
        return !!e && ("symbol" === (void 0 === e ? "undefined" : n(e)) || !!e.constructor && ("Symbol" === e.constructor.name && "Symbol" === e[e.constructor.toStringTag]))
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(11)
      , i = Object.create
      , o = Object.defineProperty
      , a = Object.prototype
      , s = i(null);
    e.exports = function(e) {
        for (var t, r, i = 0; s[e + (i || "")]; )
            ++i;
        return s[e += i || ""] = !0,
        o(a, t = "@@" + e, n.gs(null, function(e) {
            r || (r = !0,
            o(this, t, n(e)),
            r = !1)
        })),
        t
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(11)
      , i = r(12).Symbol;
    e.exports = function(e) {
        return Object.defineProperties(e, {
            hasInstance: n("", i && i.hasInstance || e("hasInstance")),
            isConcatSpreadable: n("", i && i.isConcatSpreadable || e("isConcatSpreadable")),
            iterator: n("", i && i.iterator || e("iterator")),
            match: n("", i && i.match || e("match")),
            replace: n("", i && i.replace || e("replace")),
            search: n("", i && i.search || e("search")),
            species: n("", i && i.species || e("species")),
            split: n("", i && i.split || e("split")),
            toPrimitive: n("", i && i.toPrimitive || e("toPrimitive")),
            toStringTag: n("", i && i.toStringTag || e("toStringTag")),
            unscopables: n("", i && i.unscopables || e("unscopables"))
        })
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(11)
      , i = r(21)
      , o = Object.create(null);
    e.exports = function(e) {
        return Object.defineProperties(e, {
            for: n(function(t) {
                return o[t] ? o[t] : o[t] = e(String(t))
            }),
            keyFor: n(function(e) {
                var t;
                for (t in i(e),
                o)
                    if (o[t] === e)
                        return t
            })
        })
    }
}
, function(e, t, r) {
    "use strict";
    var n, i, o, a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    , s = r(11), c = r(21), l = r(12).Symbol, u = r(61), h = r(62), p = r(63), d = Object.create, f = Object.defineProperties, m = Object.defineProperty;
    if ("function" == typeof l)
        try {
            String(l()),
            o = !0
        } catch (e) {}
    else
        l = null;
    i = function(e) {
        if (this instanceof i)
            throw new TypeError("Symbol is not a constructor");
        return n(e)
    }
    ,
    e.exports = n = function e(t) {
        var r;
        if (this instanceof e)
            throw new TypeError("Symbol is not a constructor");
        return o ? l(t) : (r = d(i.prototype),
        t = void 0 === t ? "" : String(t),
        f(r, {
            __description__: s("", t),
            __name__: s("", u(t))
        }))
    }
    ,
    h(n),
    p(n),
    f(i.prototype, {
        constructor: s(n),
        toString: s("", function() {
            return this.__name__
        })
    }),
    f(n.prototype, {
        toString: s(function() {
            return "Symbol (" + c(this).__description__ + ")"
        }),
        valueOf: s(function() {
            return c(this)
        })
    }),
    m(n.prototype, n.toPrimitive, s("", function() {
        var e = c(this);
        return "symbol" === (void 0 === e ? "undefined" : a(e)) ? e : e.toString()
    })),
    m(n.prototype, n.toStringTag, s("c", "Symbol")),
    m(i.prototype, n.toStringTag, s("c", n.prototype[n.toStringTag])),
    m(i.prototype, n.toPrimitive, s("c", n.prototype[n.toPrimitive]))
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
      , i = function() {
        if ("object" === ("undefined" == typeof self ? "undefined" : n(self)) && self)
            return self;
        if ("object" === ("undefined" == typeof window ? "undefined" : n(window)) && window)
            return window;
        throw new Error("Unable to resolve global `this`")
    };
    e.exports = function() {
        if (this)
            return this;
        try {
            Object.defineProperty(Object.prototype, "__global__", {
                get: function() {
                    return this
                },
                configurable: !0
            })
        } catch (e) {
            return i()
        }
        try {
            return __global__ || i()
        } finally {
            delete Object.prototype.__global__
        }
    }()
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    e.exports = function() {
        return "object" === ("undefined" == typeof globalThis ? "undefined" : n(globalThis)) && (!!globalThis && globalThis.Array === Array)
    }
}
, function(e, t, r) {
    "use strict";
    var n = Array.prototype.slice
      , i = Object.prototype.toString;
    e.exports = function(e) {
        var t = this;
        if ("function" != typeof t || "[object Function]" !== i.call(t))
            throw new TypeError("Function.prototype.bind called on incompatible " + t);
        for (var r, o = n.call(arguments, 1), a = Math.max(0, t.length - o.length), s = [], c = 0; c < a; c++)
            s.push("$" + c);
        if (r = Function("binder", "return function (" + s.join(",") + "){ return binder.apply(this,arguments); }")(function() {
            if (this instanceof r) {
                var i = t.apply(this, o.concat(n.call(arguments)));
                return Object(i) === i ? i : this
            }
            return t.apply(e, o.concat(n.call(arguments)))
        }),
        t.prototype) {
            var l = function() {};
            l.prototype = t.prototype,
            r.prototype = new l,
            l.prototype = null
        }
        return r
    }
}
, function(e, t, r) {
    "use strict";
    (function(t) {
        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
          , i = t.Symbol
          , o = r(69);
        e.exports = function() {
            return "function" == typeof i && ("function" == typeof Symbol && ("symbol" === n(i("foo")) && ("symbol" === n(Symbol("bar")) && o())))
        }
    }
    ).call(t, r(25))
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    e.exports = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
            return !1;
        if ("symbol" === n(Symbol.iterator))
            return !0;
        var e = {}
          , t = Symbol("test")
          , r = Object(t);
        if ("string" == typeof t)
            return !1;
        if ("[object Symbol]" !== Object.prototype.toString.call(t))
            return !1;
        if ("[object Symbol]" !== Object.prototype.toString.call(r))
            return !1;
        for (t in e[t] = 42,
        e)
            return !1;
        if ("function" == typeof Object.keys && 0 !== Object.keys(e).length)
            return !1;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length)
            return !1;
        var i = Object.getOwnPropertySymbols(e);
        if (1 !== i.length || i[0] !== t)
            return !1;
        if (!Object.prototype.propertyIsEnumerable.call(e, t))
            return !1;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
            var o = Object.getOwnPropertyDescriptor(e, t);
            if (42 !== o.value || !0 !== o.enumerable)
                return !1
        }
        return !0
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(16);
    e.exports = n.call(Function.call, Object.prototype.hasOwnProperty)
}
, function(e, t, r) {
    "use strict";
    var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ;
    if (!Object.keys) {
        var o = Object.prototype.hasOwnProperty
          , a = Object.prototype.toString
          , s = r(22)
          , c = Object.prototype.propertyIsEnumerable
          , l = !c.call({
            toString: null
        }, "toString")
          , u = c.call(function() {}, "prototype")
          , h = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"]
          , p = function(e) {
            var t = e.constructor;
            return t && t.prototype === e
        }
          , d = {
            $applicationCache: !0,
            $console: !0,
            $external: !0,
            $frame: !0,
            $frameElement: !0,
            $frames: !0,
            $innerHeight: !0,
            $innerWidth: !0,
            $onmozfullscreenchange: !0,
            $onmozfullscreenerror: !0,
            $outerHeight: !0,
            $outerWidth: !0,
            $pageXOffset: !0,
            $pageYOffset: !0,
            $parent: !0,
            $scrollLeft: !0,
            $scrollTop: !0,
            $scrollX: !0,
            $scrollY: !0,
            $self: !0,
            $webkitIndexedDB: !0,
            $webkitStorageInfo: !0,
            $window: !0
        }
          , f = function() {
            if ("undefined" == typeof window)
                return !1;
            for (var e in window)
                try {
                    if (!d["$" + e] && o.call(window, e) && null !== window[e] && "object" === i(window[e]))
                        try {
                            p(window[e])
                        } catch (e) {
                            return !0
                        }
                } catch (e) {
                    return !0
                }
            return !1
        }();
        n = function(e) {
            var t = null !== e && "object" === (void 0 === e ? "undefined" : i(e))
              , r = "[object Function]" === a.call(e)
              , n = s(e)
              , c = t && "[object String]" === a.call(e)
              , d = [];
            if (!t && !r && !n)
                throw new TypeError("Object.keys called on a non-object");
            var m = u && r;
            if (c && e.length > 0 && !o.call(e, 0))
                for (var v = 0; v < e.length; ++v)
                    d.push(String(v));
            if (n && e.length > 0)
                for (var g = 0; g < e.length; ++g)
                    d.push(String(g));
            else
                for (var y in e)
                    m && "prototype" === y || !o.call(e, y) || d.push(String(y));
            if (l)
                for (var b = function(e) {
                    if ("undefined" == typeof window || !f)
                        return p(e);
                    try {
                        return p(e)
                    } catch (e) {
                        return !1
                    }
                }(e), x = 0; x < h.length; ++x)
                    b && "constructor" === h[x] || !o.call(e, h[x]) || d.push(h[x]);
            return d
        }
    }
    e.exports = n
}
, function(e, t, r) {
    "use strict";
    var n = Array.prototype.slice
      , i = r(22)
      , o = Object.keys
      , a = o ? function(e) {
        return o(e)
    }
    : r(71)
      , s = Object.keys;
    a.shim = function() {
        Object.keys ? function() {
            var e = Object.keys(arguments);
            return e && e.length === arguments.length
        }(1, 2) || (Object.keys = function(e) {
            return i(e) ? s(n.call(e)) : s(e)
        }
        ) : Object.keys = a;
        return Object.keys || a
    }
    ,
    e.exports = a
}
, function(e, t, r) {
    "use strict";
    var n = r(70)
      , i = r(43)
      , o = r(46)("Object.prototype.propertyIsEnumerable");
    e.exports = function(e) {
        var t = i(e)
          , r = [];
        for (var a in t)
            n(t, a) && o(t, a) && r.push(t[a]);
        return r
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(73);
    e.exports = function() {
        return "function" == typeof Object.values ? Object.values : n
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(74)
      , i = r(42);
    e.exports = function() {
        var e = n();
        return i(Object, {
            values: e
        }, {
            values: function() {
                return Object.values !== e
            }
        }),
        e
    }
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        ;
        !function(e, o, a) {
            function s(e) {
                var t = this
                  , r = function() {
                    var e = 4022871197;
                    return function(t) {
                        t = String(t);
                        for (var r = 0; r < t.length; r++) {
                            var n = .02519603282416938 * (e += t.charCodeAt(r));
                            n -= e = n >>> 0,
                            e = (n *= e) >>> 0,
                            e += 4294967296 * (n -= e)
                        }
                        return 2.3283064365386963e-10 * (e >>> 0)
                    }
                }();
                t.next = function() {
                    var e = 2091639 * t.s0 + 2.3283064365386963e-10 * t.c;
                    return t.s0 = t.s1,
                    t.s1 = t.s2,
                    t.s2 = e - (t.c = 0 | e)
                }
                ,
                t.c = 1,
                t.s0 = r(" "),
                t.s1 = r(" "),
                t.s2 = r(" "),
                t.s0 -= r(e),
                t.s0 < 0 && (t.s0 += 1),
                t.s1 -= r(e),
                t.s1 < 0 && (t.s1 += 1),
                t.s2 -= r(e),
                t.s2 < 0 && (t.s2 += 1),
                r = null
            }
            function c(e, t) {
                return t.c = e.c,
                t.s0 = e.s0,
                t.s1 = e.s1,
                t.s2 = e.s2,
                t
            }
            function l(e, t) {
                var r = new s(e)
                  , n = t && t.state
                  , o = r.next;
                return o.int32 = function() {
                    return 4294967296 * r.next() | 0
                }
                ,
                o.double = function() {
                    return o() + 1.1102230246251565e-16 * (2097152 * o() | 0)
                }
                ,
                o.quick = o,
                n && ("object" == (void 0 === n ? "undefined" : i(n)) && c(n, r),
                o.state = function() {
                    return c(r, {})
                }
                ),
                o
            }
            o && o.exports ? o.exports = l : r(2) && r(10) ? void 0 === (n = function() {
                return l
            }
            .call(t, r, t, o)) || (o.exports = n) : this.alea = l
        }(0, "object" == i(e) && e, r(2))
    }
    ).call(t, r(6)(e))
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        ;
        !function(e, o, a) {
            function s(e, t) {
                return t.a = e.a,
                t.b = e.b,
                t.c = e.c,
                t.d = e.d,
                t
            }
            function c(e, t) {
                var r = new function(e) {
                    var t = this
                      , r = "";
                    t.next = function() {
                        var e = t.b
                          , r = t.c
                          , n = t.d
                          , i = t.a;
                        return e = e << 25 ^ e >>> 7 ^ r,
                        r = r - n | 0,
                        n = n << 24 ^ n >>> 8 ^ i,
                        i = i - e | 0,
                        t.b = e = e << 20 ^ e >>> 12 ^ r,
                        t.c = r = r - n | 0,
                        t.d = n << 16 ^ r >>> 16 ^ i,
                        t.a = i - e | 0
                    }
                    ,
                    t.a = 0,
                    t.b = 0,
                    t.c = -1640531527,
                    t.d = 1367130551,
                    e === Math.floor(e) ? (t.a = e / 4294967296 | 0,
                    t.b = 0 | e) : r += e;
                    for (var n = 0; n < r.length + 20; n++)
                        t.b ^= 0 | r.charCodeAt(n),
                        t.next()
                }
                (e)
                  , n = t && t.state
                  , o = function() {
                    return (r.next() >>> 0) / 4294967296
                };
                return o.double = function() {
                    do {
                        var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }
                ,
                o.int32 = r.next,
                o.quick = o,
                n && ("object" == (void 0 === n ? "undefined" : i(n)) && s(n, r),
                o.state = function() {
                    return s(r, {})
                }
                ),
                o
            }
            o && o.exports ? o.exports = c : r(2) && r(10) ? void 0 === (n = function() {
                return c
            }
            .call(t, r, t, o)) || (o.exports = n) : this.tychei = c
        }(0, "object" == i(e) && e, r(2))
    }
    ).call(t, r(6)(e))
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        ;
        !function(e, o, a) {
            function s(e, t) {
                return t.x = e.x,
                t.y = e.y,
                t.z = e.z,
                t.w = e.w,
                t
            }
            function c(e, t) {
                var r = new function(e) {
                    var t = this
                      , r = "";
                    t.x = 0,
                    t.y = 0,
                    t.z = 0,
                    t.w = 0,
                    t.next = function() {
                        var e = t.x ^ t.x << 11;
                        return t.x = t.y,
                        t.y = t.z,
                        t.z = t.w,
                        t.w ^= t.w >>> 19 ^ e ^ e >>> 8
                    }
                    ,
                    e === (0 | e) ? t.x = e : r += e;
                    for (var n = 0; n < r.length + 64; n++)
                        t.x ^= 0 | r.charCodeAt(n),
                        t.next()
                }
                (e)
                  , n = t && t.state
                  , o = function() {
                    return (r.next() >>> 0) / 4294967296
                };
                return o.double = function() {
                    do {
                        var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }
                ,
                o.int32 = r.next,
                o.quick = o,
                n && ("object" == (void 0 === n ? "undefined" : i(n)) && s(n, r),
                o.state = function() {
                    return s(r, {})
                }
                ),
                o
            }
            o && o.exports ? o.exports = c : r(2) && r(10) ? void 0 === (n = function() {
                return c
            }
            .call(t, r, t, o)) || (o.exports = n) : this.xor128 = c
        }(0, "object" == i(e) && e, r(2))
    }
    ).call(t, r(6)(e))
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        var n;
        !function(e, i, o) {
            function a(e, t) {
                return t.i = e.i,
                t.w = e.w,
                t.X = e.X.slice(),
                t
            }
            function s(e, t) {
                null == e && (e = +new Date);
                var r = new function(e) {
                    var t = this;
                    t.next = function() {
                        var e, r, n = t.w, i = t.X, o = t.i;
                        return t.w = n = n + 1640531527 | 0,
                        r = i[o + 34 & 127],
                        e = i[o = o + 1 & 127],
                        r ^= r << 13,
                        e ^= e << 17,
                        r ^= r >>> 15,
                        e ^= e >>> 12,
                        r = i[o] = r ^ e,
                        t.i = o,
                        r + (n ^ n >>> 16) | 0
                    }
                    ,
                    function(e, t) {
                        var r, n, i, o, a, s = [], c = 128;
                        for (t === (0 | t) ? (n = t,
                        t = null) : (t += "\0",
                        n = 0,
                        c = Math.max(c, t.length)),
                        i = 0,
                        o = -32; o < c; ++o)
                            t && (n ^= t.charCodeAt((o + 32) % t.length)),
                            0 === o && (a = n),
                            n ^= n << 10,
                            n ^= n >>> 15,
                            n ^= n << 4,
                            n ^= n >>> 13,
                            o >= 0 && (a = a + 1640531527 | 0,
                            i = 0 == (r = s[127 & o] ^= n + a) ? i + 1 : 0);
                        for (i >= 128 && (s[127 & (t && t.length || 0)] = -1),
                        i = 127,
                        o = 512; o > 0; --o)
                            n = s[i + 34 & 127],
                            r = s[i = i + 1 & 127],
                            n ^= n << 13,
                            r ^= r << 17,
                            n ^= n >>> 15,
                            r ^= r >>> 12,
                            s[i] = n ^ r;
                        e.w = a,
                        e.X = s,
                        e.i = i
                    }(t, e)
                }
                (e)
                  , n = t && t.state
                  , i = function() {
                    return (r.next() >>> 0) / 4294967296
                };
                return i.double = function() {
                    do {
                        var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }
                ,
                i.int32 = r.next,
                i.quick = i,
                n && (n.X && a(n, r),
                i.state = function() {
                    return a(r, {})
                }
                ),
                i
            }
            i && i.exports ? i.exports = s : r(2) && r(10) ? void 0 === (n = function() {
                return s
            }
            .call(t, r, t, i)) || (i.exports = n) : this.xor4096 = s
        }(0, "object" == ("function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e) && e, r(2))
    }
    ).call(t, r(6)(e))
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        var n;
        !function(e, i, o) {
            function a(e, t) {
                return t.x = e.x.slice(),
                t.i = e.i,
                t
            }
            function s(e, t) {
                null == e && (e = +new Date);
                var r = new function(e) {
                    var t = this;
                    t.next = function() {
                        var e, r, n = t.x, i = t.i;
                        return e = n[i],
                        r = (e ^= e >>> 7) ^ e << 24,
                        r ^= (e = n[i + 1 & 7]) ^ e >>> 10,
                        r ^= (e = n[i + 3 & 7]) ^ e >>> 3,
                        r ^= (e = n[i + 4 & 7]) ^ e << 7,
                        e = n[i + 7 & 7],
                        r ^= (e ^= e << 13) ^ e << 9,
                        n[i] = r,
                        t.i = i + 1 & 7,
                        r
                    }
                    ,
                    function(e, t) {
                        var r, n = [];
                        if (t === (0 | t))
                            n[0] = t;
                        else
                            for (t = "" + t,
                            r = 0; r < t.length; ++r)
                                n[7 & r] = n[7 & r] << 15 ^ t.charCodeAt(r) + n[r + 1 & 7] << 13;
                        for (; n.length < 8; )
                            n.push(0);
                        for (r = 0; r < 8 && 0 === n[r]; ++r)
                            ;
                        for (8 == r ? n[7] = -1 : n[r],
                        e.x = n,
                        e.i = 0,
                        r = 256; r > 0; --r)
                            e.next()
                    }(t, e)
                }
                (e)
                  , n = t && t.state
                  , i = function() {
                    return (r.next() >>> 0) / 4294967296
                };
                return i.double = function() {
                    do {
                        var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }
                ,
                i.int32 = r.next,
                i.quick = i,
                n && (n.x && a(n, r),
                i.state = function() {
                    return a(r, {})
                }
                ),
                i
            }
            i && i.exports ? i.exports = s : r(2) && r(10) ? void 0 === (n = function() {
                return s
            }
            .call(t, r, t, i)) || (i.exports = n) : this.xorshift7 = s
        }(0, "object" == ("function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e) && e, r(2))
    }
    ).call(t, r(6)(e))
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        ;
        !function(e, o, a) {
            function s(e, t) {
                return t.x = e.x,
                t.y = e.y,
                t.z = e.z,
                t.w = e.w,
                t.v = e.v,
                t.d = e.d,
                t
            }
            function c(e, t) {
                var r = new function(e) {
                    var t = this
                      , r = "";
                    t.next = function() {
                        var e = t.x ^ t.x >>> 2;
                        return t.x = t.y,
                        t.y = t.z,
                        t.z = t.w,
                        t.w = t.v,
                        (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0
                    }
                    ,
                    t.x = 0,
                    t.y = 0,
                    t.z = 0,
                    t.w = 0,
                    t.v = 0,
                    e === (0 | e) ? t.x = e : r += e;
                    for (var n = 0; n < r.length + 64; n++)
                        t.x ^= 0 | r.charCodeAt(n),
                        n == r.length && (t.d = t.x << 10 ^ t.x >>> 4),
                        t.next()
                }
                (e)
                  , n = t && t.state
                  , o = function() {
                    return (r.next() >>> 0) / 4294967296
                };
                return o.double = function() {
                    do {
                        var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }
                ,
                o.int32 = r.next,
                o.quick = o,
                n && ("object" == (void 0 === n ? "undefined" : i(n)) && s(n, r),
                o.state = function() {
                    return s(r, {})
                }
                ),
                o
            }
            o && o.exports ? o.exports = c : r(2) && r(10) ? void 0 === (n = function() {
                return c
            }
            .call(t, r, t, o)) || (o.exports = n) : this.xorwow = c
        }(0, "object" == i(e) && e, r(2))
    }
    ).call(t, r(6)(e))
}
, function(e, t, r) {
    "use strict";
    (function(e) {
        var n, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        ;
        !function(o, a, s) {
            var c, l = 256, u = 6, h = "random", p = s.pow(l, u), d = s.pow(2, 52), f = 2 * d, m = l - 1;
            function v(e, t, r) {
                var n = []
                  , v = y(function e(t, r) {
                    var n, o = [], a = void 0 === t ? "undefined" : i(t);
                    if (r && "object" == a)
                        for (n in t)
                            try {
                                o.push(e(t[n], r - 1))
                            } catch (e) {}
                    return o.length ? o : "string" == a ? t : t + "\0"
                }((t = 1 == t ? {
                    entropy: !0
                } : t || {}).entropy ? [e, b(a)] : null == e ? function() {
                    try {
                        var e;
                        return c && (e = c.randomBytes) ? e = e(l) : (e = new Uint8Array(l),
                        (o.crypto || o.msCrypto).getRandomValues(e)),
                        b(e)
                    } catch (e) {
                        var t = o.navigator
                          , r = t && t.plugins;
                        return [+new Date, o, r, o.screen, b(a)]
                    }
                }() : e, 3), n)
                  , x = new function(e) {
                    var t, r = e.length, n = this, i = 0, o = n.i = n.j = 0, a = n.S = [];
                    r || (e = [r++]);
                    for (; i < l; )
                        a[i] = i++;
                    for (i = 0; i < l; i++)
                        a[i] = a[o = m & o + e[i % r] + (t = a[i])],
                        a[o] = t;
                    (n.g = function(e) {
                        for (var t, r = 0, i = n.i, o = n.j, a = n.S; e--; )
                            t = a[i = m & i + 1],
                            r = r * l + a[m & (a[i] = a[o = m & o + t]) + (a[o] = t)];
                        return n.i = i,
                        n.j = o,
                        r
                    }
                    )(l)
                }
                (n)
                  , w = function() {
                    for (var e = x.g(u), t = p, r = 0; e < d; )
                        e = (e + r) * l,
                        t *= l,
                        r = x.g(1);
                    for (; e >= f; )
                        e /= 2,
                        t /= 2,
                        r >>>= 1;
                    return (e + r) / t
                };
                return w.int32 = function() {
                    return 0 | x.g(4)
                }
                ,
                w.quick = function() {
                    return x.g(4) / 4294967296
                }
                ,
                w.double = w,
                y(b(x.S), a),
                (t.pass || r || function(e, t, r, n) {
                    return n && (n.S && g(n, x),
                    e.state = function() {
                        return g(x, {})
                    }
                    ),
                    r ? (s[h] = e,
                    t) : e
                }
                )(w, v, "global"in t ? t.global : this == s, t.state)
            }
            function g(e, t) {
                return t.i = e.i,
                t.j = e.j,
                t.S = e.S.slice(),
                t
            }
            function y(e, t) {
                for (var r, n = e + "", i = 0; i < n.length; )
                    t[m & i] = m & (r ^= 19 * t[m & i]) + n.charCodeAt(i++);
                return b(t)
            }
            function b(e) {
                return String.fromCharCode.apply(0, e)
            }
            if (y(s.random(), a),
            "object" == i(e) && e.exports) {
                e.exports = v;
                try {
                    c = r(105)
                } catch (e) {}
            } else
                void 0 === (n = function() {
                    return v
                }
                .call(t, r, t, e)) || (e.exports = n)
        }("undefined" != typeof self ? self : void 0, [], Math)
    }
    ).call(t, r(6)(e))
}
, function(e, t, r) {
    "use strict";
    var n = r(86);
    e.exports = function(e) {
        if ("function" != typeof e)
            return !1;
        if (!hasOwnProperty.call(e, "length"))
            return !1;
        try {
            if ("number" != typeof e.length)
                return !1;
            if ("function" != typeof e.call)
                return !1;
            if ("function" != typeof e.apply)
                return !1
        } catch (e) {
            return !1
        }
        return !n(e)
    }
}
, function(e, t, r) {
    "use strict";
    var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
      , i = r(24)
      , o = {
        object: !0,
        function: !0,
        undefined: !0
    };
    e.exports = function(e) {
        return !!i(e) && hasOwnProperty.call(o, void 0 === e ? "undefined" : n(e))
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(83)
      , i = /^\s*class[\s{/}]/
      , o = Function.prototype.toString;
    e.exports = function(e) {
        return !!n(e) && !i.test(o.call(e))
    }
}
, function(e, t, r) {
    "use strict";
    var n = r(84);
    e.exports = function(e) {
        if (!n(e))
            return !1;
        try {
            return !!e.constructor && e.constructor.prototype === e
        } catch (e) {
            return !1
        }
    }
}
, function(e, t, r) {
    "use strict";
    r(37),
    r(39),
    r(38),
    r(40);
    var n = c(r(1))
      , i = c(r(19))
      , o = c(r(5))
      , a = r(13)
      , s = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(20));
    function c(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }
    String.prototype.padStart || (String.prototype.padStart = function(e, t) {
        return e >>= 0,
        t = String(void 0 !== t ? t : " "),
        this.length > e ? String(this) : ((e -= this.length) > t.length && (t += t.repeat(e / t.length)),
        t.slice(0, e) + String(this))
    }
    ),
    (0,
    a.trackLoadingStarted)(),
    document.getElementById("load-text").innerText = "loading...",
    o.load(function(e) {
        document.getElementById("load-text").innerText = "starting...",
        s.default && (document.body.className = "mobile"),
        i.calculate(),
        n.init(e),
        (0,
        a.attemptSDKInit)(),
        (0,
        a.trackLoadingFinished)(),
        requestAnimationFrame(function() {
            document.body.className += " done-loading",
            window.setTimeout(function() {
                document.body.removeChild(document.getElementById("loading-screen"))
            }, 2e3)
        })
    })
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.tube = void 0;
    var n = function(e) {
        if (e && e.__esModule)
            return e;
        var t = {};
        if (null != e)
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        return t.default = e,
        t
    }(r(89));
    t.tube = n
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.type = t.center = void 0,
    t.create = function(e) {
        s.material = i.basicMaterial,
        s.material.vertexColors = n.FaceColors,
        e.add(o)
    }
    ,
    t.move = function(e) {
        o.position.z += e;
        var t = 2 * a;
        o.position.z > t && (o.position.z -= t)
    }
    ;
    var n = r(0)
      , i = r(1)
      , o = new n.Group
      , a = 7;
    t.center = {
        x: 0,
        y: 0
    },
    t.type = "tube";
    for (var s = void 0, c = 0; c < 50; c++) {
        var l = c % 2 == 0
          , u = l ? 4.5 : 4.7
          , h = (0,
        i.createCylinder)(u, a, 8);
        if (h.geometry.rotateX(.5 * Math.PI),
        h.geometry.translate(0, 0, c * -a),
        l) {
            var p = !0
              , d = !1
              , f = void 0;
            try {
                for (var m, v = h.geometry.faces[Symbol.iterator](); !(p = (m = v.next()).done); p = !0) {
                    m.value.color.setHex(8738)
                }
            } catch (e) {
                d = !0,
                f = e
            } finally {
                try {
                    !p && v.return && v.return()
                } finally {
                    if (d)
                        throw f
                }
            }
        }
        s ? s.geometry.merge(h.geometry) : s = h
    }
    s.receiveShadow = !0,
    o.add(s)
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(0);
    function i(e) {
        throw new Error(e)
    }
    var o = function(e) {
        this.manager = void 0 !== e ? e : n.DefaultLoadingManager,
        this.materials = null,
        this.regexp = {
            vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
            face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
            face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
            face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
            face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
            object_pattern: /^[og]\s*(.+)?/,
            smoothing_pattern: /^s\s+(\d+|on|off)/,
            material_library_pattern: /^mtllib /,
            material_use_pattern: /^usemtl /
        }
    };
    o.prototype = {
        constructor: o,
        load: function(e, t, r, o) {
            var a = this;
            this.onError = o || i;
            var s = new n.FileLoader(a.manager);
            s.setPath(this.path),
            s.load(e, function(e) {
                t(a.parse(e))
            }, r, o)
        },
        setPath: function(e) {
            this.path = e
        },
        setMaterials: function(e) {
            this.materials = e
        },
        _createParserState: function() {
            var e = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                uvs: [],
                materialLibraries: [],
                startObject: function(e, t) {
                    if (this.object && !1 === this.object.fromDeclaration)
                        return this.object.name = e,
                        void (this.object.fromDeclaration = !1 !== t);
                    var r = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0),
                    this.object = {
                        name: e || "",
                        fromDeclaration: !1 !== t,
                        geometry: {
                            vertices: [],
                            normals: [],
                            uvs: []
                        },
                        materials: [],
                        smooth: !0,
                        startMaterial: function(e, t) {
                            var r = this._finalize(!1);
                            r && (r.inherited || r.groupCount <= 0) && this.materials.splice(r.index, 1);
                            var n = {
                                index: this.materials.length,
                                name: e || "",
                                mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                smooth: void 0 !== r ? r.smooth : this.smooth,
                                groupStart: void 0 !== r ? r.groupEnd : 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: !1,
                                clone: function(e) {
                                    var t = {
                                        index: "number" == typeof e ? e : this.index,
                                        name: this.name,
                                        mtllib: this.mtllib,
                                        smooth: this.smooth,
                                        groupStart: 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: !1
                                    };
                                    return t.clone = this.clone.bind(t),
                                    t
                                }
                            };
                            return this.materials.push(n),
                            n
                        },
                        currentMaterial: function() {
                            if (this.materials.length > 0)
                                return this.materials[this.materials.length - 1]
                        },
                        _finalize: function(e) {
                            var t = this.currentMaterial();
                            if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3,
                            t.groupCount = t.groupEnd - t.groupStart,
                            t.inherited = !1),
                            e && this.materials.length > 1)
                                for (var r = this.materials.length - 1; r >= 0; r--)
                                    this.materials[r].groupCount <= 0 && this.materials.splice(r, 1);
                            return e && 0 === this.materials.length && this.materials.push({
                                name: "",
                                smooth: this.smooth
                            }),
                            t
                        }
                    },
                    r && r.name && "function" == typeof r.clone) {
                        var n = r.clone(0);
                        n.inherited = !0,
                        this.object.materials.push(n)
                    }
                    this.objects.push(this.object)
                },
                finalize: function() {
                    this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                },
                parseVertexIndex: function(e, t) {
                    var r = parseInt(e, 10);
                    return 3 * (r >= 0 ? r - 1 : r + t / 3)
                },
                parseNormalIndex: function(e, t) {
                    var r = parseInt(e, 10);
                    return 3 * (r >= 0 ? r - 1 : r + t / 3)
                },
                parseUVIndex: function(e, t) {
                    var r = parseInt(e, 10);
                    return 2 * (r >= 0 ? r - 1 : r + t / 2)
                },
                addVertex: function(e, t, r) {
                    var n = this.vertices
                      , i = this.object.geometry.vertices;
                    i.push(n[e + 0]),
                    i.push(n[e + 1]),
                    i.push(n[e + 2]),
                    i.push(n[t + 0]),
                    i.push(n[t + 1]),
                    i.push(n[t + 2]),
                    i.push(n[r + 0]),
                    i.push(n[r + 1]),
                    i.push(n[r + 2])
                },
                addVertexLine: function(e) {
                    var t = this.vertices
                      , r = this.object.geometry.vertices;
                    r.push(t[e + 0]),
                    r.push(t[e + 1]),
                    r.push(t[e + 2])
                },
                addNormal: function(e, t, r) {
                    var n = this.normals
                      , i = this.object.geometry.normals;
                    i.push(n[e + 0]),
                    i.push(n[e + 1]),
                    i.push(n[e + 2]),
                    i.push(n[t + 0]),
                    i.push(n[t + 1]),
                    i.push(n[t + 2]),
                    i.push(n[r + 0]),
                    i.push(n[r + 1]),
                    i.push(n[r + 2])
                },
                addUV: function(e, t, r) {
                    var n = this.uvs
                      , i = this.object.geometry.uvs;
                    i.push(n[e + 0]),
                    i.push(n[e + 1]),
                    i.push(n[t + 0]),
                    i.push(n[t + 1]),
                    i.push(n[r + 0]),
                    i.push(n[r + 1])
                },
                addUVLine: function(e) {
                    var t = this.uvs
                      , r = this.object.geometry.uvs;
                    r.push(t[e + 0]),
                    r.push(t[e + 1])
                },
                addFace: function(e, t, r, n, i, o, a, s, c, l, u, h) {
                    var p, d = this.vertices.length, f = this.parseVertexIndex(e, d), m = this.parseVertexIndex(t, d), v = this.parseVertexIndex(r, d);
                    if (void 0 === n ? this.addVertex(f, m, v) : (p = this.parseVertexIndex(n, d),
                    this.addVertex(f, m, p),
                    this.addVertex(m, v, p)),
                    void 0 !== i) {
                        var g = this.uvs.length;
                        f = this.parseUVIndex(i, g),
                        m = this.parseUVIndex(o, g),
                        v = this.parseUVIndex(a, g),
                        void 0 === n ? this.addUV(f, m, v) : (p = this.parseUVIndex(s, g),
                        this.addUV(f, m, p),
                        this.addUV(m, v, p))
                    }
                    if (void 0 !== c) {
                        var y = this.normals.length;
                        f = this.parseNormalIndex(c, y),
                        m = c === l ? f : this.parseNormalIndex(l, y),
                        v = c === u ? f : this.parseNormalIndex(u, y),
                        void 0 === n ? this.addNormal(f, m, v) : (p = this.parseNormalIndex(h, y),
                        this.addNormal(f, m, p),
                        this.addNormal(m, v, p))
                    }
                },
                addLineGeometry: function(e, t) {
                    this.object.geometry.type = "Line";
                    for (var r = this.vertices.length, n = this.uvs.length, i = 0, o = e.length; i < o; i++)
                        this.addVertexLine(this.parseVertexIndex(e[i], r));
                    var a = 0;
                    for (o = t.length; a < o; a++)
                        this.addUVLine(this.parseUVIndex(t[a], n))
                }
            };
            return e.startObject("", !1),
            e
        },
        parse: function(e, t) {
            void 0 === t && (t = !1),
            t && console.time("OBJLoader");
            var r = this._createParserState();
            -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")),
            -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
            for (var i = e.split("\n"), o = "", a = "", s = "", c = [], l = "function" == typeof "".trimLeft, u = 0, h = i.length; u < h; u++)
                if (o = i[u],
                0 !== (o = l ? o.trimLeft() : o.trim()).length && "#" !== (a = o.charAt(0)))
                    if ("v" === a)
                        " " === (s = o.charAt(1)) && null !== (c = this.regexp.vertex_pattern.exec(o)) ? r.vertices.push(parseFloat(c[1]), parseFloat(c[2]), parseFloat(c[3])) : "n" === s && null !== (c = this.regexp.normal_pattern.exec(o)) ? r.normals.push(parseFloat(c[1]), parseFloat(c[2]), parseFloat(c[3])) : "t" === s && null !== (c = this.regexp.uv_pattern.exec(o)) ? r.uvs.push(parseFloat(c[1]), parseFloat(c[2])) : this.onError("Unexpected vertex/normal/uv line: '" + o + "'");
                    else if ("f" === a)
                        null !== (c = this.regexp.face_vertex_uv_normal.exec(o)) ? r.addFace(c[1], c[4], c[7], c[10], c[2], c[5], c[8], c[11], c[3], c[6], c[9], c[12]) : null !== (c = this.regexp.face_vertex_uv.exec(o)) ? r.addFace(c[1], c[3], c[5], c[7], c[2], c[4], c[6], c[8]) : null !== (c = this.regexp.face_vertex_normal.exec(o)) ? r.addFace(c[1], c[3], c[5], c[7], void 0, void 0, void 0, void 0, c[2], c[4], c[6], c[8]) : null !== (c = this.regexp.face_vertex.exec(o)) ? r.addFace(c[1], c[2], c[3], c[4]) : this.onError("Unexpected face line: '" + o + "'");
                    else if ("l" === a) {
                        var p = o.substring(1).trim().split(" ")
                          , d = []
                          , f = [];
                        if (-1 === o.indexOf("/"))
                            d = p;
                        else
                            for (var m = 0, v = p.length; m < v; m++) {
                                var g = p[m].split("/");
                                "" !== g[0] && d.push(g[0]),
                                "" !== g[1] && f.push(g[1])
                            }
                        r.addLineGeometry(d, f)
                    } else if (null !== (c = this.regexp.object_pattern.exec(o))) {
                        var y = (" " + c[0].substr(1).trim()).substr(1);
                        r.startObject(y)
                    } else if (this.regexp.material_use_pattern.test(o))
                        r.object.startMaterial(o.substring(7).trim(), r.materialLibraries);
                    else if (this.regexp.material_library_pattern.test(o))
                        r.materialLibraries.push(o.substring(7).trim());
                    else if (null !== (c = this.regexp.smoothing_pattern.exec(o))) {
                        var b = c[1].trim().toLowerCase();
                        r.object.smooth = "1" === b || "on" === b,
                        (R = r.object.currentMaterial()) && (R.smooth = r.object.smooth)
                    } else {
                        if ("\0" === o)
                            continue;
                        this.onError("Unexpected line: '" + o + "'")
                    }
            r.finalize();
            var x = new n.Group;
            x.materialLibraries = [].concat(r.materialLibraries);
            for (u = 0,
            h = r.objects.length; u < h; u++) {
                var w = r.objects[u]
                  , _ = w.geometry
                  , M = w.materials
                  , S = "Line" === _.type;
                if (0 !== _.vertices.length) {
                    var E = new n.BufferGeometry;
                    E.addAttribute("position", new n.BufferAttribute(new Float32Array(_.vertices),3)),
                    _.normals.length > 0 ? E.addAttribute("normal", new n.BufferAttribute(new Float32Array(_.normals),3)) : E.computeVertexNormals(),
                    _.uvs.length > 0 && E.addAttribute("uv", new n.BufferAttribute(new Float32Array(_.uvs),2));
                    for (var T, A = [], L = 0, P = M.length; L < P; L++) {
                        var C = M[L]
                          , R = void 0;
                        if (null !== this.materials && (R = this.materials.create(C.name),
                        S && R && !(R instanceof n.LineBasicMaterial))) {
                            var O = new n.LineBasicMaterial;
                            O.copy(R),
                            R = O
                        }
                        R || ((R = S ? new n.LineBasicMaterial : new n.MeshPhongMaterial).name = C.name),
                        R.flatShading = !C.smooth,
                        A.push(R)
                    }
                    if (A.length > 1) {
                        for (L = 0,
                        P = M.length; L < P; L++) {
                            C = M[L];
                            E.addGroup(C.groupStart, C.groupCount, L)
                        }
                        var I = new n.MultiMaterial(A);
                        T = S ? new n.LineSegments(E,I) : new n.Mesh(E,I)
                    } else
                        T = S ? new n.LineSegments(E,A[0]) : new n.Mesh(E,A[0]);
                    T.name = w.name,
                    x.add(T)
                }
            }
            return t && console.timeEnd("OBJLoader"),
            x
        }
    },
    t.default = o
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }()
      , i = r(0)
      , o = l(r(28))
      , a = l(r(7))
      , s = r(3)
      , c = r(4);
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var u = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            this.collisionObstacles = [],
            this.group = new i.Group,
            this.basicObstacle = (0,
            o.default)(),
            this.collisionObstacles.push(this.basicObstacle.object),
            this.obstacleTrigger = (0,
            a.default)(),
            this.group.add(this.obstacleTrigger.object),
            this.group.add(this.basicObstacle.object)
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.basicObstacle.pool(),
                this.triggered ? this.triggered = !1 : this.obstacleTrigger.pool()
            }
        }, {
            key: "checkCollisions",
            value: function(e) {
                var t = !0
                  , r = !1
                  , n = void 0;
                try {
                    for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value
                          , l = !0
                          , u = !1
                          , h = void 0;
                        try {
                            for (var p, d = this.collisionObstacles[Symbol.iterator](); !(l = (p = d.next()).done); l = !0) {
                                var f = p.value;
                                if (!f.visible)
                                    return !1;
                                for (var m = a.intersectObjects(f.children), v = 0; v < m.length; v++)
                                    return gtag("event", "death", {
                                        event_category: "basic",
                                        event_label: (0,
                                        s.getCurrentLevelNumber)().toString().padStart(6, "0"),
                                        value: (0,
                                        c.getPercToLevelEnd)()
                                    }),
                                    "obstacle"
                            }
                        } catch (e) {
                            u = !0,
                            h = e
                        } finally {
                            try {
                                !l && d.return && d.return()
                            } finally {
                                if (u)
                                    throw h
                            }
                        }
                        if (!this.triggered) {
                            m = [];
                            if (this.obstacleTrigger.trigger.raycast(a, m),
                            m.length > 0)
                                return this.triggered = !0,
                                this.obstacleTrigger.pool(),
                                "obstacleTrigger"
                        }
                    }
                } catch (e) {
                    r = !0,
                    n = e
                } finally {
                    try {
                        !t && o.return && o.return()
                    } finally {
                        if (r)
                            throw n
                    }
                }
                return !1
            }
        }]),
        e
    }();
    t.default = u
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }()
      , i = r(0)
      , o = l(r(7))
      , a = l(r(29))
      , s = r(3)
      , c = r(4);
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var u = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            this.collisionObstacles = [],
            this.cylinderRows = [];
            var t = new i.Group
              , r = (0,
            a.default)();
            t.add(r.object),
            this.cylinderRows.push(r),
            this.collisionObstacles.push(r.object),
            this.obstacleTrigger = (0,
            o.default)(),
            t.add(this.obstacleTrigger.object),
            this.group = t
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.cylinderRows.forEach(function(e) {
                    return e.pool()
                }),
                this.cylinderRows = [],
                this.triggered ? this.triggered = !1 : this.obstacleTrigger.pool()
            }
        }, {
            key: "checkCollisions",
            value: function(e) {
                var t = !0
                  , r = !1
                  , n = void 0;
                try {
                    for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value
                          , l = !0
                          , u = !1
                          , h = void 0;
                        try {
                            for (var p, d = this.collisionObstacles[Symbol.iterator](); !(l = (p = d.next()).done); l = !0) {
                                var f = p.value;
                                if (!f.visible)
                                    return !1;
                                for (var m = a.intersectObjects(f.children), v = 0; v < m.length; v++)
                                    return gtag("event", "death", {
                                        event_category: "cylinderCorridor",
                                        event_label: (0,
                                        s.getCurrentLevelNumber)().toString().padStart(6, "0"),
                                        value: (0,
                                        c.getPercToLevelEnd)()
                                    }),
                                    "obstacle"
                            }
                        } catch (e) {
                            u = !0,
                            h = e
                        } finally {
                            try {
                                !l && d.return && d.return()
                            } finally {
                                if (u)
                                    throw h
                            }
                        }
                        if (!this.triggered) {
                            m = [];
                            if (this.obstacleTrigger.trigger.raycast(a, m),
                            m.length > 0)
                                return this.triggered = !0,
                                this.obstacleTrigger.pool(),
                                "obstacleTrigger"
                        }
                    }
                } catch (e) {
                    r = !0,
                    n = e
                } finally {
                    try {
                        !t && o.return && o.return()
                    } finally {
                        if (r)
                            throw n
                    }
                }
                return !1
            }
        }]),
        e
    }();
    u.defaultObstacleInterval = 15,
    t.default = u
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }()
      , i = r(0)
      , o = l(r(30))
      , a = l(r(7))
      , s = r(3)
      , c = r(4);
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var u = function() {
        function e(t) {
            var r = t.type
              , n = void 0 === r ? "single" : r;
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            this.poolBuffer = 20,
            this.collisionObstacles = [],
            this.group = new i.Group,
            this.fan = (0,
            o.default)(n),
            this.collisionObstacles.push(this.fan.object),
            this.obstacleTrigger = (0,
            a.default)(),
            this.obstacleTrigger.object.position.z = -20,
            this.group.add(this.fan.object),
            this.group.add(this.obstacleTrigger.object)
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.fan.pool(),
                this.triggered ? this.triggered = !1 : this.obstacleTrigger.pool()
            }
        }, {
            key: "update",
            value: function(e) {
                this.fan.update(e)
            }
        }, {
            key: "checkCollisions",
            value: function(e) {
                var t = !0
                  , r = !1
                  , n = void 0;
                try {
                    for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value
                          , l = !0
                          , u = !1
                          , h = void 0;
                        try {
                            for (var p, d = this.collisionObstacles[Symbol.iterator](); !(l = (p = d.next()).done); l = !0) {
                                var f = p.value;
                                if (!f.visible)
                                    return !1;
                                for (var m = a.intersectObjects(f.children), v = 0; v < m.length; v++)
                                    return gtag("event", "death", {
                                        event_category: "fan",
                                        event_label: (0,
                                        s.getCurrentLevelNumber)().toString().padStart(6, "0"),
                                        value: (0,
                                        c.getPercToLevelEnd)()
                                    }),
                                    "obstacle"
                            }
                        } catch (e) {
                            u = !0,
                            h = e
                        } finally {
                            try {
                                !l && d.return && d.return()
                            } finally {
                                if (u)
                                    throw h
                            }
                        }
                        if (!this.triggered) {
                            m = [];
                            if (this.obstacleTrigger.trigger.raycast(a, m),
                            m.length > 0)
                                return this.triggered = !0,
                                this.obstacleTrigger.pool(),
                                "obstacleTrigger"
                        }
                    }
                } catch (e) {
                    r = !0,
                    n = e
                } finally {
                    try {
                        !t && o.return && o.return()
                    } finally {
                        if (r)
                            throw n
                    }
                }
                return !1
            }
        }]),
        e
    }();
    u.defaultObstacleInterval = 100,
    t.default = u
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }()
      , i = r(0)
      , o = l(r(31))
      , a = l(r(7))
      , s = r(3)
      , c = r(4);
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var u = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            this.collisionObstacles = [],
            this.group = new i.Group,
            this.object = (0,
            o.default)(),
            this.collisionObstacles.push(this.object.object),
            this.obstacleTrigger = (0,
            a.default)(),
            this.group.add(this.object.object),
            this.group.add(this.obstacleTrigger.object)
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.object.pool(),
                this.triggered ? this.triggered = !1 : this.obstacleTrigger.pool()
            }
        }, {
            key: "distanceMoved",
            value: function(e) {
                this.object.distanceMoved(e)
            }
        }, {
            key: "checkCollisions",
            value: function(e) {
                var t = !0
                  , r = !1
                  , n = void 0;
                try {
                    for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value
                          , l = !0
                          , u = !1
                          , h = void 0;
                        try {
                            for (var p, d = this.collisionObstacles[Symbol.iterator](); !(l = (p = d.next()).done); l = !0) {
                                var f = p.value;
                                if (!f.visible)
                                    return !1;
                                for (var m = a.intersectObjects(f.children), v = 0; v < m.length; v++)
                                    return gtag("event", "death", {
                                        event_category: "risers",
                                        event_label: (0,
                                        s.getCurrentLevelNumber)().toString().padStart(6, "0"),
                                        value: (0,
                                        c.getPercToLevelEnd)()
                                    }),
                                    "obstacle"
                            }
                        } catch (e) {
                            u = !0,
                            h = e
                        } finally {
                            try {
                                !l && d.return && d.return()
                            } finally {
                                if (u)
                                    throw h
                            }
                        }
                        if (!this.triggered) {
                            m = [];
                            if (this.obstacleTrigger.trigger.raycast(a, m),
                            m.length > 0)
                                return this.triggered = !0,
                                this.obstacleTrigger.pool(),
                                "obstacleTrigger"
                        }
                    }
                } catch (e) {
                    r = !0,
                    n = e
                } finally {
                    try {
                        !t && o.return && o.return()
                    } finally {
                        if (r)
                            throw n
                    }
                }
                return !1
            }
        }]),
        e
    }();
    u.defaultObstacleInterval = 20,
    t.default = u
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }()
      , i = r(0)
      , o = l(r(32))
      , a = l(r(7))
      , s = r(3)
      , c = r(4);
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var u = function() {
        function e(t) {
            var r = t.direction
              , n = void 0 === r ? 1 : r;
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            this.collisionObstacles = [],
            this.group = new i.Group,
            this.spinner = (0,
            o.default)(),
            this.collisionObstacles.push(this.spinner.object),
            this.obstacleTrigger = (0,
            a.default)(),
            this.direction = n,
            this.group.add(this.spinner.object),
            this.group.add(this.obstacleTrigger.object)
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.spinner.pool(),
                this.triggered ? this.triggered = !1 : this.obstacleTrigger.pool()
            }
        }, {
            key: "update",
            value: function(e) {
                this.spinner.move(e, this.direction)
            }
        }, {
            key: "checkCollisions",
            value: function(e) {
                var t = !0
                  , r = !1
                  , n = void 0;
                try {
                    for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value
                          , l = !0
                          , u = !1
                          , h = void 0;
                        try {
                            for (var p, d = this.collisionObstacles[Symbol.iterator](); !(l = (p = d.next()).done); l = !0) {
                                var f = p.value;
                                if (!f.visible)
                                    return !1;
                                for (var m = a.intersectObjects(f.children), v = 0; v < m.length; v++)
                                    return gtag("event", "death", {
                                        event_category: "spinner",
                                        event_label: (0,
                                        s.getCurrentLevelNumber)().toString().padStart(6, "0"),
                                        value: (0,
                                        c.getPercToLevelEnd)()
                                    }),
                                    "obstacle"
                            }
                        } catch (e) {
                            u = !0,
                            h = e
                        } finally {
                            try {
                                !l && d.return && d.return()
                            } finally {
                                if (u)
                                    throw h
                            }
                        }
                        if (!this.triggered) {
                            m = [];
                            if (this.obstacleTrigger.trigger.raycast(a, m),
                            m.length > 0)
                                return this.triggered = !0,
                                this.obstacleTrigger.pool(),
                                "obstacleTrigger"
                        }
                    }
                } catch (e) {
                    r = !0,
                    n = e
                } finally {
                    try {
                        !t && o.return && o.return()
                    } finally {
                        if (r)
                            throw n
                    }
                }
                return !1
            }
        }]),
        e
    }();
    u.defaultObstacleInterval = 75,
    t.default = u
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = function() {
        function e(e, t) {
            for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(e, n.key, n)
            }
        }
        return function(t, r, n) {
            return r && e(t.prototype, r),
            n && e(t, n),
            t
        }
    }()
      , i = r(0)
      , o = l(r(33))
      , a = l(r(7))
      , s = r(3)
      , c = r(4);
    function l(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    var u = function() {
        function e() {
            !function(e, t) {
                if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function")
            }(this, e),
            this.collisionObstacles = [],
            this.group = new i.Group,
            this.tripleGap = (0,
            o.default)(),
            this.collisionObstacles.push(this.tripleGap.object),
            this.obstacleTrigger = (0,
            a.default)(),
            this.group.add(this.tripleGap.object),
            this.group.add(this.obstacleTrigger.object)
        }
        return n(e, [{
            key: "pool",
            value: function() {
                this.tripleGap.pool(),
                this.triggered ? this.triggered = !1 : this.obstacleTrigger.pool()
            }
        }, {
            key: "checkCollisions",
            value: function(e) {
                var t = !0
                  , r = !1
                  , n = void 0;
                try {
                    for (var i, o = e[Symbol.iterator](); !(t = (i = o.next()).done); t = !0) {
                        var a = i.value
                          , l = !0
                          , u = !1
                          , h = void 0;
                        try {
                            for (var p, d = this.collisionObstacles[Symbol.iterator](); !(l = (p = d.next()).done); l = !0) {
                                var f = p.value;
                                if (!f.visible)
                                    return !1;
                                for (var m = a.intersectObjects(f.children), v = 0; v < m.length; v++)
                                    return gtag("event", "death", {
                                        event_category: "tripleGap",
                                        event_label: (0,
                                        s.getCurrentLevelNumber)().toString().padStart(6, "0"),
                                        value: (0,
                                        c.getPercToLevelEnd)()
                                    }),
                                    "obstacle"
                            }
                        } catch (e) {
                            u = !0,
                            h = e
                        } finally {
                            try {
                                !l && d.return && d.return()
                            } finally {
                                if (u)
                                    throw h
                            }
                        }
                        if (!this.triggered) {
                            m = [];
                            if (this.obstacleTrigger.trigger.raycast(a, m),
                            m.length > 0)
                                return this.triggered = !0,
                                this.obstacleTrigger.pool(),
                                "obstacleTrigger"
                        }
                    }
                } catch (e) {
                    r = !0,
                    n = e
                } finally {
                    try {
                        !t && o.return && o.return()
                    } finally {
                        if (r)
                            throw n
                    }
                }
                return !1
            }
        }]),
        e
    }();
    t.default = u
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(0)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(8));
    t.default = function() {
        return (0,
        i.default)({
            id: "dodecahedron",
            name: "Dodecahedron",
            color: "black",
            object: function() {
                var e = new n.DodecahedronGeometry;
                return e.scale(1.3, 1.3, 1.3),
                new n.Mesh(e)
            }(),
            unlockLevel: 7,
            update: function(e) {
                this.object.rotation.y += .002 * e,
                this.object.rotation.z += .002 * e
            },
            hasParticles: !1
        })
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(5)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(8));
    t.default = function() {
        return (0,
        i.default)({
            id: "mark-five",
            name: "Mark Five",
            object: n.resources.models.ship5,
            color: "black",
            unlockLevel: 30
        })
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(5)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(8));
    t.default = function() {
        return (0,
        i.default)({
            id: "mark-four",
            name: "Mark Four",
            object: n.resources.models.ship4,
            color: "red",
            unlockLevel: 3
        })
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(5)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(8));
    t.default = function() {
        return (0,
        i.default)({
            id: "mark-one",
            name: "Mark One",
            object: n.resources.models.ship,
            unlockLevel: 0
        })
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(0)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(8))
      , o = r(35);
    t.default = function() {
        return (0,
        i.default)({
            id: "mark-six",
            name: "Mark Six",
            color: "white",
            object: function() {
                var e = new n.SphereGeometry(1,16,16);
                return e.scale(2, 1, 2),
                new n.Mesh(e)
            }(),
            applyShader: o.applyDistortion,
            unlockLevel: 40
        })
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(5)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(8));
    t.default = function() {
        return (0,
        i.default)({
            id: "mark-three",
            name: "Mark Three",
            object: n.resources.models.ship3,
            color: "white",
            unlockLevel: 12
        })
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var n = r(5)
      , i = function(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }(r(8));
    t.default = function() {
        return (0,
        i.default)({
            id: "mark-two",
            name: "Mark Two",
            object: n.resources.models.ship2,
            unlockLevel: 20
        })
    }
}
, function(e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.shakeAmount = void 0,
    t.shake = function() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .7
          , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 600;
        a = e,
        i = 0,
        o = t
    }
    ,
    t.update = function(e) {
        i += e;
        var t = (0,
        n.lerp)(a, 0, i / o);
        i <= o ? (s.x = (Math.random() - .5) * t,
        s.y = (Math.random() - .5) * t) : (s.x = 0,
        s.y = 0)
    }
    ;
    var n = r(1)
      , i = 1 / 0
      , o = 0
      , a = 0
      , s = t.shakeAmount = {
        x: 0,
        y: 0
    }
}
, function(e, t) {}
]);
